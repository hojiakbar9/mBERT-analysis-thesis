id,classname,method_name,method_sig,method_def_line,mut_location,mut_start,mut_end,mut_operator,orig_token,pred_token,pred_pos,pred_score,masked_expr,masked_seq
0,Base64.java,isUrlSafe,boolean isUrlSafe(),359,360,14538,14541,BinaryOperatorMutator,==,=,0,0.2843572,this.encodeTable <mask> org.apache.commons.codec.binary.Base64.URL_SAFE_ENCODE_TABLE,"boolean isUrlSafe() {
        return this.encodeTable<mask>URL_SAFE_ENCODE_TABLE;
    }"
1,Base64.java,isUrlSafe,boolean isUrlSafe(),359,360,14538,14541,BinaryOperatorMutator,==,IS,1,0.2492414,this.encodeTable <mask> org.apache.commons.codec.binary.Base64.URL_SAFE_ENCODE_TABLE,"boolean isUrlSafe() {
        return this.encodeTable<mask>URL_SAFE_ENCODE_TABLE;
    }"
2,Base64.java,isUrlSafe,boolean isUrlSafe(),359,360,14538,14541,BinaryOperatorMutator,==,.,2,0.2025588,this.encodeTable <mask> org.apache.commons.codec.binary.Base64.URL_SAFE_ENCODE_TABLE,"boolean isUrlSafe() {
        return this.encodeTable<mask>URL_SAFE_ENCODE_TABLE;
    }"
3,Base64.java,isUrlSafe,boolean isUrlSafe(),359,360,14538,14541,BinaryOperatorMutator,==,Is,3,0.079036824,this.encodeTable <mask> org.apache.commons.codec.binary.Base64.URL_SAFE_ENCODE_TABLE,"boolean isUrlSafe() {
        return this.encodeTable<mask>URL_SAFE_ENCODE_TABLE;
    }"
4,Base64.java,isUrlSafe,boolean isUrlSafe(),359,360,14538,14541,BinaryOperatorMutator,==,_,4,0.03650931,this.encodeTable <mask> org.apache.commons.codec.binary.Base64.URL_SAFE_ENCODE_TABLE,"boolean isUrlSafe() {
        return this.encodeTable<mask>URL_SAFE_ENCODE_TABLE;
    }"
5,Base64.java,isUrlSafe,boolean isUrlSafe(),359,360,14522,14537,IdentifierMutator-Variable,this.encodeTable,table,0,0.70714295,<mask>,"boolean isUrlSafe() {
        return<mask> == URL_SAFE_ENCODE_TABLE;
    }"
6,Base64.java,isUrlSafe,boolean isUrlSafe(),359,360,14522,14537,IdentifierMutator-Variable,this.encodeTable,encoding,1,0.062470734,<mask>,"boolean isUrlSafe() {
        return<mask> == URL_SAFE_ENCODE_TABLE;
    }"
7,Base64.java,isUrlSafe,boolean isUrlSafe(),359,360,14522,14537,IdentifierMutator-Variable,this.encodeTable,enc,2,0.022495214,<mask>,"boolean isUrlSafe() {
        return<mask> == URL_SAFE_ENCODE_TABLE;
    }"
8,Base64.java,isUrlSafe,boolean isUrlSafe(),359,360,14522,14537,IdentifierMutator-Variable,this.encodeTable,type,3,0.013758537,<mask>,"boolean isUrlSafe() {
        return<mask> == URL_SAFE_ENCODE_TABLE;
    }"
9,Base64.java,isUrlSafe,boolean isUrlSafe(),359,360,14522,14537,IdentifierMutator-Variable,this.encodeTable,tables,4,0.01133225,<mask>,"boolean isUrlSafe() {
        return<mask> == URL_SAFE_ENCODE_TABLE;
    }"
10,Base64.java,isUrlSafe,boolean isUrlSafe(),359,360,14522,14525,IdentifierMutator-ThisAccess,this,config,1,0.03620054,<mask>,"boolean isUrlSafe() {
        return<mask>.encodeTable == URL_SAFE_ENCODE_TABLE;
    }"
11,Base64.java,isUrlSafe,boolean isUrlSafe(),359,360,14522,14525,IdentifierMutator-ThisAccess,this,options,2,0.015777318,<mask>,"boolean isUrlSafe() {
        return<mask>.encodeTable == URL_SAFE_ENCODE_TABLE;
    }"
12,Base64.java,isUrlSafe,boolean isUrlSafe(),359,360,14522,14525,IdentifierMutator-ThisAccess,this,settings,3,0.014880351,<mask>,"boolean isUrlSafe() {
        return<mask>.encodeTable == URL_SAFE_ENCODE_TABLE;
    }"
13,Base64.java,isUrlSafe,boolean isUrlSafe(),359,360,14522,14525,IdentifierMutator-ThisAccess,this,env,4,0.009000222,<mask>,"boolean isUrlSafe() {
        return<mask>.encodeTable == URL_SAFE_ENCODE_TABLE;
    }"
14,Base64.java,isUrlSafe,boolean isUrlSafe(),359,360,14527,14537,FieldReferenceMutator,encodeTable,table,0,0.61776394,this.<mask>,"boolean isUrlSafe() {
        return this.<mask> == URL_SAFE_ENCODE_TABLE;
    }"
15,Base64.java,isUrlSafe,boolean isUrlSafe(),359,360,14527,14537,FieldReferenceMutator,encodeTable,enc,1,0.036451984,this.<mask>,"boolean isUrlSafe() {
        return this.<mask> == URL_SAFE_ENCODE_TABLE;
    }"
16,Base64.java,isUrlSafe,boolean isUrlSafe(),359,360,14527,14537,FieldReferenceMutator,encodeTable,code,2,0.03590355,this.<mask>,"boolean isUrlSafe() {
        return this.<mask> == URL_SAFE_ENCODE_TABLE;
    }"
17,Base64.java,isUrlSafe,boolean isUrlSafe(),359,360,14527,14537,FieldReferenceMutator,encodeTable,type,3,0.03188064,this.<mask>,"boolean isUrlSafe() {
        return this.<mask> == URL_SAFE_ENCODE_TABLE;
    }"
18,Base64.java,isUrlSafe,boolean isUrlSafe(),359,360,14527,14537,FieldReferenceMutator,encodeTable,name,4,0.025844902,this.<mask>,"boolean isUrlSafe() {
        return this.<mask> == URL_SAFE_ENCODE_TABLE;
    }"
19,Base64.java,isUrlSafe,boolean isUrlSafe(),359,360,14542,14562,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.URL_SAFE_ENCODE_TABLE,table,0,0.7777944,<mask>,"boolean isUrlSafe() {
        return this.encodeTable ==<mask>;
    }"
20,Base64.java,isUrlSafe,boolean isUrlSafe(),359,360,14542,14562,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.URL_SAFE_ENCODE_TABLE,null,1,0.05689768,<mask>,"boolean isUrlSafe() {
        return this.encodeTable ==<mask>;
    }"
21,Base64.java,isUrlSafe,boolean isUrlSafe(),359,360,14542,14562,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.URL_SAFE_ENCODE_TABLE,0,2,0.047562327,<mask>,"boolean isUrlSafe() {
        return this.encodeTable ==<mask>;
    }"
22,Base64.java,isUrlSafe,boolean isUrlSafe(),359,360,14542,14562,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.URL_SAFE_ENCODE_TABLE,TABLE,3,0.0229317,<mask>,"boolean isUrlSafe() {
        return this.encodeTable ==<mask>;
    }"
23,Base64.java,isUrlSafe,boolean isUrlSafe(),359,360,14542,14562,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.URL_SAFE_ENCODE_TABLE,1,4,0.010206895,<mask>,"boolean isUrlSafe() {
        return this.encodeTable ==<mask>;
    }"
24,Base64.java,isUrlSafe,boolean isUrlSafe(),359,360,14542,14562,FieldReferenceMutator,URL_SAFE_ENCODE_TABLE,table,0,0.7777944,org.apache.commons.codec.binary.Base64.<mask>,"boolean isUrlSafe() {
        return this.encodeTable ==<mask>;
    }"
25,Base64.java,isUrlSafe,boolean isUrlSafe(),359,360,14542,14562,FieldReferenceMutator,URL_SAFE_ENCODE_TABLE,null,1,0.05689768,org.apache.commons.codec.binary.Base64.<mask>,"boolean isUrlSafe() {
        return this.encodeTable ==<mask>;
    }"
26,Base64.java,isUrlSafe,boolean isUrlSafe(),359,360,14542,14562,FieldReferenceMutator,URL_SAFE_ENCODE_TABLE,0,2,0.047562327,org.apache.commons.codec.binary.Base64.<mask>,"boolean isUrlSafe() {
        return this.encodeTable ==<mask>;
    }"
27,Base64.java,isUrlSafe,boolean isUrlSafe(),359,360,14542,14562,FieldReferenceMutator,URL_SAFE_ENCODE_TABLE,TABLE,3,0.0229317,org.apache.commons.codec.binary.Base64.<mask>,"boolean isUrlSafe() {
        return this.encodeTable ==<mask>;
    }"
28,Base64.java,isUrlSafe,boolean isUrlSafe(),359,360,14542,14562,FieldReferenceMutator,URL_SAFE_ENCODE_TABLE,1,4,0.010206895,org.apache.commons.codec.binary.Base64.<mask>,"boolean isUrlSafe() {
        return this.encodeTable ==<mask>;
    }"
29,Base64.java,hasData,boolean hasData(),368,369,14794,14797,BinaryOperatorMutator,!=,==,0,0.7420034,this.buffer <mask> null,"boolean hasData() {
        return this.buffer<mask>null;
    }"
30,Base64.java,hasData,boolean hasData(),368,369,14794,14797,BinaryOperatorMutator,!=,=,2,0.046860874,this.buffer <mask> null,"boolean hasData() {
        return this.buffer<mask>null;
    }"
31,Base64.java,hasData,boolean hasData(),368,369,14794,14797,BinaryOperatorMutator,!=,==,3,0.015022981,this.buffer <mask> null,"boolean hasData() {
        return this.buffer<mask>null;
    }"
32,Base64.java,hasData,boolean hasData(),368,369,14794,14797,BinaryOperatorMutator,!=,===,4,0.014372619,this.buffer <mask> null,"boolean hasData() {
        return this.buffer<mask>null;
    }"
33,Base64.java,hasData,boolean hasData(),368,369,14783,14793,IdentifierMutator-Variable,this.buffer,data,0,0.8235272,<mask>,"boolean hasData() {
        return<mask> != null;
    }"
34,Base64.java,hasData,boolean hasData(),368,369,14783,14793,IdentifierMutator-Variable,this.buffer,result,1,0.025498437,<mask>,"boolean hasData() {
        return<mask> != null;
    }"
35,Base64.java,hasData,boolean hasData(),368,369,14783,14793,IdentifierMutator-Variable,this.buffer,response,2,0.006110003,<mask>,"boolean hasData() {
        return<mask> != null;
    }"
36,Base64.java,hasData,boolean hasData(),368,369,14783,14793,IdentifierMutator-Variable,this.buffer,value,3,0.0050241635,<mask>,"boolean hasData() {
        return<mask> != null;
    }"
37,Base64.java,hasData,boolean hasData(),368,369,14783,14793,IdentifierMutator-Variable,this.buffer,d,4,0.00488934,<mask>,"boolean hasData() {
        return<mask> != null;
    }"
38,Base64.java,hasData,boolean hasData(),368,369,14783,14786,IdentifierMutator-ThisAccess,this,buffer,1,0.019601444,<mask>,"boolean hasData() {
        return<mask>.buffer != null;
    }"
39,Base64.java,hasData,boolean hasData(),368,369,14783,14786,IdentifierMutator-ThisAccess,this,m,2,0.011960568,<mask>,"boolean hasData() {
        return<mask>.buffer != null;
    }"
40,Base64.java,hasData,boolean hasData(),368,369,14783,14786,IdentifierMutator-ThisAccess,this,b,3,0.0068625947,<mask>,"boolean hasData() {
        return<mask>.buffer != null;
    }"
41,Base64.java,hasData,boolean hasData(),368,369,14783,14786,IdentifierMutator-ThisAccess,this,data,4,0.006812522,<mask>,"boolean hasData() {
        return<mask>.buffer != null;
    }"
42,Base64.java,hasData,boolean hasData(),368,369,14788,14793,FieldReferenceMutator,buffer,data,0,0.8169109,this.<mask>,"boolean hasData() {
        return this.<mask> != null;
    }"
43,Base64.java,hasData,boolean hasData(),368,369,14788,14793,FieldReferenceMutator,buffer,next,1,0.015416469,this.<mask>,"boolean hasData() {
        return this.<mask> != null;
    }"
44,Base64.java,hasData,boolean hasData(),368,369,14788,14793,FieldReferenceMutator,buffer,value,2,0.010786855,this.<mask>,"boolean hasData() {
        return this.<mask> != null;
    }"
45,Base64.java,hasData,boolean hasData(),368,369,14788,14793,FieldReferenceMutator,buffer,table,3,0.008582931,this.<mask>,"boolean hasData() {
        return this.<mask> != null;
    }"
46,Base64.java,hasData,boolean hasData(),368,369,14798,14801,IdentifierMutator-Literal,null,buffer,1,0.0090063745,<mask>,"boolean hasData() {
        return this.buffer !=<mask>;
    }"
47,Base64.java,hasData,boolean hasData(),368,369,14798,14801,IdentifierMutator-Literal,null,0,2,0.008980388,<mask>,"boolean hasData() {
        return this.buffer !=<mask>;
    }"
48,Base64.java,hasData,boolean hasData(),368,369,14798,14801,IdentifierMutator-Literal,null,"""""",3,0.0042835455,<mask>,"boolean hasData() {
        return this.buffer !=<mask>;
    }"
49,Base64.java,hasData,boolean hasData(),368,369,14798,14801,IdentifierMutator-Literal,null,nil,4,0.0038371386,<mask>,"boolean hasData() {
        return this.buffer !=<mask>;
    }"
50,Base64.java,avail,int avail(),377,378,15000,15033,IdentifierMutator-Conditional,buffer!=null?pos-readPos:0,avail,0,0.6324072,<mask>,"int avail() {
        return<mask>;
    }"
51,Base64.java,avail,int avail(),377,378,15000,15033,IdentifierMutator-Conditional,buffer!=null?pos-readPos:0,0,1,0.11783128,<mask>,"int avail() {
        return<mask>;
    }"
52,Base64.java,avail,int avail(),377,378,15000,15033,IdentifierMutator-Conditional,buffer!=null?pos-readPos:0,1,2,0.05654944,<mask>,"int avail() {
        return<mask>;
    }"
53,Base64.java,avail,int avail(),377,378,15000,15033,IdentifierMutator-Conditional,buffer!=null?pos-readPos:0,available,3,0.04339945,<mask>,"int avail() {
        return<mask>;
    }"
54,Base64.java,avail,int avail(),377,378,15000,15033,IdentifierMutator-Conditional,buffer!=null?pos-readPos:0,capacity,4,0.014927301,<mask>,"int avail() {
        return<mask>;
    }"
55,Base64.java,avail,int avail(),377,378,15006,15009,BinaryOperatorMutator,!=,==,0,0.84894454,buffer <mask> null,"int avail() {
        return buffer<mask>null ? pos - readPos : 0;
    }"
56,Base64.java,avail,int avail(),377,378,15006,15009,BinaryOperatorMutator,!=,==,2,0.03189363,buffer <mask> null,"int avail() {
        return buffer<mask>null ? pos - readPos : 0;
    }"
57,Base64.java,avail,int avail(),377,378,15006,15009,BinaryOperatorMutator,!=,=,3,0.02440542,buffer <mask> null,"int avail() {
        return buffer<mask>null ? pos - readPos : 0;
    }"
58,Base64.java,avail,int avail(),377,378,15006,15009,BinaryOperatorMutator,!=,.,4,0.0037829767,buffer <mask> null,"int avail() {
        return buffer<mask>null ? pos - readPos : 0;
    }"
59,Base64.java,avail,int avail(),377,378,15000,15005,IdentifierMutator-Variable,buffer,pos,0,0.6842773,<mask>,"int avail() {
        return<mask> != null ? pos - readPos : 0;
    }"
60,Base64.java,avail,int avail(),377,378,15000,15005,IdentifierMutator-Variable,buffer,position,1,0.03559566,<mask>,"int avail() {
        return<mask> != null ? pos - readPos : 0;
    }"
61,Base64.java,avail,int avail(),377,378,15000,15005,IdentifierMutator-Variable,buffer,buf,2,0.02107256,<mask>,"int avail() {
        return<mask> != null ? pos - readPos : 0;
    }"
62,Base64.java,avail,int avail(),377,378,15000,15005,IdentifierMutator-Variable,buffer,reader,4,0.011582953,<mask>,"int avail() {
        return<mask> != null ? pos - readPos : 0;
    }"
63,Base64.java,avail,int avail(),377,378,15000,15005,FieldReferenceMutator,buffer,pos,0,0.6842773,<mask>,"int avail() {
        return<mask> != null ? pos - readPos : 0;
    }"
64,Base64.java,avail,int avail(),377,378,15000,15005,FieldReferenceMutator,buffer,position,1,0.03559566,<mask>,"int avail() {
        return<mask> != null ? pos - readPos : 0;
    }"
65,Base64.java,avail,int avail(),377,378,15000,15005,FieldReferenceMutator,buffer,buf,2,0.02107256,<mask>,"int avail() {
        return<mask> != null ? pos - readPos : 0;
    }"
66,Base64.java,avail,int avail(),377,378,15000,15005,FieldReferenceMutator,buffer,reader,4,0.011582953,<mask>,"int avail() {
        return<mask> != null ? pos - readPos : 0;
    }"
67,Base64.java,avail,int avail(),377,378,15010,15013,IdentifierMutator-Literal,null,0,2,3.0271194E-4,<mask>,"int avail() {
        return buffer !=<mask> ? pos - readPos : 0;
    }"
68,Base64.java,avail,int avail(),377,378,15010,15013,IdentifierMutator-Literal,null,nil,3,1.8120975E-4,<mask>,"int avail() {
        return buffer !=<mask> ? pos - readPos : 0;
    }"
69,Base64.java,avail,int avail(),377,378,15010,15013,IdentifierMutator-Literal,null,NULL,4,1.6804806E-4,<mask>,"int avail() {
        return buffer !=<mask> ? pos - readPos : 0;
    }"
70,Base64.java,avail,int avail(),377,378,15020,15022,BinaryOperatorMutator,-,+,1,0.3186232,pos <mask> readPos,"int avail() {
        return buffer != null ? pos<mask>readPos : 0;
    }"
71,Base64.java,avail,int avail(),377,378,15020,15022,BinaryOperatorMutator,-,.,2,0.03662823,pos <mask> readPos,"int avail() {
        return buffer != null ? pos<mask>readPos : 0;
    }"
72,Base64.java,avail,int avail(),377,378,15020,15022,BinaryOperatorMutator,-,/,4,0.013476046,pos <mask> readPos,"int avail() {
        return buffer != null ? pos<mask>readPos : 0;
    }"
73,Base64.java,avail,int avail(),377,378,15017,15019,IdentifierMutator-Variable,pos,buffer,0,0.38500774,<mask>,"int avail() {
        return buffer != null ?<mask> - readPos : 0;
    }"
74,Base64.java,avail,int avail(),377,378,15017,15019,IdentifierMutator-Variable,pos,position,1,0.25913656,<mask>,"int avail() {
        return buffer != null ?<mask> - readPos : 0;
    }"
75,Base64.java,avail,int avail(),377,378,15017,15019,IdentifierMutator-Variable,pos,limit,2,0.04765534,<mask>,"int avail() {
        return buffer != null ?<mask> - readPos : 0;
    }"
76,Base64.java,avail,int avail(),377,378,15017,15019,IdentifierMutator-Variable,pos,available,3,0.03913235,<mask>,"int avail() {
        return buffer != null ?<mask> - readPos : 0;
    }"
77,Base64.java,avail,int avail(),377,378,15017,15019,FieldReferenceMutator,pos,buffer,0,0.38500774,<mask>,"int avail() {
        return buffer != null ?<mask> - readPos : 0;
    }"
78,Base64.java,avail,int avail(),377,378,15017,15019,FieldReferenceMutator,pos,position,1,0.25913656,<mask>,"int avail() {
        return buffer != null ?<mask> - readPos : 0;
    }"
79,Base64.java,avail,int avail(),377,378,15017,15019,FieldReferenceMutator,pos,limit,2,0.04765534,<mask>,"int avail() {
        return buffer != null ?<mask> - readPos : 0;
    }"
80,Base64.java,avail,int avail(),377,378,15017,15019,FieldReferenceMutator,pos,available,3,0.03913235,<mask>,"int avail() {
        return buffer != null ?<mask> - readPos : 0;
    }"
81,Base64.java,avail,int avail(),377,378,15023,15029,IdentifierMutator-Variable,readPos,buffer,0,0.8479305,<mask>,"int avail() {
        return buffer != null ? pos -<mask> : 0;
    }"
82,Base64.java,avail,int avail(),377,378,15023,15029,IdentifierMutator-Variable,readPos,avail,1,0.043809254,<mask>,"int avail() {
        return buffer != null ? pos -<mask> : 0;
    }"
83,Base64.java,avail,int avail(),377,378,15023,15029,IdentifierMutator-Variable,readPos,available,2,0.013781001,<mask>,"int avail() {
        return buffer != null ? pos -<mask> : 0;
    }"
84,Base64.java,avail,int avail(),377,378,15023,15029,IdentifierMutator-Variable,readPos,1,3,0.009437389,<mask>,"int avail() {
        return buffer != null ? pos -<mask> : 0;
    }"
85,Base64.java,avail,int avail(),377,378,15023,15029,IdentifierMutator-Variable,readPos,start,4,0.009393641,<mask>,"int avail() {
        return buffer != null ? pos -<mask> : 0;
    }"
86,Base64.java,avail,int avail(),377,378,15023,15029,FieldReferenceMutator,readPos,buffer,0,0.8479305,<mask>,"int avail() {
        return buffer != null ? pos -<mask> : 0;
    }"
87,Base64.java,avail,int avail(),377,378,15023,15029,FieldReferenceMutator,readPos,avail,1,0.043809254,<mask>,"int avail() {
        return buffer != null ? pos -<mask> : 0;
    }"
88,Base64.java,avail,int avail(),377,378,15023,15029,FieldReferenceMutator,readPos,available,2,0.013781001,<mask>,"int avail() {
        return buffer != null ? pos -<mask> : 0;
    }"
89,Base64.java,avail,int avail(),377,378,15023,15029,FieldReferenceMutator,readPos,1,3,0.009437389,<mask>,"int avail() {
        return buffer != null ? pos -<mask> : 0;
    }"
90,Base64.java,avail,int avail(),377,378,15023,15029,FieldReferenceMutator,readPos,start,4,0.009393641,<mask>,"int avail() {
        return buffer != null ? pos -<mask> : 0;
    }"
91,Base64.java,avail,int avail(),377,378,15033,15033,IdentifierMutator-Literal,0,pos,1,0.053147975,<mask>,"int avail() {
        return buffer != null ? pos - readPos :<mask>;
    }"
92,Base64.java,avail,int avail(),377,378,15033,15033,IdentifierMutator-Literal,0,avail,2,0.04842747,<mask>,"int avail() {
        return buffer != null ? pos - readPos :<mask>;
    }"
93,Base64.java,avail,int avail(),377,378,15033,15033,IdentifierMutator-Literal,0,position,3,0.011988309,<mask>,"int avail() {
        return buffer != null ? pos - readPos :<mask>;
    }"
94,Base64.java,avail,int avail(),377,378,15033,15033,IdentifierMutator-Literal,0,1,4,0.009000819,<mask>,"int avail() {
        return buffer != null ? pos - readPos :<mask>;
    }"
95,Base64.java,resizeBuffer,void resizeBuffer(),382,383,15126,15129,BinaryOperatorMutator,==,=,2,0.038895022,buffer <mask> null,"void resizeBuffer() {
        if (buffer<mask>null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
96,Base64.java,resizeBuffer,void resizeBuffer(),382,383,15126,15129,BinaryOperatorMutator,==,!=,3,0.0037705088,buffer <mask> null,"void resizeBuffer() {
        if (buffer<mask>null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
97,Base64.java,resizeBuffer,void resizeBuffer(),382,383,15126,15129,BinaryOperatorMutator,==,_,4,8.9660665E-4,buffer <mask> null,"void resizeBuffer() {
        if (buffer<mask>null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
98,Base64.java,resizeBuffer,void resizeBuffer(),382,383,15120,15125,IdentifierMutator-Variable,buffer,Buffer,2,3.5758392E-4,<mask>,"void resizeBuffer() {
        if (<mask> == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
99,Base64.java,resizeBuffer,void resizeBuffer(),382,383,15120,15125,IdentifierMutator-Variable,buffer,buf,3,2.1959419E-4,<mask>,"void resizeBuffer() {
        if (<mask> == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
100,Base64.java,resizeBuffer,void resizeBuffer(),382,383,15120,15125,IdentifierMutator-Variable,buffer,source,4,2.0003051E-4,<mask>,"void resizeBuffer() {
        if (<mask> == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
101,Base64.java,resizeBuffer,void resizeBuffer(),382,383,15120,15125,FieldReferenceMutator,buffer,Buffer,2,3.5758392E-4,<mask>,"void resizeBuffer() {
        if (<mask> == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
102,Base64.java,resizeBuffer,void resizeBuffer(),382,383,15120,15125,FieldReferenceMutator,buffer,buf,3,2.1959419E-4,<mask>,"void resizeBuffer() {
        if (<mask> == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
103,Base64.java,resizeBuffer,void resizeBuffer(),382,383,15120,15125,FieldReferenceMutator,buffer,source,4,2.0003051E-4,<mask>,"void resizeBuffer() {
        if (<mask> == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
104,Base64.java,resizeBuffer,void resizeBuffer(),382,383,15130,15133,IdentifierMutator-Literal,null,0,1,4.752759E-4,<mask>,"void resizeBuffer() {
        if (buffer ==<mask>) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
105,Base64.java,resizeBuffer,void resizeBuffer(),382,383,15130,15133,IdentifierMutator-Literal,null,nil,2,3.5452028E-4,<mask>,"void resizeBuffer() {
        if (buffer ==<mask>) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
106,Base64.java,resizeBuffer,void resizeBuffer(),382,383,15130,15133,IdentifierMutator-Literal,null,NULL,3,3.0958635E-4,<mask>,"void resizeBuffer() {
        if (buffer ==<mask>) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
107,Base64.java,resizeBuffer,void resizeBuffer(),382,384,15156,15156,AssignmentMutator,buffer=newbyte[org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_SIZE],*,0,0.5153762,buffer <mask>= new byte[org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_SIZE],"void resizeBuffer() {
        if (buffer == null) {
            buffer<mask>= new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
108,Base64.java,resizeBuffer,void resizeBuffer(),382,384,15156,15156,AssignmentMutator,buffer=newbyte[org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_SIZE],|,1,0.17859434,buffer <mask>= new byte[org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_SIZE],"void resizeBuffer() {
        if (buffer == null) {
            buffer<mask>= new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
109,Base64.java,resizeBuffer,void resizeBuffer(),382,384,15156,15156,AssignmentMutator,buffer=newbyte[org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_SIZE],[],2,0.08555169,buffer <mask>= new byte[org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_SIZE],"void resizeBuffer() {
        if (buffer == null) {
            buffer<mask>= new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
110,Base64.java,resizeBuffer,void resizeBuffer(),382,384,15156,15156,AssignmentMutator,buffer=newbyte[org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_SIZE],||,3,0.036428154,buffer <mask>= new byte[org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_SIZE],"void resizeBuffer() {
        if (buffer == null) {
            buffer<mask>= new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
111,Base64.java,resizeBuffer,void resizeBuffer(),382,384,15156,15156,AssignmentMutator,buffer=newbyte[org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_SIZE],=,4,0.022377187,buffer <mask>= new byte[org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_SIZE],"void resizeBuffer() {
        if (buffer == null) {
            buffer<mask>= new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
112,Base64.java,resizeBuffer,void resizeBuffer(),382,384,15150,15155,IdentifierMutator-Variable,buffer,b,2,3.3286124E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {<mask> = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
113,Base64.java,resizeBuffer,void resizeBuffer(),382,384,15150,15155,IdentifierMutator-Variable,buffer,buf,3,2.9198776E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {<mask> = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
114,Base64.java,resizeBuffer,void resizeBuffer(),382,384,15150,15155,IdentifierMutator-Variable,buffer,buff,4,1.0084516E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {<mask> = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
115,Base64.java,resizeBuffer,void resizeBuffer(),382,384,15150,15155,FieldReferenceMutator,buffer,b,2,3.3286124E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {<mask> = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
116,Base64.java,resizeBuffer,void resizeBuffer(),382,384,15150,15155,FieldReferenceMutator,buffer,buf,3,2.9198776E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {<mask> = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
117,Base64.java,resizeBuffer,void resizeBuffer(),382,384,15150,15155,FieldReferenceMutator,buffer,buff,4,1.0084516E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {<mask> = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
118,Base64.java,resizeBuffer,void resizeBuffer(),382,384,15168,15186,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_SIZE,size,0,0.34460708,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[<mask>];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
119,Base64.java,resizeBuffer,void resizeBuffer(),382,384,15168,15186,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_SIZE,0,1,0.13565125,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[<mask>];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
120,Base64.java,resizeBuffer,void resizeBuffer(),382,384,15168,15186,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_SIZE,capacity,2,0.12566428,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[<mask>];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
121,Base64.java,resizeBuffer,void resizeBuffer(),382,384,15168,15186,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_SIZE,1024,3,0.029645784,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[<mask>];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
122,Base64.java,resizeBuffer,void resizeBuffer(),382,384,15168,15186,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_SIZE,length,4,0.025477322,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[<mask>];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
123,Base64.java,resizeBuffer,void resizeBuffer(),382,384,15168,15186,FieldReferenceMutator,DEFAULT_BUFFER_SIZE,size,0,0.34460708,org.apache.commons.codec.binary.Base64.<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[<mask>];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
124,Base64.java,resizeBuffer,void resizeBuffer(),382,384,15168,15186,FieldReferenceMutator,DEFAULT_BUFFER_SIZE,0,1,0.13565125,org.apache.commons.codec.binary.Base64.<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[<mask>];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
125,Base64.java,resizeBuffer,void resizeBuffer(),382,384,15168,15186,FieldReferenceMutator,DEFAULT_BUFFER_SIZE,capacity,2,0.12566428,org.apache.commons.codec.binary.Base64.<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[<mask>];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
126,Base64.java,resizeBuffer,void resizeBuffer(),382,384,15168,15186,FieldReferenceMutator,DEFAULT_BUFFER_SIZE,1024,3,0.029645784,org.apache.commons.codec.binary.Base64.<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[<mask>];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
127,Base64.java,resizeBuffer,void resizeBuffer(),382,384,15168,15186,FieldReferenceMutator,DEFAULT_BUFFER_SIZE,length,4,0.025477322,org.apache.commons.codec.binary.Base64.<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[<mask>];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
128,Base64.java,resizeBuffer,void resizeBuffer(),382,385,15205,15205,AssignmentMutator,pos=0,|,0,0.39245072,pos <mask>= 0,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos<mask>= 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
129,Base64.java,resizeBuffer,void resizeBuffer(),382,385,15205,15205,AssignmentMutator,pos=0,*,1,0.27559638,pos <mask>= 0,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos<mask>= 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
130,Base64.java,resizeBuffer,void resizeBuffer(),382,385,15205,15205,AssignmentMutator,pos=0,&,2,0.05735226,pos <mask>= 0,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos<mask>= 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
131,Base64.java,resizeBuffer,void resizeBuffer(),382,385,15205,15205,AssignmentMutator,pos=0,^,3,0.056953393,pos <mask>= 0,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos<mask>= 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
132,Base64.java,resizeBuffer,void resizeBuffer(),382,385,15205,15205,AssignmentMutator,pos=0,<<,4,0.027322184,pos <mask>= 0,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos<mask>= 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
133,Base64.java,resizeBuffer,void resizeBuffer(),382,385,15202,15204,IdentifierMutator-Variable,pos,position,1,0.247314,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];<mask> = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
134,Base64.java,resizeBuffer,void resizeBuffer(),382,385,15202,15204,IdentifierMutator-Variable,pos,offset,2,0.1119119,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];<mask> = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
135,Base64.java,resizeBuffer,void resizeBuffer(),382,385,15202,15204,IdentifierMutator-Variable,pos,size,3,0.048590504,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];<mask> = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
136,Base64.java,resizeBuffer,void resizeBuffer(),382,385,15202,15204,IdentifierMutator-Variable,pos,length,4,0.034745116,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];<mask> = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
137,Base64.java,resizeBuffer,void resizeBuffer(),382,385,15202,15204,FieldReferenceMutator,pos,position,1,0.247314,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];<mask> = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
138,Base64.java,resizeBuffer,void resizeBuffer(),382,385,15202,15204,FieldReferenceMutator,pos,offset,2,0.1119119,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];<mask> = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
139,Base64.java,resizeBuffer,void resizeBuffer(),382,385,15202,15204,FieldReferenceMutator,pos,size,3,0.048590504,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];<mask> = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
140,Base64.java,resizeBuffer,void resizeBuffer(),382,385,15202,15204,FieldReferenceMutator,pos,length,4,0.034745116,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];<mask> = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
141,Base64.java,resizeBuffer,void resizeBuffer(),382,385,15208,15208,IdentifierMutator-Literal,0,pos,1,0.013057393,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos =<mask>;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
142,Base64.java,resizeBuffer,void resizeBuffer(),382,385,15208,15208,IdentifierMutator-Literal,0,1,2,0.005226168,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos =<mask>;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
143,Base64.java,resizeBuffer,void resizeBuffer(),382,385,15208,15208,IdentifierMutator-Literal,0,position,3,0.005217901,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos =<mask>;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
144,Base64.java,resizeBuffer,void resizeBuffer(),382,385,15208,15208,IdentifierMutator-Literal,0,size,4,0.0017768156,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos =<mask>;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
145,Base64.java,resizeBuffer,void resizeBuffer(),382,386,15230,15230,AssignmentMutator,readPos=0,|,0,0.37869298,readPos <mask>= 0,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos<mask>= 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
146,Base64.java,resizeBuffer,void resizeBuffer(),382,386,15230,15230,AssignmentMutator,readPos=0,*,1,0.21572544,readPos <mask>= 0,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos<mask>= 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
147,Base64.java,resizeBuffer,void resizeBuffer(),382,386,15230,15230,AssignmentMutator,readPos=0,&,2,0.16219305,readPos <mask>= 0,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos<mask>= 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
148,Base64.java,resizeBuffer,void resizeBuffer(),382,386,15230,15230,AssignmentMutator,readPos=0,/,3,0.05325817,readPos <mask>= 0,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos<mask>= 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
149,Base64.java,resizeBuffer,void resizeBuffer(),382,386,15230,15230,AssignmentMutator,readPos=0,^,4,0.048508678,readPos <mask>= 0,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos<mask>= 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
150,Base64.java,resizeBuffer,void resizeBuffer(),382,386,15223,15229,IdentifierMutator-Variable,readPos,offset,0,0.19163232,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;<mask> = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
151,Base64.java,resizeBuffer,void resizeBuffer(),382,386,15223,15229,IdentifierMutator-Variable,readPos,limit,1,0.09158048,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;<mask> = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
152,Base64.java,resizeBuffer,void resizeBuffer(),382,386,15223,15229,IdentifierMutator-Variable,readPos,size,2,0.0835456,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;<mask> = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
153,Base64.java,resizeBuffer,void resizeBuffer(),382,386,15223,15229,IdentifierMutator-Variable,readPos,count,3,0.062918335,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;<mask> = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
154,Base64.java,resizeBuffer,void resizeBuffer(),382,386,15223,15229,IdentifierMutator-Variable,readPos,length,4,0.061428133,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;<mask> = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
155,Base64.java,resizeBuffer,void resizeBuffer(),382,386,15223,15229,FieldReferenceMutator,readPos,offset,0,0.19163232,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;<mask> = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
156,Base64.java,resizeBuffer,void resizeBuffer(),382,386,15223,15229,FieldReferenceMutator,readPos,limit,1,0.09158048,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;<mask> = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
157,Base64.java,resizeBuffer,void resizeBuffer(),382,386,15223,15229,FieldReferenceMutator,readPos,size,2,0.0835456,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;<mask> = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
158,Base64.java,resizeBuffer,void resizeBuffer(),382,386,15223,15229,FieldReferenceMutator,readPos,count,3,0.062918335,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;<mask> = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
159,Base64.java,resizeBuffer,void resizeBuffer(),382,386,15223,15229,FieldReferenceMutator,readPos,length,4,0.061428133,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;<mask> = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
160,Base64.java,resizeBuffer,void resizeBuffer(),382,386,15233,15233,IdentifierMutator-Literal,0,pos,1,0.32420737,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos =<mask>;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
161,Base64.java,resizeBuffer,void resizeBuffer(),382,386,15233,15233,IdentifierMutator-Literal,0,position,2,0.015387487,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos =<mask>;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
162,Base64.java,resizeBuffer,void resizeBuffer(),382,386,15233,15233,IdentifierMutator-Literal,0,1,3,0.007912336,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos =<mask>;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
163,Base64.java,resizeBuffer,void resizeBuffer(),382,386,15233,15233,IdentifierMutator-Literal,0,offset,4,0.0037060792,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos =<mask>;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
164,Base64.java,resizeBuffer,void resizeBuffer(),382,388,15298,15300,BinaryOperatorMutator,*,/,2,0.05686551,buffer.length <mask> org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_RESIZE_FACTOR,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length<mask>DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
165,Base64.java,resizeBuffer,void resizeBuffer(),382,388,15298,15300,BinaryOperatorMutator,*,/,3,0.010096999,buffer.length <mask> org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_RESIZE_FACTOR,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length<mask>DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
166,Base64.java,resizeBuffer,void resizeBuffer(),382,388,15298,15300,BinaryOperatorMutator,*,//,4,0.0057115383,buffer.length <mask> org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_RESIZE_FACTOR,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length<mask>DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
167,Base64.java,resizeBuffer,void resizeBuffer(),382,388,15285,15297,IdentifierMutator-Variable,buffer.length,size,0,0.15002394,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[<mask> * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
168,Base64.java,resizeBuffer,void resizeBuffer(),382,388,15285,15297,IdentifierMutator-Variable,buffer.length,1024,1,0.09849174,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[<mask> * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
169,Base64.java,resizeBuffer,void resizeBuffer(),382,388,15285,15297,IdentifierMutator-Variable,buffer.length,2,2,0.05713501,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[<mask> * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
170,Base64.java,resizeBuffer,void resizeBuffer(),382,388,15285,15297,IdentifierMutator-Variable,buffer.length,SIZE,3,0.042523887,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[<mask> * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
171,Base64.java,resizeBuffer,void resizeBuffer(),382,388,15285,15297,IdentifierMutator-Variable,buffer.length,8,4,0.036943916,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[<mask> * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
172,Base64.java,resizeBuffer,void resizeBuffer(),382,388,15285,15290,IdentifierMutator-Variable,buffer,Buffer,1,0.0046080067,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[<mask>.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
173,Base64.java,resizeBuffer,void resizeBuffer(),382,388,15285,15290,IdentifierMutator-Variable,buffer,buf,3,3.1533375E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[<mask>.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
174,Base64.java,resizeBuffer,void resizeBuffer(),382,388,15285,15290,IdentifierMutator-Variable,buffer,queue,4,1.9087548E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[<mask>.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
175,Base64.java,resizeBuffer,void resizeBuffer(),382,388,15285,15290,FieldReferenceMutator,buffer,Buffer,1,0.0046080067,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[<mask>.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
176,Base64.java,resizeBuffer,void resizeBuffer(),382,388,15285,15290,FieldReferenceMutator,buffer,buf,3,3.1533375E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[<mask>.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
177,Base64.java,resizeBuffer,void resizeBuffer(),382,388,15285,15290,FieldReferenceMutator,buffer,queue,4,1.9087548E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[<mask>.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
178,Base64.java,resizeBuffer,void resizeBuffer(),382,388,15292,15297,FieldReferenceMutator,length,size,1,5.9637625E-4,buffer.<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.<mask> * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
179,Base64.java,resizeBuffer,void resizeBuffer(),382,388,15292,15297,FieldReferenceMutator,length,capacity,2,5.5692275E-4,buffer.<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.<mask> * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
180,Base64.java,resizeBuffer,void resizeBuffer(),382,388,15292,15297,FieldReferenceMutator,length,position,3,8.739172E-5,buffer.<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.<mask> * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
181,Base64.java,resizeBuffer,void resizeBuffer(),382,388,15301,15328,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_RESIZE_FACTOR,2,0,0.6583112,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length *<mask>];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
182,Base64.java,resizeBuffer,void resizeBuffer(),382,388,15301,15328,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_RESIZE_FACTOR,4,1,0.15488945,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length *<mask>];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
183,Base64.java,resizeBuffer,void resizeBuffer(),382,388,15301,15328,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_RESIZE_FACTOR,3,2,0.051842883,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length *<mask>];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
184,Base64.java,resizeBuffer,void resizeBuffer(),382,388,15301,15328,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_RESIZE_FACTOR,8,3,0.037875786,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length *<mask>];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
185,Base64.java,resizeBuffer,void resizeBuffer(),382,388,15301,15328,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DEFAULT_BUFFER_RESIZE_FACTOR,1024,4,0.0108403815,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length *<mask>];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
186,Base64.java,resizeBuffer,void resizeBuffer(),382,388,15301,15328,FieldReferenceMutator,DEFAULT_BUFFER_RESIZE_FACTOR,2,0,0.6583112,org.apache.commons.codec.binary.Base64.<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length *<mask>];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
187,Base64.java,resizeBuffer,void resizeBuffer(),382,388,15301,15328,FieldReferenceMutator,DEFAULT_BUFFER_RESIZE_FACTOR,4,1,0.15488945,org.apache.commons.codec.binary.Base64.<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length *<mask>];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
188,Base64.java,resizeBuffer,void resizeBuffer(),382,388,15301,15328,FieldReferenceMutator,DEFAULT_BUFFER_RESIZE_FACTOR,3,2,0.051842883,org.apache.commons.codec.binary.Base64.<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length *<mask>];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
189,Base64.java,resizeBuffer,void resizeBuffer(),382,388,15301,15328,FieldReferenceMutator,DEFAULT_BUFFER_RESIZE_FACTOR,8,3,0.037875786,org.apache.commons.codec.binary.Base64.<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length *<mask>];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
190,Base64.java,resizeBuffer,void resizeBuffer(),382,388,15301,15328,FieldReferenceMutator,DEFAULT_BUFFER_RESIZE_FACTOR,1024,4,0.0108403815,org.apache.commons.codec.binary.Base64.<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length *<mask>];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
191,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15351,15359,MethodCallMutator,arraycopy,copy,0,0.98117334,"System.<mask>(buffer, 0, b, 0, buffer.length)","void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.<mask>(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
192,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15351,15359,MethodCallMutator,arraycopy,array,1,0.0031739804,"System.<mask>(buffer, 0, b, 0, buffer.length)","void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.<mask>(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
193,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15351,15359,MethodCallMutator,arraycopy,write,2,0.0031280164,"System.<mask>(buffer, 0, b, 0, buffer.length)","void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.<mask>(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
194,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15351,15359,MethodCallMutator,arraycopy,bytes,3,0.0029730068,"System.<mask>(buffer, 0, b, 0, buffer.length)","void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.<mask>(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
195,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15351,15359,MethodCallMutator,arraycopy,read,4,0.0015968026,"System.<mask>(buffer, 0, b, 0, buffer.length)","void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.<mask>(buffer, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
196,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15361,15366,IdentifierMutator-Variable,buffer,Buffer,2,1.1309912E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(<mask>, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
197,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15361,15366,IdentifierMutator-Variable,buffer,buf,3,2.4314462E-5,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(<mask>, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
198,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15361,15366,IdentifierMutator-Variable,buffer,source,4,2.391295E-5,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(<mask>, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
199,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15361,15366,FieldReferenceMutator,buffer,Buffer,2,1.1309912E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(<mask>, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
200,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15361,15366,FieldReferenceMutator,buffer,buf,3,2.4314462E-5,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(<mask>, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
201,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15361,15366,FieldReferenceMutator,buffer,source,4,2.391295E-5,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(<mask>, 0, b, 0, buffer.length);
            buffer = b;
        }
    }"
202,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15369,15369,IdentifierMutator-Literal,0,pos,1,0.010127073,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer,<mask>, b, 0, buffer.length);
            buffer = b;
        }
    }"
203,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15369,15369,IdentifierMutator-Literal,0,1,2,0.007938074,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer,<mask>, b, 0, buffer.length);
            buffer = b;
        }
    }"
204,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15369,15369,IdentifierMutator-Literal,0,length,3,0.003676184,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer,<mask>, b, 0, buffer.length);
            buffer = b;
        }
    }"
205,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15369,15369,IdentifierMutator-Literal,0,len,4,0.0019418129,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer,<mask>, b, 0, buffer.length);
            buffer = b;
        }
    }"
206,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15372,15372,IdentifierMutator-Variable,b,buffer,1,7.7730726E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0,<mask>, 0, buffer.length);
            buffer = b;
        }
    }"
207,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15372,15372,IdentifierMutator-Variable,b,a,2,3.4320206E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0,<mask>, 0, buffer.length);
            buffer = b;
        }
    }"
208,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15372,15372,IdentifierMutator-Variable,b,buf,3,2.3874287E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0,<mask>, 0, buffer.length);
            buffer = b;
        }
    }"
209,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15375,15375,IdentifierMutator-Literal,0,pos,1,0.044146985,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b,<mask>, buffer.length);
            buffer = b;
        }
    }"
210,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15375,15375,IdentifierMutator-Literal,0,1,2,0.02007706,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b,<mask>, buffer.length);
            buffer = b;
        }
    }"
211,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15375,15375,IdentifierMutator-Literal,0,size,3,0.0020945072,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b,<mask>, buffer.length);
            buffer = b;
        }
    }"
212,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15375,15375,IdentifierMutator-Literal,0,4,4,0.0019141458,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b,<mask>, buffer.length);
            buffer = b;
        }
    }"
213,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15378,15390,IdentifierMutator-Variable,buffer.length,pos,0,0.93046486,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0,<mask>);
            buffer = b;
        }
    }"
214,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15378,15390,IdentifierMutator-Variable,buffer.length,len,1,0.022601316,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0,<mask>);
            buffer = b;
        }
    }"
215,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15378,15390,IdentifierMutator-Variable,buffer.length,size,2,0.007844301,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0,<mask>);
            buffer = b;
        }
    }"
216,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15378,15390,IdentifierMutator-Variable,buffer.length,n,3,0.005124929,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0,<mask>);
            buffer = b;
        }
    }"
217,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15378,15390,IdentifierMutator-Variable,buffer.length,offset,4,0.0050978553,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0,<mask>);
            buffer = b;
        }
    }"
218,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15378,15383,IdentifierMutator-Variable,buffer,b,1,0.0108165145,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0,<mask>.length);
            buffer = b;
        }
    }"
219,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15378,15383,IdentifierMutator-Variable,buffer,buf,3,7.636923E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0,<mask>.length);
            buffer = b;
        }
    }"
220,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15378,15383,IdentifierMutator-Variable,buffer,buffers,4,4.4694712E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0,<mask>.length);
            buffer = b;
        }
    }"
221,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15378,15383,FieldReferenceMutator,buffer,b,1,0.0108165145,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0,<mask>.length);
            buffer = b;
        }
    }"
222,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15378,15383,FieldReferenceMutator,buffer,buf,3,7.636923E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0,<mask>.length);
            buffer = b;
        }
    }"
223,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15378,15383,FieldReferenceMutator,buffer,buffers,4,4.4694712E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0,<mask>.length);
            buffer = b;
        }
    }"
224,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15385,15390,FieldReferenceMutator,length,position,1,1.21198726E-4,buffer.<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.<mask>);
            buffer = b;
        }
    }"
225,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15385,15390,FieldReferenceMutator,length,size,3,2.1060217E-5,buffer.<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.<mask>);
            buffer = b;
        }
    }"
226,Base64.java,resizeBuffer,void resizeBuffer(),382,389,15385,15390,FieldReferenceMutator,length,count,4,1.6033995E-5,buffer.<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.<mask>);
            buffer = b;
        }
    }"
227,Base64.java,resizeBuffer,void resizeBuffer(),382,390,15412,15412,AssignmentMutator,buffer=b,[],0,0.540444,buffer <mask>= b,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer<mask>= b;
        }
    }"
228,Base64.java,resizeBuffer,void resizeBuffer(),382,390,15412,15412,AssignmentMutator,buffer=b,|,1,0.22721569,buffer <mask>= b,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer<mask>= b;
        }
    }"
229,Base64.java,resizeBuffer,void resizeBuffer(),382,390,15412,15412,AssignmentMutator,buffer=b,.,2,0.06996397,buffer <mask>= b,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer<mask>= b;
        }
    }"
230,Base64.java,resizeBuffer,void resizeBuffer(),382,390,15412,15412,AssignmentMutator,buffer=b,.,3,0.04075797,buffer <mask>= b,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer<mask>= b;
        }
    }"
231,Base64.java,resizeBuffer,void resizeBuffer(),382,390,15412,15412,AssignmentMutator,buffer=b,^,4,0.026115466,buffer <mask>= b,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer<mask>= b;
        }
    }"
232,Base64.java,resizeBuffer,void resizeBuffer(),382,390,15406,15411,IdentifierMutator-Variable,buffer,buf,2,8.3654636E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);<mask> = b;
        }
    }"
233,Base64.java,resizeBuffer,void resizeBuffer(),382,390,15406,15411,IdentifierMutator-Variable,buffer,buffers,3,7.569468E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);<mask> = b;
        }
    }"
234,Base64.java,resizeBuffer,void resizeBuffer(),382,390,15406,15411,IdentifierMutator-Variable,buffer,Buffer,4,7.2781055E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);<mask> = b;
        }
    }"
235,Base64.java,resizeBuffer,void resizeBuffer(),382,390,15406,15411,FieldReferenceMutator,buffer,buf,2,8.3654636E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);<mask> = b;
        }
    }"
236,Base64.java,resizeBuffer,void resizeBuffer(),382,390,15406,15411,FieldReferenceMutator,buffer,buffers,3,7.569468E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);<mask> = b;
        }
    }"
237,Base64.java,resizeBuffer,void resizeBuffer(),382,390,15406,15411,FieldReferenceMutator,buffer,Buffer,4,7.2781055E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);<mask> = b;
        }
    }"
238,Base64.java,resizeBuffer,void resizeBuffer(),382,390,15415,15415,IdentifierMutator-Variable,b,null,1,0.04959017,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer =<mask>;
        }
    }"
239,Base64.java,resizeBuffer,void resizeBuffer(),382,390,15415,15415,IdentifierMutator-Variable,b,0,2,7.0119475E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer =<mask>;
        }
    }"
240,Base64.java,resizeBuffer,void resizeBuffer(),382,390,15415,15415,IdentifierMutator-Variable,b,a,4,4.905091E-4,<mask>,"void resizeBuffer() {
        if (buffer == null) {
            buffer = new byte[DEFAULT_BUFFER_SIZE];
            pos = 0;
            readPos = 0;
        } else {
            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
            System.arraycopy(buffer, 0, b, 0, buffer.length);
            buffer =<mask>;
        }
    }"
241,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,407,16094,16097,BinaryOperatorMutator,!=,==,0,0.5928318,buffer <mask> null,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer<mask>null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
242,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,407,16094,16097,BinaryOperatorMutator,!=,==,2,0.11785365,buffer <mask> null,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer<mask>null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
243,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,407,16094,16097,BinaryOperatorMutator,!=,=,3,0.057654608,buffer <mask> null,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer<mask>null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
244,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,407,16094,16097,BinaryOperatorMutator,!=,!,4,9.783455E-4,buffer <mask> null,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer<mask>null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
245,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,407,16088,16093,IdentifierMutator-Variable,buffer,b,1,0.043929122,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (<mask> != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
246,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,407,16088,16093,IdentifierMutator-Variable,buffer,buf,2,0.007960141,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (<mask> != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
247,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,407,16088,16093,IdentifierMutator-Variable,buffer,bb,3,0.006993577,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (<mask> != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
248,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,407,16088,16093,IdentifierMutator-Variable,buffer,Buffer,4,0.0043558734,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (<mask> != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
249,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,407,16088,16093,FieldReferenceMutator,buffer,b,1,0.043929122,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (<mask> != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
250,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,407,16088,16093,FieldReferenceMutator,buffer,buf,2,0.007960141,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (<mask> != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
251,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,407,16088,16093,FieldReferenceMutator,buffer,bb,3,0.006993577,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (<mask> != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
252,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,407,16088,16093,FieldReferenceMutator,buffer,Buffer,4,0.0043558734,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (<mask> != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
253,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,407,16098,16101,IdentifierMutator-Literal,null,b,1,0.08690027,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer !=<mask>) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
254,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,407,16098,16101,IdentifierMutator-Literal,null,nil,2,0.0023644997,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer !=<mask>) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
255,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,407,16098,16101,IdentifierMutator-Literal,null,a,3,0.0023485883,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer !=<mask>) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
256,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,407,16098,16101,IdentifierMutator-Literal,null,0,4,0.0017861786,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer !=<mask>) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
257,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,408,16133,16135,MethodCallMutator,min,max,0,0.5111452,"Math.<mask>(avail(), bAvail)","int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.<mask>(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
258,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,408,16133,16135,MethodCallMutator,min,div,2,0.0057413774,"Math.<mask>(avail(), bAvail)","int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.<mask>(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
259,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,408,16133,16135,MethodCallMutator,min,diff,3,0.0048660305,"Math.<mask>(avail(), bAvail)","int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.<mask>(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
260,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,408,16137,16141,MethodCallMutator,avail,len,0,0.51891404,<mask>(),"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(<mask>(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
261,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,408,16137,16141,MethodCallMutator,avail,length,1,0.1402075,<mask>(),"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(<mask>(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
262,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,408,16137,16141,MethodCallMutator,avail,size,2,0.07255191,<mask>(),"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(<mask>(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
263,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,408,16137,16141,MethodCallMutator,avail,limit,3,0.034165174,<mask>(),"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(<mask>(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
264,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,408,16137,16141,MethodCallMutator,avail,pos,4,0.016755255,<mask>(),"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(<mask>(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
265,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,408,16146,16151,IdentifierMutator-Variable,bAvail,len,0,0.3276092,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(),<mask>);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
266,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,408,16146,16151,IdentifierMutator-Variable,bAvail,pos,1,0.25411612,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(),<mask>);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
267,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,408,16146,16151,IdentifierMutator-Variable,bAvail,avail,2,0.2113732,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(),<mask>);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
268,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,408,16146,16151,IdentifierMutator-Variable,bAvail,buf,3,0.015767002,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(),<mask>);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
269,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,408,16146,16151,IdentifierMutator-Variable,bAvail,length,4,0.01393332,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(),<mask>);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
270,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,409,16177,16180,BinaryOperatorMutator,!=,==,1,0.08186549,buffer <mask> b,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer<mask>b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
271,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,409,16177,16180,BinaryOperatorMutator,!=,=,2,0.054267198,buffer <mask> b,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer<mask>b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
272,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,409,16177,16180,BinaryOperatorMutator,!=,==,3,0.010027055,buffer <mask> b,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer<mask>b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
273,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,409,16177,16180,BinaryOperatorMutator,!=,<,4,0.0047950204,buffer <mask> b,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer<mask>b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
274,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,409,16171,16176,IdentifierMutator-Variable,buffer,null,1,0.07905773,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (<mask> != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
275,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,409,16171,16176,IdentifierMutator-Variable,buffer,Buffer,2,0.013602355,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (<mask> != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
276,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,409,16171,16176,IdentifierMutator-Variable,buffer,buf,3,0.013125694,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (<mask> != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
277,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,409,16171,16176,IdentifierMutator-Variable,buffer,this,4,0.005331501,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (<mask> != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
278,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,409,16171,16176,FieldReferenceMutator,buffer,null,1,0.07905773,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (<mask> != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
279,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,409,16171,16176,FieldReferenceMutator,buffer,Buffer,2,0.013602355,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (<mask> != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
280,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,409,16171,16176,FieldReferenceMutator,buffer,buf,3,0.013125694,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (<mask> != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
281,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,409,16171,16176,FieldReferenceMutator,buffer,this,4,0.005331501,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (<mask> != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
282,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,409,16181,16181,IdentifierMutator-Variable,b,null,0,0.99904305,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer !=<mask>) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
283,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,409,16181,16181,IdentifierMutator-Variable,b,null,1,2.1213107E-4,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer !=<mask>) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
284,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,409,16181,16181,IdentifierMutator-Variable,b,0,2,1.1686201E-4,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer !=<mask>) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
285,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,409,16181,16181,IdentifierMutator-Variable,b,nil,3,9.286482E-5,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer !=<mask>) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
286,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,409,16181,16181,IdentifierMutator-Variable,b,buffer,4,7.330082E-5,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer !=<mask>) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
287,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,410,16209,16217,MethodCallMutator,arraycopy,copy,0,0.99813396,"System.<mask>(buffer, readPos, b, bPos, len)","int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.<mask>(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
288,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,410,16209,16217,MethodCallMutator,arraycopy,fill,1,3.4737174E-4,"System.<mask>(buffer, readPos, b, bPos, len)","int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.<mask>(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
289,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,410,16209,16217,MethodCallMutator,arraycopy,write,2,2.6493066E-4,"System.<mask>(buffer, readPos, b, bPos, len)","int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.<mask>(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
290,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,410,16209,16217,MethodCallMutator,arraycopy,read,3,2.4135142E-4,"System.<mask>(buffer, readPos, b, bPos, len)","int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.<mask>(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
291,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,410,16209,16217,MethodCallMutator,arraycopy,array,4,2.3703066E-4,"System.<mask>(buffer, readPos, b, bPos, len)","int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.<mask>(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
292,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,410,16219,16224,IdentifierMutator-Variable,buffer,b,1,0.08261473,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(<mask>, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
293,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,410,16219,16224,IdentifierMutator-Variable,buffer,a,2,0.01892693,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(<mask>, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
294,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,410,16219,16224,IdentifierMutator-Variable,buffer,buf,3,0.016065864,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(<mask>, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
295,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,410,16219,16224,IdentifierMutator-Variable,buffer,buff,4,0.008418677,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(<mask>, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
296,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,410,16219,16224,FieldReferenceMutator,buffer,b,1,0.08261473,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(<mask>, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
297,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,410,16219,16224,FieldReferenceMutator,buffer,a,2,0.01892693,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(<mask>, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
298,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,410,16219,16224,FieldReferenceMutator,buffer,buf,3,0.016065864,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(<mask>, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
299,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,410,16219,16224,FieldReferenceMutator,buffer,buff,4,0.008418677,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(<mask>, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
300,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,410,16227,16233,IdentifierMutator-Variable,readPos,0,0,0.97651064,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer,<mask>, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
301,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,410,16227,16233,IdentifierMutator-Variable,readPos,pos,1,0.011396354,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer,<mask>, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
302,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,410,16227,16233,IdentifierMutator-Variable,readPos,off,2,0.0029571946,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer,<mask>, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
303,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,410,16227,16233,IdentifierMutator-Variable,readPos,0,3,0.0022172837,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer,<mask>, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
304,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,410,16227,16233,IdentifierMutator-Variable,readPos,len,4,0.0013470198,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer,<mask>, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
305,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,410,16227,16233,FieldReferenceMutator,readPos,0,0,0.97651064,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer,<mask>, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
306,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,410,16227,16233,FieldReferenceMutator,readPos,pos,1,0.011396354,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer,<mask>, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
307,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,410,16227,16233,FieldReferenceMutator,readPos,off,2,0.0029571946,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer,<mask>, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
308,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,410,16227,16233,FieldReferenceMutator,readPos,0,3,0.0022172837,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer,<mask>, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
309,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,410,16227,16233,FieldReferenceMutator,readPos,len,4,0.0013470198,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer,<mask>, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
310,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,410,16236,16236,IdentifierMutator-Variable,b,buffer,1,0.0075172163,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos,<mask>, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
311,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,410,16236,16236,IdentifierMutator-Variable,b,a,2,0.004429151,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos,<mask>, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
312,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,410,16236,16236,IdentifierMutator-Variable,b,buf,3,0.0026695626,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos,<mask>, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
313,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,410,16236,16236,IdentifierMutator-Variable,b,output,4,0.0011687083,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos,<mask>, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
314,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,410,16239,16242,IdentifierMutator-Variable,bPos,pos,0,0.64307934,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b,<mask>, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
315,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,410,16239,16242,IdentifierMutator-Variable,bPos,0,1,0.28497908,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b,<mask>, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
316,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,410,16239,16242,IdentifierMutator-Variable,bPos,off,2,0.046385903,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b,<mask>, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
317,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,410,16239,16242,IdentifierMutator-Variable,bPos,offset,3,0.012231663,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b,<mask>, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
318,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,410,16239,16242,IdentifierMutator-Variable,bPos,Pos,4,0.001881053,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b,<mask>, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
319,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,410,16245,16247,IdentifierMutator-Variable,len,pos,1,0.0013072627,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos,<mask>);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
320,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,410,16245,16247,IdentifierMutator-Variable,len,length,3,7.535234E-5,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos,<mask>);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
321,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,410,16245,16247,IdentifierMutator-Variable,len,n,4,5.472175E-5,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos,<mask>);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
322,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,411,16274,16274,AssignmentMutator,readPos+=len,++,0,0.27567104,readPos <mask>= len,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos<mask>+= len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
323,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,411,16274,16274,AssignmentMutator,readPos+=len,*,1,0.1753126,readPos <mask>= len,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos<mask>+= len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
324,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,411,16274,16274,AssignmentMutator,readPos+=len,*,2,0.110553496,readPos <mask>= len,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos<mask>+= len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
325,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,411,16274,16274,AssignmentMutator,readPos+=len,//,3,0.059827756,readPos <mask>= len,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos<mask>+= len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
326,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,411,16274,16274,AssignmentMutator,readPos+=len,|,4,0.027135741,readPos <mask>= len,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos<mask>+= len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
327,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,411,16267,16273,IdentifierMutator-Variable,readPos,pos,0,0.9652716,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);<mask> += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
328,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,411,16267,16273,IdentifierMutator-Variable,readPos,pos,1,0.011851549,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);<mask> += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
329,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,411,16267,16273,IdentifierMutator-Variable,readPos,offset,2,0.0040938174,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);<mask> += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
330,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,411,16267,16273,IdentifierMutator-Variable,readPos,position,3,0.0031750116,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);<mask> += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
331,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,411,16267,16273,IdentifierMutator-Variable,readPos,len,4,0.0014009856,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);<mask> += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
332,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,411,16267,16273,FieldReferenceMutator,readPos,pos,0,0.9652716,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);<mask> += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
333,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,411,16267,16273,FieldReferenceMutator,readPos,pos,1,0.011851549,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);<mask> += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
334,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,411,16267,16273,FieldReferenceMutator,readPos,offset,2,0.0040938174,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);<mask> += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
335,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,411,16267,16273,FieldReferenceMutator,readPos,position,3,0.0031750116,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);<mask> += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
336,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,411,16267,16273,FieldReferenceMutator,readPos,len,4,0.0014009856,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);<mask> += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
337,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,411,16278,16280,IdentifierMutator-Variable,len,1,1,4.9659784E-4,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos +=<mask>;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
338,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,411,16278,16280,IdentifierMutator-Variable,len,pos,2,4.1558515E-4,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos +=<mask>;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
339,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,411,16278,16280,IdentifierMutator-Variable,len,2,3,2.9972725E-4,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos +=<mask>;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
340,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,411,16278,16280,IdentifierMutator-Variable,len,length,4,1.7989149E-4,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos +=<mask>;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
341,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,412,16310,16313,BinaryOperatorMutator,>=,==,0,0.4963244,readPos <mask> pos,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos<mask>pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
342,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,412,16310,16313,BinaryOperatorMutator,>=,<,1,0.18656628,readPos <mask> pos,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos<mask>pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
343,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,412,16310,16313,BinaryOperatorMutator,>=,!=,2,0.062623605,readPos <mask> pos,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos<mask>pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
344,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,412,16310,16313,BinaryOperatorMutator,>=,>,3,0.05326289,readPos <mask> pos,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos<mask>pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
345,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,412,16310,16313,BinaryOperatorMutator,>=,>,4,0.04871892,readPos <mask> pos,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos<mask>pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
346,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,412,16303,16309,IdentifierMutator-Variable,readPos,len,0,0.5431593,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (<mask> >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
347,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,412,16303,16309,IdentifierMutator-Variable,readPos,end,1,0.120956436,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (<mask> >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
348,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,412,16303,16309,IdentifierMutator-Variable,readPos,offset,2,0.03451969,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (<mask> >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
349,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,412,16303,16309,IdentifierMutator-Variable,readPos,pos,3,0.034197595,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (<mask> >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
350,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,412,16303,16309,IdentifierMutator-Variable,readPos,length,4,0.0200239,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (<mask> >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
351,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,412,16303,16309,FieldReferenceMutator,readPos,len,0,0.5431593,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (<mask> >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
352,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,412,16303,16309,FieldReferenceMutator,readPos,end,1,0.120956436,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (<mask> >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
353,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,412,16303,16309,FieldReferenceMutator,readPos,offset,2,0.03451969,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (<mask> >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
354,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,412,16303,16309,FieldReferenceMutator,readPos,pos,3,0.034197595,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (<mask> >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
355,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,412,16303,16309,FieldReferenceMutator,readPos,length,4,0.0200239,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (<mask> >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
356,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,412,16314,16316,IdentifierMutator-Variable,pos,len,0,0.5736299,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >=<mask>) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
357,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,412,16314,16316,IdentifierMutator-Variable,pos,limit,1,0.08756221,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >=<mask>) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
358,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,412,16314,16316,IdentifierMutator-Variable,pos,0,2,0.038317945,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >=<mask>) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
359,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,412,16314,16316,IdentifierMutator-Variable,pos,n,3,0.031352434,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >=<mask>) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
360,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,412,16314,16316,IdentifierMutator-Variable,pos,length,4,0.028452622,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >=<mask>) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
361,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,412,16314,16316,FieldReferenceMutator,pos,len,0,0.5736299,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >=<mask>) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
362,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,412,16314,16316,FieldReferenceMutator,pos,limit,1,0.08756221,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >=<mask>) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
363,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,412,16314,16316,FieldReferenceMutator,pos,0,2,0.038317945,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >=<mask>) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
364,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,412,16314,16316,FieldReferenceMutator,pos,n,3,0.031352434,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >=<mask>) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
365,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,412,16314,16316,FieldReferenceMutator,pos,length,4,0.028452622,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >=<mask>) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
366,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,413,16347,16347,AssignmentMutator,buffer=null,&,0,0.23664978,buffer <mask>= null,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer<mask>= null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
367,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,413,16347,16347,AssignmentMutator,buffer=null,*,1,0.22174147,buffer <mask>= null,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer<mask>= null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
368,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,413,16347,16347,AssignmentMutator,buffer=null,!,2,0.21433789,buffer <mask>= null,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer<mask>= null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
369,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,413,16347,16347,AssignmentMutator,buffer=null,|,3,0.12891358,buffer <mask>= null,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer<mask>= null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
370,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,413,16347,16347,AssignmentMutator,buffer=null,||,4,0.058560688,buffer <mask>= null,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer<mask>= null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
371,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,413,16341,16346,IdentifierMutator-Variable,buffer,reader,1,0.0017130193,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {<mask> = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
372,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,413,16341,16346,IdentifierMutator-Variable,buffer,b,2,0.0017106896,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {<mask> = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
373,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,413,16341,16346,IdentifierMutator-Variable,buffer,buf,4,0.0012960918,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {<mask> = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
374,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,413,16341,16346,FieldReferenceMutator,buffer,reader,1,0.0017130193,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {<mask> = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
375,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,413,16341,16346,FieldReferenceMutator,buffer,b,2,0.0017106896,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {<mask> = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
376,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,413,16341,16346,FieldReferenceMutator,buffer,buf,4,0.0012960918,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {<mask> = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
377,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,413,16350,16353,IdentifierMutator-Literal,null,b,1,0.026511936,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer =<mask>;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
378,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,413,16350,16353,IdentifierMutator-Literal,null,nil,2,0.0024392828,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer =<mask>;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
379,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,413,16350,16353,IdentifierMutator-Literal,null,"""""",3,6.70203E-4,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer =<mask>;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
380,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,413,16350,16353,IdentifierMutator-Literal,null,buffer,4,5.261728E-4,<mask>,"int readResults(byte[] b, int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer =<mask>;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
381,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,418,16532,16532,AssignmentMutator,buffer=null,!,0,0.34105435,buffer <mask>= null,"   if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer<mask>= null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
382,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,418,16532,16532,AssignmentMutator,buffer=null,*,1,0.25918993,buffer <mask>= null,"   if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer<mask>= null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
383,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,418,16532,16532,AssignmentMutator,buffer=null,&,2,0.120966114,buffer <mask>= null,"   if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer<mask>= null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
384,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,418,16532,16532,AssignmentMutator,buffer=null,||,3,0.05230672,buffer <mask>= null,"   if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer<mask>= null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
385,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,418,16532,16532,AssignmentMutator,buffer=null,|,4,0.042981137,buffer <mask>= null,"   if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer<mask>= null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
386,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,418,16526,16531,IdentifierMutator-Variable,buffer,b,1,0.28750157,<mask>,", int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.<mask> = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
387,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,418,16526,16531,IdentifierMutator-Variable,buffer,input,2,0.0076402347,<mask>,", int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.<mask> = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
388,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,418,16526,16531,IdentifierMutator-Variable,buffer,buf,3,0.0066065006,<mask>,", int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.<mask> = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
389,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,418,16526,16531,IdentifierMutator-Variable,buffer,output,4,0.0035677585,<mask>,", int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.<mask> = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
390,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,418,16526,16531,FieldReferenceMutator,buffer,b,1,0.28750157,<mask>,", int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.<mask> = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
391,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,418,16526,16531,FieldReferenceMutator,buffer,input,2,0.0076402347,<mask>,", int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.<mask> = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
392,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,418,16526,16531,FieldReferenceMutator,buffer,buf,3,0.0066065006,<mask>,", int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.<mask> = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
393,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,418,16526,16531,FieldReferenceMutator,buffer,output,4,0.0035677585,<mask>,", int bPos, int bAvail) {
        if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.<mask> = null;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
394,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,418,16535,16538,IdentifierMutator-Literal,null,b,1,0.2084152,<mask>,"  if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer =<mask>;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
395,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,418,16535,16538,IdentifierMutator-Literal,null,nil,2,0.0045961123,<mask>,"  if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer =<mask>;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
396,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,418,16535,16538,IdentifierMutator-Literal,null,undefined,3,0.0023095808,<mask>,"  if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer =<mask>;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
397,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,418,16535,16538,IdentifierMutator-Literal,null,a,4,9.838173E-4,<mask>,"  if (buffer != null) {
            int len = Math.min(avail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer =<mask>;
            }
            return len;
        }
        return eof ? -1 : 0;
    }"
398,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,420,16574,16576,IdentifierMutator-Variable,len,buffer,0,0.54770184,<mask>,"ail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return<mask>;
        }
        return eof ? -1 : 0;
    }"
399,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,420,16574,16576,IdentifierMutator-Variable,len,b,1,0.18174793,<mask>,"ail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return<mask>;
        }
        return eof ? -1 : 0;
    }"
400,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,420,16574,16576,IdentifierMutator-Variable,len,buf,2,0.04597363,<mask>,"ail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return<mask>;
        }
        return eof ? -1 : 0;
    }"
401,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,420,16574,16576,IdentifierMutator-Variable,len,0,3,0.04320586,<mask>,"ail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return<mask>;
        }
        return eof ? -1 : 0;
    }"
402,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,420,16574,16576,IdentifierMutator-Variable,len,null,4,0.016592212,<mask>,"ail(), bAvail);
            if (buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return<mask>;
        }
        return eof ? -1 : 0;
    }"
403,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,422,16604,16615,IdentifierMutator-Conditional,eof?-1:0,0,0,0.2375896,<mask>,"buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return<mask>;
    }"
404,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,422,16604,16615,IdentifierMutator-Conditional,eof?-1:0,b,1,0.20608939,<mask>,"buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return<mask>;
    }"
405,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,422,16604,16615,IdentifierMutator-Conditional,eof?-1:0,buffer,2,0.14947222,<mask>,"buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return<mask>;
    }"
406,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,422,16604,16615,IdentifierMutator-Conditional,eof?-1:0,null,3,0.07340877,<mask>,"buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return<mask>;
    }"
407,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,422,16604,16615,IdentifierMutator-Conditional,eof?-1:0,buf,4,0.040902775,<mask>,"buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return<mask>;
    }"
408,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,422,16604,16606,IdentifierMutator-Variable,eof,negative,0,0.62197536,<mask>,"buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return<mask> ? -1 : 0;
    }"
409,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,422,16604,16606,IdentifierMutator-Variable,eof,reversed,1,0.03409621,<mask>,"buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return<mask> ? -1 : 0;
    }"
410,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,422,16604,16606,IdentifierMutator-Variable,eof,reverse,2,0.030431136,<mask>,"buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return<mask> ? -1 : 0;
    }"
411,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,422,16604,16606,IdentifierMutator-Variable,eof,0,3,0.017484184,<mask>,"buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return<mask> ? -1 : 0;
    }"
412,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,422,16604,16606,IdentifierMutator-Variable,eof,neg,4,0.016923545,<mask>,"buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return<mask> ? -1 : 0;
    }"
413,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,422,16604,16606,FieldReferenceMutator,eof,negative,0,0.62197536,<mask>,"buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return<mask> ? -1 : 0;
    }"
414,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,422,16604,16606,FieldReferenceMutator,eof,reversed,1,0.03409621,<mask>,"buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return<mask> ? -1 : 0;
    }"
415,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,422,16604,16606,FieldReferenceMutator,eof,reverse,2,0.030431136,<mask>,"buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return<mask> ? -1 : 0;
    }"
416,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,422,16604,16606,FieldReferenceMutator,eof,0,3,0.017484184,<mask>,"buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return<mask> ? -1 : 0;
    }"
417,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,422,16604,16606,FieldReferenceMutator,eof,neg,4,0.016923545,<mask>,"buffer != b) {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return<mask> ? -1 : 0;
    }"
418,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,422,16610,16610,UnaryOperatorMutator,-,$,1,0.002904153,<mask>1,") {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ?<mask>1 : 0;
    }"
419,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,422,16610,16610,UnaryOperatorMutator,-,+,2,0.001843675,<mask>1,") {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ?<mask>1 : 0;
    }"
420,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,422,16610,16610,UnaryOperatorMutator,-,!,4,5.1324064E-4,<mask>1,") {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ?<mask>1 : 0;
    }"
421,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,422,16611,16611,IdentifierMutator-Literal,1,2,1,0.0015188624,<mask>," {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -<mask> : 0;
    }"
422,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,422,16611,16611,IdentifierMutator-Literal,1,3,3,9.6279364E-5,<mask>," {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -<mask> : 0;
    }"
423,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,422,16611,16611,IdentifierMutator-Literal,1,Infinity,4,8.285509E-5,<mask>," {
                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -<mask> : 0;
    }"
424,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,422,16615,16615,IdentifierMutator-Literal,0,1,1,0.08179466,<mask>,"                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 :<mask>;
    }"
425,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,422,16615,16615,IdentifierMutator-Literal,0,len,2,0.042342626,<mask>,"                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 :<mask>;
    }"
426,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,422,16615,16615,IdentifierMutator-Literal,0,null,3,0.017626926,<mask>,"                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 :<mask>;
    }"
427,Base64.java,readResults,"int readResults(byte[] b, int bPos, int bAvail)",406,422,16615,16615,IdentifierMutator-Literal,0,pos,4,0.011236394,<mask>,"                System.arraycopy(buffer, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos) {
                    buffer = null;
                }
            } else {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buffer = null;
            }
            return len;
        }
        return eof ? -1 :<mask>;
    }"
428,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,439,17330,17333,BinaryOperatorMutator,&&,&,2,0.024439977,(out != null) <mask> (out.length == outAvail),"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null<mask>out.length == outAvail) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
429,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,439,17330,17333,BinaryOperatorMutator,&&,||,3,0.008184119,(out != null) <mask> (out.length == outAvail),"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null<mask>out.length == outAvail) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
430,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,439,17330,17333,BinaryOperatorMutator,&&,.,4,0.005439521,(out != null) <mask> (out.length == outAvail),"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null<mask>out.length == outAvail) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
431,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,439,17322,17325,BinaryOperatorMutator,!=,==,1,0.020267881,out <mask> null,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out<mask>null && out.length == outAvail) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
432,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,439,17322,17325,BinaryOperatorMutator,!=,=,2,0.007667449,out <mask> null,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out<mask>null && out.length == outAvail) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
433,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,439,17322,17325,BinaryOperatorMutator,!=,!,3,0.0011559238,out <mask> null,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out<mask>null && out.length == outAvail) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
434,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,439,17322,17325,BinaryOperatorMutator,!=,.,4,5.9748755E-4,out <mask> null,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out<mask>null && out.length == outAvail) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
435,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,439,17319,17321,IdentifierMutator-Variable,out,buffer,1,0.09019017,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (<mask> != null && out.length == outAvail) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
436,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,439,17319,17321,IdentifierMutator-Variable,out,in,2,0.013020912,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (<mask> != null && out.length == outAvail) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
437,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,439,17319,17321,IdentifierMutator-Variable,out,raw,3,0.0044664345,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (<mask> != null && out.length == outAvail) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
438,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,439,17326,17329,IdentifierMutator-Literal,null,buffer,2,4.6255975E-4,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out !=<mask> && out.length == outAvail) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
439,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,439,17326,17329,IdentifierMutator-Literal,null,nil,3,4.514922E-4,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out !=<mask> && out.length == outAvail) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
440,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,439,17326,17329,IdentifierMutator-Literal,null,NULL,4,1.6594128E-4,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out !=<mask> && out.length == outAvail) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
441,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,439,17344,17347,BinaryOperatorMutator,==,<,1,0.1641892,out.length <mask> outAvail,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length<mask>outAvail) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
442,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,439,17344,17347,BinaryOperatorMutator,==,>,2,0.14383334,out.length <mask> outAvail,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length<mask>outAvail) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
443,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,439,17344,17347,BinaryOperatorMutator,==,<,3,0.09177125,out.length <mask> outAvail,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length<mask>outAvail) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
444,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,439,17344,17347,BinaryOperatorMutator,==,>=,4,0.08300209,out.length <mask> outAvail,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length<mask>outAvail) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
445,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,439,17334,17343,IdentifierMutator-Variable,out.length,avail,0,0.18955195,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null &&<mask> == outAvail) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
446,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,439,17334,17343,IdentifierMutator-Variable,out.length,pos,1,0.17935348,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null &&<mask> == outAvail) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
447,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,439,17334,17343,IdentifierMutator-Variable,out.length,0,2,0.14641057,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null &&<mask> == outAvail) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
448,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,439,17334,17343,IdentifierMutator-Variable,out.length,offset,3,0.03900305,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null &&<mask> == outAvail) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
449,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,439,17334,17343,IdentifierMutator-Variable,out.length,size,4,0.038735345,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null &&<mask> == outAvail) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
450,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,439,17334,17336,IdentifierMutator-Variable,out,buffer,1,0.067934506,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null &&<mask>.length == outAvail) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
451,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,439,17334,17336,IdentifierMutator-Variable,out,in,2,0.0053871595,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null &&<mask>.length == outAvail) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
452,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,439,17334,17336,IdentifierMutator-Variable,out,output,3,0.0024574546,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null &&<mask>.length == outAvail) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
453,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,439,17338,17343,FieldReferenceMutator,length,size,2,5.559805E-4,out.<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.<mask> == outAvail) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
454,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,439,17338,17343,FieldReferenceMutator,length,len,3,3.4576768E-4,out.<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.<mask> == outAvail) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
455,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,439,17338,17343,FieldReferenceMutator,length,read,4,2.1612718E-4,out.<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.<mask> == outAvail) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
456,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,439,17348,17355,IdentifierMutator-Variable,outAvail,0,0,0.57634324,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length ==<mask>) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
457,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,439,17348,17355,IdentifierMutator-Variable,outAvail,capacity,1,0.13315304,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length ==<mask>) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
458,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,439,17348,17355,IdentifierMutator-Variable,outAvail,limit,2,0.032771766,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length ==<mask>) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
459,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,439,17348,17355,IdentifierMutator-Variable,outAvail,size,3,0.032395586,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length ==<mask>) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
460,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,439,17348,17355,IdentifierMutator-Variable,outAvail,1,4,0.016693259,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length ==<mask>) {
            buffer = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
461,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,440,17378,17378,AssignmentMutator,buffer=out,[],0,0.90489644,buffer <mask>= out,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer<mask>= out;
            pos = outPos;
            readPos = outPos;
        }
    }"
462,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,440,17378,17378,AssignmentMutator,buffer=out,Array,1,0.025338857,buffer <mask>= out,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer<mask>= out;
            pos = outPos;
            readPos = outPos;
        }
    }"
463,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,440,17378,17378,AssignmentMutator,buffer=out,|,2,0.010240666,buffer <mask>= out,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer<mask>= out;
            pos = outPos;
            readPos = outPos;
        }
    }"
464,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,440,17378,17378,AssignmentMutator,buffer=out,Bytes,3,0.007355219,buffer <mask>= out,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer<mask>= out;
            pos = outPos;
            readPos = outPos;
        }
    }"
465,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,440,17378,17378,AssignmentMutator,buffer=out,*,4,0.0028085366,buffer <mask>= out,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer<mask>= out;
            pos = outPos;
            readPos = outPos;
        }
    }"
466,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,440,17372,17377,IdentifierMutator-Variable,buffer,buf,1,0.16216211,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {<mask> = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
467,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,440,17372,17377,IdentifierMutator-Variable,buffer,out,2,0.15520911,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {<mask> = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
468,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,440,17372,17377,IdentifierMutator-Variable,buffer,in,3,0.018152885,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {<mask> = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
469,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,440,17372,17377,IdentifierMutator-Variable,buffer,bytes,4,0.008103398,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {<mask> = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
470,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,440,17372,17377,FieldReferenceMutator,buffer,buf,1,0.16216211,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {<mask> = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
471,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,440,17372,17377,FieldReferenceMutator,buffer,out,2,0.15520911,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {<mask> = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
472,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,440,17372,17377,FieldReferenceMutator,buffer,in,3,0.018152885,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {<mask> = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
473,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,440,17372,17377,FieldReferenceMutator,buffer,bytes,4,0.008103398,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {<mask> = out;
            pos = outPos;
            readPos = outPos;
        }
    }"
474,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,440,17381,17383,IdentifierMutator-Variable,out,null,1,0.02526874,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer =<mask>;
            pos = outPos;
            readPos = outPos;
        }
    }"
475,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,440,17381,17383,IdentifierMutator-Variable,out,0,2,0.0070171696,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer =<mask>;
            pos = outPos;
            readPos = outPos;
        }
    }"
476,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,440,17381,17383,IdentifierMutator-Variable,out,"""""",3,0.0062760864,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer =<mask>;
            pos = outPos;
            readPos = outPos;
        }
    }"
477,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,440,17381,17383,IdentifierMutator-Variable,out,in,4,0.0034074527,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer =<mask>;
            pos = outPos;
            readPos = outPos;
        }
    }"
478,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,441,17401,17401,AssignmentMutator,pos=outPos,|,0,0.6727651,pos <mask>= outPos,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;
            pos<mask>= outPos;
            readPos = outPos;
        }
    }"
479,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,441,17401,17401,AssignmentMutator,pos=outPos,*,1,0.1740724,pos <mask>= outPos,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;
            pos<mask>= outPos;
            readPos = outPos;
        }
    }"
480,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,441,17401,17401,AssignmentMutator,pos=outPos,^,2,0.031229826,pos <mask>= outPos,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;
            pos<mask>= outPos;
            readPos = outPos;
        }
    }"
481,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,441,17401,17401,AssignmentMutator,pos=outPos,&,3,0.024800051,pos <mask>= outPos,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;
            pos<mask>= outPos;
            readPos = outPos;
        }
    }"
482,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,441,17401,17401,AssignmentMutator,pos=outPos,/,4,0.011816745,pos <mask>= outPos,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;
            pos<mask>= outPos;
            readPos = outPos;
        }
    }"
483,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,441,17398,17400,IdentifierMutator-Variable,pos,offset,0,0.38235542,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;<mask> = outPos;
            readPos = outPos;
        }
    }"
484,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,441,17398,17400,IdentifierMutator-Variable,pos,position,1,0.229,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;<mask> = outPos;
            readPos = outPos;
        }
    }"
485,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,441,17398,17400,IdentifierMutator-Variable,pos,index,3,0.029905181,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;<mask> = outPos;
            readPos = outPos;
        }
    }"
486,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,441,17398,17400,IdentifierMutator-Variable,pos,off,4,0.024775626,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;<mask> = outPos;
            readPos = outPos;
        }
    }"
487,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,441,17398,17400,FieldReferenceMutator,pos,offset,0,0.38235542,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;<mask> = outPos;
            readPos = outPos;
        }
    }"
488,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,441,17398,17400,FieldReferenceMutator,pos,position,1,0.229,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;<mask> = outPos;
            readPos = outPos;
        }
    }"
489,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,441,17398,17400,FieldReferenceMutator,pos,index,3,0.029905181,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;<mask> = outPos;
            readPos = outPos;
        }
    }"
490,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,441,17398,17400,FieldReferenceMutator,pos,off,4,0.024775626,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;<mask> = outPos;
            readPos = outPos;
        }
    }"
491,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,441,17404,17409,IdentifierMutator-Variable,outPos,pos,0,0.49127096,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;
            pos =<mask>;
            readPos = outPos;
        }
    }"
492,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,441,17404,17409,IdentifierMutator-Variable,outPos,0,1,0.43252343,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;
            pos =<mask>;
            readPos = outPos;
        }
    }"
493,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,441,17404,17409,IdentifierMutator-Variable,outPos,position,2,0.026665945,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;
            pos =<mask>;
            readPos = outPos;
        }
    }"
494,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,441,17404,17409,IdentifierMutator-Variable,outPos,offset,3,0.011094583,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;
            pos =<mask>;
            readPos = outPos;
        }
    }"
495,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,441,17404,17409,IdentifierMutator-Variable,outPos,start,4,0.005085646,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;
            pos =<mask>;
            readPos = outPos;
        }
    }"
496,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,442,17431,17431,AssignmentMutator,readPos=outPos,|,0,0.7022642,readPos <mask>= outPos,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;
            pos = outPos;
            readPos<mask>= outPos;
        }
    }"
497,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,442,17431,17431,AssignmentMutator,readPos=outPos,*,1,0.204247,readPos <mask>= outPos,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;
            pos = outPos;
            readPos<mask>= outPos;
        }
    }"
498,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,442,17431,17431,AssignmentMutator,readPos=outPos,^,2,0.021865107,readPos <mask>= outPos,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;
            pos = outPos;
            readPos<mask>= outPos;
        }
    }"
499,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,442,17431,17431,AssignmentMutator,readPos=outPos,&,3,0.017436674,readPos <mask>= outPos,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;
            pos = outPos;
            readPos<mask>= outPos;
        }
    }"
500,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,442,17431,17431,AssignmentMutator,readPos=outPos,/,4,0.015005814,readPos <mask>= outPos,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;
            pos = outPos;
            readPos<mask>= outPos;
        }
    }"
501,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,442,17424,17430,IdentifierMutator-Variable,readPos,offset,0,0.32260492,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;
            pos = outPos;<mask> = outPos;
        }
    }"
502,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,442,17424,17430,IdentifierMutator-Variable,readPos,avail,1,0.10832181,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;
            pos = outPos;<mask> = outPos;
        }
    }"
503,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,442,17424,17430,IdentifierMutator-Variable,readPos,off,2,0.07419637,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;
            pos = outPos;<mask> = outPos;
        }
    }"
504,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,442,17424,17430,IdentifierMutator-Variable,readPos,available,3,0.033441678,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;
            pos = outPos;<mask> = outPos;
        }
    }"
505,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,442,17424,17430,IdentifierMutator-Variable,readPos,remaining,4,0.031114496,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;
            pos = outPos;<mask> = outPos;
        }
    }"
506,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,442,17424,17430,FieldReferenceMutator,readPos,offset,0,0.32260492,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;
            pos = outPos;<mask> = outPos;
        }
    }"
507,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,442,17424,17430,FieldReferenceMutator,readPos,avail,1,0.10832181,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;
            pos = outPos;<mask> = outPos;
        }
    }"
508,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,442,17424,17430,FieldReferenceMutator,readPos,off,2,0.07419637,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;
            pos = outPos;<mask> = outPos;
        }
    }"
509,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,442,17424,17430,FieldReferenceMutator,readPos,available,3,0.033441678,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;
            pos = outPos;<mask> = outPos;
        }
    }"
510,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,442,17424,17430,FieldReferenceMutator,readPos,remaining,4,0.031114496,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;
            pos = outPos;<mask> = outPos;
        }
    }"
511,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,442,17434,17439,IdentifierMutator-Variable,outPos,pos,0,0.52477264,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;
            pos = outPos;
            readPos =<mask>;
        }
    }"
512,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,442,17434,17439,IdentifierMutator-Variable,outPos,0,1,0.3918165,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;
            pos = outPos;
            readPos =<mask>;
        }
    }"
513,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,442,17434,17439,IdentifierMutator-Variable,outPos,position,2,0.023034813,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;
            pos = outPos;
            readPos =<mask>;
        }
    }"
514,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,442,17434,17439,IdentifierMutator-Variable,outPos,offset,3,0.00632868,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;
            pos = outPos;
            readPos =<mask>;
        }
    }"
515,Base64.java,setInitialBuffer,"void setInitialBuffer(byte[] out, int outPos, int outAvail)",436,442,17434,17439,IdentifierMutator-Variable,outPos,off,4,0.0047229603,<mask>,"void setInitialBuffer(byte[] out, int outPos, int outAvail) {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail) {
            buffer = out;
            pos = outPos;
            readPos =<mask>;
        }
    }"
516,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,465,18308,18310,IdentifierMutator-Variable,eof,done,0,0.19429876,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (<mask>) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
517,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,465,18308,18310,IdentifierMutator-Variable,eof,finished,1,0.16145582,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (<mask>) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
518,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,465,18308,18310,IdentifierMutator-Variable,eof,end,2,0.074207194,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (<mask>) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
519,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,465,18308,18310,IdentifierMutator-Variable,eof,stop,3,0.066900685,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (<mask>) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
520,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,465,18308,18310,IdentifierMutator-Variable,eof,error,4,0.0407589,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (<mask>) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
521,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,465,18308,18310,FieldReferenceMutator,eof,done,0,0.19429876,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (<mask>) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
522,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,465,18308,18310,FieldReferenceMutator,eof,finished,1,0.16145582,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (<mask>) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
523,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,465,18308,18310,FieldReferenceMutator,eof,end,2,0.074207194,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (<mask>) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
524,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,465,18308,18310,FieldReferenceMutator,eof,stop,3,0.066900685,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (<mask>) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
525,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,465,18308,18310,FieldReferenceMutator,eof,error,4,0.0407589,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (<mask>) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
526,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,470,18466,18468,BinaryOperatorMutator,<,>,1,0.25205335,inAvail <mask> 0,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail<mask>0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
527,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,470,18466,18468,BinaryOperatorMutator,<,>,3,0.053521637,inAvail <mask> 0,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail<mask>0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
528,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,470,18466,18468,BinaryOperatorMutator,<,==,4,0.052368738,inAvail <mask> 0,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail<mask>0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
529,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,470,18459,18465,IdentifierMutator-Variable,inAvail,pos,0,0.7517562,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (<mask> < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
     "
530,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,470,18459,18465,IdentifierMutator-Variable,inAvail,offset,1,0.08945218,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (<mask> < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
     "
531,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,470,18459,18465,IdentifierMutator-Variable,inAvail,abs,2,0.0102591915,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (<mask> < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
     "
532,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,470,18459,18465,IdentifierMutator-Variable,inAvail,off,3,0.007988152,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (<mask> < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
     "
533,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,470,18459,18465,IdentifierMutator-Variable,inAvail,i,4,0.0068571665,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (<mask> < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
     "
534,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,470,18469,18469,IdentifierMutator-Literal,0,1,1,0.0028293866,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail <<mask>) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
535,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,470,18469,18469,IdentifierMutator-Literal,0,pos,3,1.4442338E-4,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail <<mask>) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
536,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,470,18469,18469,IdentifierMutator-Literal,0,size,4,1.2638369E-4,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail <<mask>) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
537,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,471,18489,18489,AssignmentMutator,eof=true,|,0,0.97770643,eof <mask>= true,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof<mask>= true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
  "
538,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,471,18489,18489,AssignmentMutator,eof=true,&,1,0.008145292,eof <mask>= true,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof<mask>= true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
  "
539,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,471,18489,18489,AssignmentMutator,eof=true,!,2,0.0038271723,eof <mask>= true,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof<mask>= true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
  "
540,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,471,18489,18489,AssignmentMutator,eof=true,|,3,0.0017310834,eof <mask>= true,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof<mask>= true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
  "
541,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,471,18489,18489,AssignmentMutator,eof=true,||,4,0.0016703724,eof <mask>= true,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof<mask>= true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
  "
542,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,471,18486,18488,IdentifierMutator-Variable,eof,done,0,0.5250192,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {<mask> = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                "
543,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,471,18486,18488,IdentifierMutator-Variable,eof,finished,1,0.12915988,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {<mask> = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                "
544,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,471,18486,18488,IdentifierMutator-Variable,eof,ended,2,0.03053205,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {<mask> = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                "
545,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,471,18486,18488,IdentifierMutator-Variable,eof,closed,3,0.029502647,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {<mask> = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                "
546,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,471,18486,18488,IdentifierMutator-Variable,eof,end,4,0.027778732,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {<mask> = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                "
547,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,471,18486,18488,FieldReferenceMutator,eof,done,0,0.5250192,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {<mask> = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                "
548,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,471,18486,18488,FieldReferenceMutator,eof,finished,1,0.12915988,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {<mask> = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                "
549,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,471,18486,18488,FieldReferenceMutator,eof,ended,2,0.03053205,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {<mask> = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                "
550,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,471,18486,18488,FieldReferenceMutator,eof,closed,3,0.029502647,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {<mask> = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                "
551,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,471,18486,18488,FieldReferenceMutator,eof,end,4,0.027778732,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {<mask> = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                "
552,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,471,18492,18495,IdentifierMutator-Literal,true,false,1,0.018989656,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof =<mask>;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
553,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,471,18492,18495,IdentifierMutator-Literal,true,TRUE,2,3.1368452E-4,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof =<mask>;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
554,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,471,18492,18495,IdentifierMutator-Literal,true,1,4,1.6627122E-4,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof =<mask>;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
555,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,472,18528,18531,BinaryOperatorMutator,||,|,2,0.0071264445,(buffer == null) <mask> ((buffer.length - pos) < encodeSize),"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null<mask>buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
556,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,472,18528,18531,BinaryOperatorMutator,||,.,3,0.0054187533,(buffer == null) <mask> ((buffer.length - pos) < encodeSize),"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null<mask>buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
557,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,472,18528,18531,BinaryOperatorMutator,||,?,4,0.0022501089,(buffer == null) <mask> ((buffer.length - pos) < encodeSize),"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null<mask>buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
558,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,472,18520,18523,BinaryOperatorMutator,==,=,2,0.0045053973,buffer <mask> null,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer<mask>null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
559,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,472,18520,18523,BinaryOperatorMutator,==,===,3,0.003271591,buffer <mask> null,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer<mask>null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
560,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,472,18520,18523,BinaryOperatorMutator,==,_,4,7.145099E-4,buffer <mask> null,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer<mask>null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
561,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,472,18514,18519,IdentifierMutator-Variable,buffer,buf,1,0.0022869138,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (<mask> == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
562,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,472,18514,18519,IdentifierMutator-Variable,buffer,queue,2,0.0013071565,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (<mask> == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
563,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,472,18514,18519,IdentifierMutator-Variable,buffer,Buffer,4,0.001093673,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (<mask> == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
564,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,472,18514,18519,FieldReferenceMutator,buffer,buf,1,0.0022869138,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (<mask> == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
565,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,472,18514,18519,FieldReferenceMutator,buffer,queue,2,0.0013071565,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (<mask> == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
566,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,472,18514,18519,FieldReferenceMutator,buffer,Buffer,4,0.001093673,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (<mask> == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
567,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,472,18524,18527,IdentifierMutator-Literal,null,NULL,1,7.0559524E-4,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer ==<mask> || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
568,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,472,18524,18527,IdentifierMutator-Literal,null,nil,2,6.426485E-4,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer ==<mask> || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
569,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,472,18524,18527,IdentifierMutator-Literal,null,undefined,4,1.4356709E-4,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer ==<mask> || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
570,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,472,18551,18553,BinaryOperatorMutator,<,>,1,0.18230161,(buffer.length - pos) <mask> encodeSize,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos<mask>encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
  "
571,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,472,18551,18553,BinaryOperatorMutator,<,>,3,0.090189576,(buffer.length - pos) <mask> encodeSize,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos<mask>encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
  "
572,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,472,18551,18553,BinaryOperatorMutator,<,==,4,0.067225225,(buffer.length - pos) <mask> encodeSize,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos<mask>encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
  "
573,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,472,18545,18547,BinaryOperatorMutator,-,*,1,0.15344656,buffer.length <mask> pos,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length<mask>pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
574,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,472,18545,18547,BinaryOperatorMutator,-,+,2,0.1075529,buffer.length <mask> pos,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length<mask>pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
575,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,472,18545,18547,BinaryOperatorMutator,-,/,3,0.05484094,buffer.length <mask> pos,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length<mask>pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
576,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,472,18545,18547,BinaryOperatorMutator,-,_,4,0.02774839,buffer.length <mask> pos,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length<mask>pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
577,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,472,18532,18544,IdentifierMutator-Variable,buffer.length,size,0,0.36834443,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null ||<mask> - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
     "
578,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,472,18532,18544,IdentifierMutator-Variable,buffer.length,limit,1,0.14885868,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null ||<mask> - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
     "
579,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,472,18532,18544,IdentifierMutator-Variable,buffer.length,length,2,0.06917371,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null ||<mask> - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
     "
580,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,472,18532,18544,IdentifierMutator-Variable,buffer.length,capacity,3,0.062514275,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null ||<mask> - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
     "
581,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,472,18532,18544,IdentifierMutator-Variable,buffer.length,end,4,0.041550223,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null ||<mask> - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
     "
582,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,472,18532,18537,IdentifierMutator-Variable,buffer,buf,1,0.0018659565,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null ||<mask>.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
583,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,472,18532,18537,IdentifierMutator-Variable,buffer,buffers,2,0.0014083367,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null ||<mask>.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
584,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,472,18532,18537,IdentifierMutator-Variable,buffer,input,4,4.2346347E-4,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null ||<mask>.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
585,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,472,18532,18537,FieldReferenceMutator,buffer,buf,1,0.0018659565,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null ||<mask>.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
586,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,472,18532,18537,FieldReferenceMutator,buffer,buffers,2,0.0014083367,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null ||<mask>.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
587,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,472,18532,18537,FieldReferenceMutator,buffer,input,4,4.2346347E-4,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null ||<mask>.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
588,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,472,18539,18544,FieldReferenceMutator,length,size,1,0.003997627,buffer.<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.<mask> - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
589,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,472,18539,18544,FieldReferenceMutator,length,position,2,0.0032238394,buffer.<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.<mask> - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
590,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,472,18539,18544,FieldReferenceMutator,length,len,3,0.0021605846,buffer.<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.<mask> - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
591,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,472,18539,18544,FieldReferenceMutator,length,capacity,4,0.0014499035,buffer.<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.<mask> - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
592,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,472,18548,18550,IdentifierMutator-Variable,pos,offset,1,0.06881157,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length -<mask> < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
593,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,472,18548,18550,IdentifierMutator-Variable,pos,size,2,0.025420422,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length -<mask> < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
594,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,472,18548,18550,IdentifierMutator-Variable,pos,1,3,0.022509627,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length -<mask> < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
595,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,472,18548,18550,IdentifierMutator-Variable,pos,len,4,0.020821935,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length -<mask> < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
596,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,472,18548,18550,FieldReferenceMutator,pos,offset,1,0.06881157,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length -<mask> < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
597,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,472,18548,18550,FieldReferenceMutator,pos,size,2,0.025420422,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length -<mask> < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
598,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,472,18548,18550,FieldReferenceMutator,pos,1,3,0.022509627,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length -<mask> < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
599,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,472,18548,18550,FieldReferenceMutator,pos,len,4,0.020821935,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length -<mask> < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
600,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,472,18554,18563,IdentifierMutator-Variable,encodeSize,0,0,0.20743708,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
601,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,472,18554,18563,IdentifierMutator-Variable,encodeSize,limit,1,0.19221807,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
602,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,472,18554,18563,IdentifierMutator-Variable,encodeSize,length,2,0.050543293,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
603,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,472,18554,18563,IdentifierMutator-Variable,encodeSize,size,3,0.047710393,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
604,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,472,18554,18563,IdentifierMutator-Variable,encodeSize,len,4,0.04746102,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
605,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,472,18554,18563,FieldReferenceMutator,encodeSize,0,0,0.20743708,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
606,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,472,18554,18563,FieldReferenceMutator,encodeSize,limit,1,0.19221807,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
607,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,472,18554,18563,FieldReferenceMutator,encodeSize,length,2,0.050543293,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
608,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,472,18554,18563,FieldReferenceMutator,encodeSize,size,3,0.047710393,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
609,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,472,18554,18563,FieldReferenceMutator,encodeSize,len,4,0.04746102,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
610,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,473,18584,18595,MethodCallMutator,resizeBuffer,flush,0,0.3780323,<mask>(),"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {<mask>();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer"
611,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,473,18584,18595,MethodCallMutator,resizeBuffer,close,1,0.29456574,<mask>(),"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {<mask>();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer"
612,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,473,18584,18595,MethodCallMutator,resizeBuffer,reset,2,0.03776145,<mask>(),"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {<mask>();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer"
613,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,473,18584,18595,MethodCallMutator,resizeBuffer,end,3,0.03066888,<mask>(),"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {<mask>();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer"
614,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,473,18584,18595,MethodCallMutator,resizeBuffer,complete,4,0.03007615,<mask>(),"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {<mask>();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer"
615,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,475,18634,18640,IdentifierMutator-Variable,modulus,mode,0,0.17134255,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (<mask>) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
616,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,475,18634,18640,IdentifierMutator-Variable,modulus,type,1,0.13142978,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (<mask>) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
617,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,475,18634,18640,IdentifierMutator-Variable,modulus,bit,2,0.039191253,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (<mask>) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
618,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,475,18634,18640,IdentifierMutator-Variable,modulus,pos,3,0.03375763,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (<mask>) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
619,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,475,18634,18640,IdentifierMutator-Variable,modulus,version,4,0.027490968,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (<mask>) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
620,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,475,18634,18640,FieldReferenceMutator,modulus,mode,0,0.17134255,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (<mask>) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
621,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,475,18634,18640,FieldReferenceMutator,modulus,type,1,0.13142978,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (<mask>) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
622,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,475,18634,18640,FieldReferenceMutator,modulus,bit,2,0.039191253,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (<mask>) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
623,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,475,18634,18640,FieldReferenceMutator,modulus,pos,3,0.03375763,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (<mask>) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
624,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,475,18634,18640,FieldReferenceMutator,modulus,version,4,0.027490968,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (<mask>) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
625,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,476,18666,18666,IdentifierMutator-Literal,1,0,1,0.054954752,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case<mask> :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
626,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,476,18666,18666,IdentifierMutator-Literal,1,3,2,0.04661077,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case<mask> :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
627,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,476,18666,18666,IdentifierMutator-Literal,1,2,3,0.017740346,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case<mask> :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
628,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,476,18666,18666,IdentifierMutator-Literal,1,4,4,0.008284727,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case<mask> :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
629,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,477,18703,18703,AssignmentMutator,buffer[pos++]=encodeTable[(x>>2)&org.apache.commons.codec.binary.Base64.MASK_6BITS],|,0,0.7590315,buffer[pos++] <mask>= encodeTable[(x >> 2) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++]<mask>= encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
  "
630,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,477,18703,18703,AssignmentMutator,buffer[pos++]=encodeTable[(x>>2)&org.apache.commons.codec.binary.Base64.MASK_6BITS],^,1,0.18873869,buffer[pos++] <mask>= encodeTable[(x >> 2) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++]<mask>= encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
  "
631,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,477,18703,18703,AssignmentMutator,buffer[pos++]=encodeTable[(x>>2)&org.apache.commons.codec.binary.Base64.MASK_6BITS],*,2,0.020246686,buffer[pos++] <mask>= encodeTable[(x >> 2) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++]<mask>= encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
  "
632,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,477,18703,18703,AssignmentMutator,buffer[pos++]=encodeTable[(x>>2)&org.apache.commons.codec.binary.Base64.MASK_6BITS],&,3,0.009587456,buffer[pos++] <mask>= encodeTable[(x >> 2) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++]<mask>= encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
  "
633,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,477,18703,18703,AssignmentMutator,buffer[pos++]=encodeTable[(x>>2)&org.apache.commons.codec.binary.Base64.MASK_6BITS],|,4,0.0032216315,buffer[pos++] <mask>= encodeTable[(x >> 2) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++]<mask>= encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
  "
634,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,477,18697,18701,ArrayAccessMutator,pos++,pos,0,0.99829334,buffer[<mask>],"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[<mask>] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
635,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,477,18697,18701,ArrayAccessMutator,pos++,++,1,1.8626895E-4,buffer[<mask>],"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[<mask>] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
636,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,477,18697,18701,ArrayAccessMutator,pos++,neg,2,1.3344926E-4,buffer[<mask>],"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[<mask>] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
637,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,477,18697,18701,ArrayAccessMutator,pos++,push,3,1.0868133E-4,buffer[<mask>],"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[<mask>] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
638,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,477,18697,18701,ArrayAccessMutator,pos++,position,4,9.961791E-5,buffer[<mask>],"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[<mask>] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
639,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,477,18690,18695,IdentifierMutator-Variable,buffer,buf,2,6.9732615E-4,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :<mask>[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++"
640,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,477,18690,18695,IdentifierMutator-Variable,buffer,byte,3,6.6206E-4,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :<mask>[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++"
641,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,477,18690,18695,IdentifierMutator-Variable,buffer,Buffer,4,4.5481455E-4,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :<mask>[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++"
642,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,477,18690,18695,FieldReferenceMutator,buffer,buf,2,6.9732615E-4,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :<mask>[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++"
643,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,477,18690,18695,FieldReferenceMutator,buffer,byte,3,6.6206E-4,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :<mask>[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++"
644,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,477,18690,18695,FieldReferenceMutator,buffer,Buffer,4,4.5481455E-4,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :<mask>[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++"
645,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,477,18700,18701,UnaryOperatorMutator,++,+,2,2.5552875E-4,pos<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos<mask>] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
646,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,477,18700,18701,UnaryOperatorMutator,++,++;,3,7.411792E-5,pos<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos<mask>] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
647,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,477,18700,18701,UnaryOperatorMutator,++,--,4,5.8394104E-5,pos<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos<mask>] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
648,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,477,18697,18699,IdentifierMutator-Variable,pos,neg,1,4.9532995E-5,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[<mask>++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
649,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,477,18697,18699,IdentifierMutator-Variable,pos,len,2,3.780034E-5,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[<mask>++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
650,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,477,18697,18699,IdentifierMutator-Variable,pos,size,3,3.673594E-5,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[<mask>++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
651,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,477,18697,18699,FieldReferenceMutator,pos,neg,1,4.9532995E-5,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[<mask>++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
652,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,477,18697,18699,FieldReferenceMutator,pos,len,2,3.780034E-5,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[<mask>++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
653,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,477,18697,18699,FieldReferenceMutator,pos,size,3,3.673594E-5,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[<mask>++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
654,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,477,18718,18738,ArrayAccessMutator,(x>>2)&org.apache.commons.codec.binary.Base64.MASK_6BITS,x,0,0.900394,encodeTable[<mask>],"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
              "
655,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,477,18718,18738,ArrayAccessMutator,(x>>2)&org.apache.commons.codec.binary.Base64.MASK_6BITS,0,1,0.021540886,encodeTable[<mask>],"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
              "
656,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,477,18718,18738,ArrayAccessMutator,(x>>2)&org.apache.commons.codec.binary.Base64.MASK_6BITS,1,2,0.011227727,encodeTable[<mask>],"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
              "
657,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,477,18718,18738,ArrayAccessMutator,(x>>2)&org.apache.commons.codec.binary.Base64.MASK_6BITS,xx,3,0.0072812657,encodeTable[<mask>],"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
              "
658,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,477,18718,18738,ArrayAccessMutator,(x>>2)&org.apache.commons.codec.binary.Base64.MASK_6BITS,X,4,0.004639651,encodeTable[<mask>],"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
              "
659,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,477,18706,18716,IdentifierMutator-Variable,encodeTable,encode,0,0.3502056,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] =<mask>[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
660,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,477,18706,18716,IdentifierMutator-Variable,encodeTable,decode,1,0.078881785,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] =<mask>[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
661,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,477,18706,18716,IdentifierMutator-Variable,encodeTable,table,2,0.055399686,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] =<mask>[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
662,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,477,18706,18716,IdentifierMutator-Variable,encodeTable,encoded,3,0.033183258,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] =<mask>[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
663,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,477,18706,18716,IdentifierMutator-Variable,encodeTable,encoding,4,0.025917934,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] =<mask>[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
664,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,477,18706,18716,FieldReferenceMutator,encodeTable,encode,0,0.3502056,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] =<mask>[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
665,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,477,18706,18716,FieldReferenceMutator,encodeTable,decode,1,0.078881785,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] =<mask>[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
666,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,477,18706,18716,FieldReferenceMutator,encodeTable,table,2,0.055399686,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] =<mask>[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
667,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,477,18706,18716,FieldReferenceMutator,encodeTable,encoded,3,0.033183258,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] =<mask>[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
668,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,477,18706,18716,FieldReferenceMutator,encodeTable,encoding,4,0.025917934,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] =<mask>[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
669,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,477,18726,18728,BinaryOperatorMutator,&,|,2,0.0015625239,(x >> 2) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS,"byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2)<mask>MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
      "
670,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,477,18726,18728,BinaryOperatorMutator,&,^,3,1.20068624E-4,(x >> 2) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS,"byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2)<mask>MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
      "
671,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,477,18726,18728,BinaryOperatorMutator,&,~,4,3.0527593E-5,(x >> 2) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS,"byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2)<mask>MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
      "
672,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,477,18720,18723,BinaryOperatorMutator,>>,<<,0,0.7636425,x <mask> 2,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x<mask>2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
673,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,477,18720,18723,BinaryOperatorMutator,>>,<<,1,0.20518024,x <mask> 2,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x<mask>2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
674,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,477,18720,18723,BinaryOperatorMutator,>>,>>>,3,0.009546914,x <mask> 2,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x<mask>2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
675,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,477,18719,18719,IdentifierMutator-Variable,x,y,1,0.0012006484,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(<mask> >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
676,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,477,18719,18719,IdentifierMutator-Variable,x,xx,2,1.7857723E-4,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(<mask> >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
677,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,477,18719,18719,IdentifierMutator-Variable,x,b,3,9.344628E-5,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(<mask> >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
678,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,477,18719,18719,FieldReferenceMutator,x,y,1,0.0012006484,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(<mask> >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
679,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,477,18719,18719,FieldReferenceMutator,x,xx,2,1.7857723E-4,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(<mask> >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
680,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,477,18719,18719,FieldReferenceMutator,x,b,3,9.344628E-5,<mask>,"void encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(<mask> >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
   "
681,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,477,18724,18724,IdentifierMutator-Literal,2,6,1,0.20613815,<mask>," encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
682,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,477,18724,18724,IdentifierMutator-Literal,2,4,2,0.19874048,<mask>," encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
683,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,477,18724,18724,IdentifierMutator-Literal,2,3,3,0.07592256,<mask>," encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
684,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,477,18724,18724,IdentifierMutator-Literal,2,5,4,0.07236434,<mask>," encode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
    "
685,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,477,18729,18738,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,mask,0,0.40965712,<mask>,"[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) &<mask>];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
            "
686,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,477,18729,18738,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,7,1,0.08821417,<mask>,"[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) &<mask>];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
            "
687,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,477,18729,18738,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,3,2,0.065015025,<mask>,"[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) &<mask>];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
            "
688,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,477,18729,18738,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,63,3,0.058936555,<mask>,"[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) &<mask>];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
            "
689,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,477,18729,18738,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,1,4,0.057763945,<mask>,"[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) &<mask>];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
            "
690,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,477,18729,18738,FieldReferenceMutator,MASK_6BITS,mask,0,0.40965712,org.apache.commons.codec.binary.Base64.<mask>,"[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) &<mask>];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
            "
691,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,477,18729,18738,FieldReferenceMutator,MASK_6BITS,7,1,0.08821417,org.apache.commons.codec.binary.Base64.<mask>,"[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) &<mask>];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
            "
692,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,477,18729,18738,FieldReferenceMutator,MASK_6BITS,3,2,0.065015025,org.apache.commons.codec.binary.Base64.<mask>,"[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) &<mask>];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
            "
693,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,477,18729,18738,FieldReferenceMutator,MASK_6BITS,63,3,0.058936555,org.apache.commons.codec.binary.Base64.<mask>,"[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) &<mask>];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
            "
694,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,477,18729,18738,FieldReferenceMutator,MASK_6BITS,1,4,0.057763945,org.apache.commons.codec.binary.Base64.<mask>,"[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) &<mask>];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
            "
695,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18775,18775,AssignmentMutator,buffer[pos++]=encodeTable[(x<<4)&org.apache.commons.codec.binary.Base64.MASK_6BITS],|,0,0.7252279,buffer[pos++] <mask>= encodeTable[(x << 4) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"        return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6"
696,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18775,18775,AssignmentMutator,buffer[pos++]=encodeTable[(x<<4)&org.apache.commons.codec.binary.Base64.MASK_6BITS],^,1,0.17072235,buffer[pos++] <mask>= encodeTable[(x << 4) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"        return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6"
697,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18775,18775,AssignmentMutator,buffer[pos++]=encodeTable[(x<<4)&org.apache.commons.codec.binary.Base64.MASK_6BITS],*,2,0.045159075,buffer[pos++] <mask>= encodeTable[(x << 4) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"        return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6"
698,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18775,18775,AssignmentMutator,buffer[pos++]=encodeTable[(x<<4)&org.apache.commons.codec.binary.Base64.MASK_6BITS],&,3,0.011590125,buffer[pos++] <mask>= encodeTable[(x << 4) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"        return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6"
699,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18775,18775,AssignmentMutator,buffer[pos++]=encodeTable[(x<<4)&org.apache.commons.codec.binary.Base64.MASK_6BITS],||,4,0.007766007,buffer[pos++] <mask>= encodeTable[(x << 4) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"        return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6"
700,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18769,18773,ArrayAccessMutator,pos++,pos,0,0.9917168,buffer[<mask>],"           return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_"
701,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18769,18773,ArrayAccessMutator,pos++,++,1,0.0013328174,buffer[<mask>],"           return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_"
702,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18769,18773,ArrayAccessMutator,pos++,offset,2,4.2848106E-4,buffer[<mask>],"           return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_"
703,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18769,18773,ArrayAccessMutator,pos++,len,3,4.192596E-4,buffer[<mask>],"           return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_"
704,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18769,18773,ArrayAccessMutator,pos++,size,4,3.425378E-4,buffer[<mask>],"           return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_"
705,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18762,18767,IdentifierMutator-Variable,buffer,byte,2,0.0011420909,<mask>," int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];<mask>[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) &"
706,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18762,18767,IdentifierMutator-Variable,buffer,buf,3,0.001104526,<mask>," int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];<mask>[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) &"
707,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18762,18767,IdentifierMutator-Variable,buffer,pad,4,5.813769E-4,<mask>," int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];<mask>[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) &"
708,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18762,18767,FieldReferenceMutator,buffer,byte,2,0.0011420909,<mask>," int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];<mask>[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) &"
709,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18762,18767,FieldReferenceMutator,buffer,buf,3,0.001104526,<mask>," int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];<mask>[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) &"
710,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18762,18767,FieldReferenceMutator,buffer,pad,4,5.813769E-4,<mask>," int inAvail) {
        if (eof) {
            return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];<mask>[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) &"
711,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18772,18773,UnaryOperatorMutator,++,+,2,1.6009732E-4,pos<mask>,"          return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos<mask>] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_"
712,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18772,18773,UnaryOperatorMutator,++,++;,3,1.3102376E-4,pos<mask>,"          return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos<mask>] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_"
713,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18772,18773,UnaryOperatorMutator,++,--,4,7.566134E-5,pos<mask>,"          return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos<mask>] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_"
714,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18769,18771,IdentifierMutator-Variable,pos,len,1,1.2618772E-4,<mask>,"           return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK"
715,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18769,18771,IdentifierMutator-Variable,pos,size,2,1.21800396E-4,<mask>,"           return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK"
716,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18769,18771,IdentifierMutator-Variable,pos,neg,3,7.470588E-5,<mask>,"           return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK"
717,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18769,18771,FieldReferenceMutator,pos,len,1,1.2618772E-4,<mask>,"           return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK"
718,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18769,18771,FieldReferenceMutator,pos,size,2,1.21800396E-4,<mask>,"           return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK"
719,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18769,18771,FieldReferenceMutator,pos,neg,3,7.470588E-5,<mask>,"           return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK"
720,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18790,18810,ArrayAccessMutator,(x<<4)&org.apache.commons.codec.binary.Base64.MASK_6BITS,x,0,0.46944067,encodeTable[<mask>],"    return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
            "
721,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18790,18810,ArrayAccessMutator,(x<<4)&org.apache.commons.codec.binary.Base64.MASK_6BITS,0,1,0.07089725,encodeTable[<mask>],"    return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
            "
722,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18790,18810,ArrayAccessMutator,(x<<4)&org.apache.commons.codec.binary.Base64.MASK_6BITS,1,2,0.05649393,encodeTable[<mask>],"    return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
            "
723,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18790,18810,ArrayAccessMutator,(x<<4)&org.apache.commons.codec.binary.Base64.MASK_6BITS,pos,3,0.042519633,encodeTable[<mask>],"    return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
            "
724,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18790,18810,ArrayAccessMutator,(x<<4)&org.apache.commons.codec.binary.Base64.MASK_6BITS,2,4,0.027682172,encodeTable[<mask>],"    return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
            "
725,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18778,18788,IdentifierMutator-Variable,encodeTable,buffer,0,0.1352958,<mask>,"       return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];"
726,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18778,18788,IdentifierMutator-Variable,encodeTable,padding,1,0.13085298,<mask>,"       return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];"
727,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18778,18788,IdentifierMutator-Variable,encodeTable,encode,2,0.097900845,<mask>,"       return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];"
728,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18778,18788,IdentifierMutator-Variable,encodeTable,pad,3,0.07295836,<mask>,"       return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];"
729,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18778,18788,IdentifierMutator-Variable,encodeTable,decode,4,0.0514366,<mask>,"       return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];"
730,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18778,18788,FieldReferenceMutator,encodeTable,buffer,0,0.1352958,<mask>,"       return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];"
731,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18778,18788,FieldReferenceMutator,encodeTable,padding,1,0.13085298,<mask>,"       return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];"
732,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18778,18788,FieldReferenceMutator,encodeTable,encode,2,0.097900845,<mask>,"       return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];"
733,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18778,18788,FieldReferenceMutator,encodeTable,pad,3,0.07295836,<mask>,"       return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];"
734,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18778,18788,FieldReferenceMutator,encodeTable,decode,4,0.0514366,<mask>,"       return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];"
735,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18798,18800,BinaryOperatorMutator,&,|,2,0.01860183,(x << 4) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS,"
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4)<mask>MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
      "
736,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18798,18800,BinaryOperatorMutator,&,^,3,7.7618205E-4,(x << 4) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS,"
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4)<mask>MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
      "
737,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18798,18800,BinaryOperatorMutator,&,|,4,3.331899E-4,(x << 4) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS,"
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4)<mask>MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
      "
738,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18792,18795,BinaryOperatorMutator,<<,>>,0,0.70748925,x <mask> 4,"  return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x<mask>4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
   "
739,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18792,18795,BinaryOperatorMutator,<<,>>,1,0.20853873,x <mask> 4,"  return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x<mask>4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
   "
740,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18792,18795,BinaryOperatorMutator,<<,-,3,0.010474247,x <mask> 4,"  return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x<mask>4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
   "
741,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18792,18795,BinaryOperatorMutator,<<,->,4,0.0030510647,x <mask> 4,"  return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x<mask>4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
   "
742,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18791,18791,IdentifierMutator-Variable,x,y,1,1.20980214E-4,<mask>,"   return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
  "
743,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18791,18791,IdentifierMutator-Variable,x,xx,2,6.727812E-5,<mask>,"   return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
  "
744,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18791,18791,IdentifierMutator-Variable,x,X,4,1.879067E-5,<mask>,"   return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
  "
745,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18791,18791,FieldReferenceMutator,x,y,1,1.20980214E-4,<mask>,"   return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
  "
746,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18791,18791,FieldReferenceMutator,x,xx,2,6.727812E-5,<mask>,"   return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
  "
747,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18791,18791,FieldReferenceMutator,x,X,4,1.879067E-5,<mask>,"   return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
  "
748,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18796,18796,IdentifierMutator-Literal,4,1,0,0.19887765,<mask>," return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x <<<mask>) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
    "
749,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18796,18796,IdentifierMutator-Literal,4,3,1,0.14177974,<mask>," return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x <<<mask>) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
    "
750,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18796,18796,IdentifierMutator-Literal,4,6,2,0.12830861,<mask>," return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x <<<mask>) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
    "
751,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18796,18796,IdentifierMutator-Literal,4,5,3,0.11965267,<mask>," return;
        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x <<<mask>) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
    "
752,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18801,18810,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,mask,0,0.41023532,<mask>,"        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) &<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
            "
753,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18801,18810,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,1,1,0.122704715,<mask>,"        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) &<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
            "
754,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18801,18810,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,7,2,0.05653944,<mask>,"        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) &<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
            "
755,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18801,18810,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,255,3,0.0391737,<mask>,"        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) &<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
            "
756,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18801,18810,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,3,4,0.037439104,<mask>,"        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) &<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
            "
757,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18801,18810,FieldReferenceMutator,MASK_6BITS,mask,0,0.41023532,org.apache.commons.codec.binary.Base64.<mask>,"        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) &<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
            "
758,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18801,18810,FieldReferenceMutator,MASK_6BITS,1,1,0.122704715,org.apache.commons.codec.binary.Base64.<mask>,"        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) &<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
            "
759,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18801,18810,FieldReferenceMutator,MASK_6BITS,7,2,0.05653944,org.apache.commons.codec.binary.Base64.<mask>,"        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) &<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
            "
760,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18801,18810,FieldReferenceMutator,MASK_6BITS,255,3,0.0391737,org.apache.commons.codec.binary.Base64.<mask>,"        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) &<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
            "
761,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,478,18801,18810,FieldReferenceMutator,MASK_6BITS,3,4,0.037439104,org.apache.commons.codec.binary.Base64.<mask>,"        }
        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0) {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) &<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
            "
762,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,480,18923,18926,BinaryOperatorMutator,==,!=,2,0.086140886,encodeTable <mask> org.apache.commons.codec.binary.Base64.STANDARD_ENCODE_TABLE,"           eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable<mask>STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x"
763,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,480,18923,18926,BinaryOperatorMutator,==,_,3,0.017122086,encodeTable <mask> org.apache.commons.codec.binary.Base64.STANDARD_ENCODE_TABLE,"           eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable<mask>STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x"
764,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,480,18923,18926,BinaryOperatorMutator,==,=,4,0.012852635,encodeTable <mask> org.apache.commons.codec.binary.Base64.STANDARD_ENCODE_TABLE,"           eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable<mask>STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x"
765,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,480,18912,18922,IdentifierMutator-Variable,encodeTable,mode,0,0.17699435,<mask>," {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (<mask> == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x"
766,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,480,18912,18922,IdentifierMutator-Variable,encodeTable,type,1,0.13789225,<mask>," {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (<mask> == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x"
767,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,480,18912,18922,IdentifierMutator-Variable,encodeTable,x,2,0.086638995,<mask>," {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (<mask> == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x"
768,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,480,18912,18922,IdentifierMutator-Variable,encodeTable,padding,3,0.03498366,<mask>," {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (<mask> == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x"
769,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,480,18912,18922,IdentifierMutator-Variable,encodeTable,format,4,0.026209446,<mask>," {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (<mask> == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x"
770,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,480,18912,18922,FieldReferenceMutator,encodeTable,mode,0,0.17699435,<mask>," {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (<mask> == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x"
771,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,480,18912,18922,FieldReferenceMutator,encodeTable,type,1,0.13789225,<mask>," {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (<mask> == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x"
772,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,480,18912,18922,FieldReferenceMutator,encodeTable,x,2,0.086638995,<mask>," {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (<mask> == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x"
773,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,480,18912,18922,FieldReferenceMutator,encodeTable,padding,3,0.03498366,<mask>," {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (<mask> == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x"
774,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,480,18912,18922,FieldReferenceMutator,encodeTable,format,4,0.026209446,<mask>," {
            eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (<mask> == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x"
775,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,480,18927,18947,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.STANDARD_ENCODE_TABLE,null,0,0.8546874,<mask>,"          eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable ==<mask>) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6"
776,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,480,18927,18947,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.STANDARD_ENCODE_TABLE,0,1,0.039812077,<mask>,"          eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable ==<mask>) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6"
777,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,480,18927,18947,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.STANDARD_ENCODE_TABLE,1,2,0.016675754,<mask>,"          eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable ==<mask>) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6"
778,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,480,18927,18947,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.STANDARD_ENCODE_TABLE,nil,3,0.0074899825,<mask>,"          eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable ==<mask>) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6"
779,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,480,18927,18947,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.STANDARD_ENCODE_TABLE,NULL,4,0.006329378,<mask>,"          eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable ==<mask>) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6"
780,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,480,18927,18947,FieldReferenceMutator,STANDARD_ENCODE_TABLE,null,0,0.8546874,org.apache.commons.codec.binary.Base64.<mask>,"          eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable ==<mask>) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6"
781,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,480,18927,18947,FieldReferenceMutator,STANDARD_ENCODE_TABLE,0,1,0.039812077,org.apache.commons.codec.binary.Base64.<mask>,"          eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable ==<mask>) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6"
782,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,480,18927,18947,FieldReferenceMutator,STANDARD_ENCODE_TABLE,1,2,0.016675754,org.apache.commons.codec.binary.Base64.<mask>,"          eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable ==<mask>) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6"
783,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,480,18927,18947,FieldReferenceMutator,STANDARD_ENCODE_TABLE,nil,3,0.0074899825,org.apache.commons.codec.binary.Base64.<mask>,"          eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable ==<mask>) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6"
784,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,480,18927,18947,FieldReferenceMutator,STANDARD_ENCODE_TABLE,NULL,4,0.006329378,org.apache.commons.codec.binary.Base64.<mask>,"          eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable ==<mask>) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6"
785,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,481,18989,18989,AssignmentMutator,buffer[pos++]=org.apache.commons.codec.binary.Base64.PAD,|,0,0.6528652,buffer[pos++] <mask>= org.apache.commons.codec.binary.Base64.PAD," encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++]<mask>= PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the"
786,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,481,18989,18989,AssignmentMutator,buffer[pos++]=org.apache.commons.codec.binary.Base64.PAD,^,1,0.16533926,buffer[pos++] <mask>= org.apache.commons.codec.binary.Base64.PAD," encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++]<mask>= PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the"
787,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,481,18989,18989,AssignmentMutator,buffer[pos++]=org.apache.commons.codec.binary.Base64.PAD,*,2,0.10714945,buffer[pos++] <mask>= org.apache.commons.codec.binary.Base64.PAD," encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++]<mask>= PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the"
788,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,481,18989,18989,AssignmentMutator,buffer[pos++]=org.apache.commons.codec.binary.Base64.PAD,&,3,0.019563375,buffer[pos++] <mask>= org.apache.commons.codec.binary.Base64.PAD," encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++]<mask>= PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the"
789,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,481,18989,18989,AssignmentMutator,buffer[pos++]=org.apache.commons.codec.binary.Base64.PAD,|,4,0.007915882,buffer[pos++] <mask>= org.apache.commons.codec.binary.Base64.PAD," encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++]<mask>= PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the"
790,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,481,18983,18987,ArrayAccessMutator,pos++,pos,0,0.9968829,buffer[<mask>]," - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips"
791,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,481,18983,18987,ArrayAccessMutator,pos++,++,1,4.8905157E-4,buffer[<mask>]," - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips"
792,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,481,18983,18987,ArrayAccessMutator,pos++,push,2,2.3605679E-4,buffer[<mask>]," - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips"
793,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,481,18983,18987,ArrayAccessMutator,pos++,size,3,1.4590618E-4,buffer[<mask>]," - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips"
794,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,481,18983,18987,ArrayAccessMutator,pos++,len,4,1.2484242E-4,buffer[<mask>]," - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips"
795,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,481,18976,18981,IdentifierMutator-Variable,buffer,pad,2,0.002047175,<mask>," eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {<mask>[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SA"
796,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,481,18976,18981,IdentifierMutator-Variable,buffer,byte,3,0.0013995272,<mask>," eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {<mask>[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SA"
797,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,481,18976,18981,IdentifierMutator-Variable,buffer,header,4,0.0012758017,<mask>," eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {<mask>[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SA"
798,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,481,18976,18981,FieldReferenceMutator,buffer,pad,2,0.002047175,<mask>," eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {<mask>[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SA"
799,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,481,18976,18981,FieldReferenceMutator,buffer,byte,3,0.0013995272,<mask>," eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {<mask>[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SA"
800,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,481,18976,18981,FieldReferenceMutator,buffer,header,4,0.0012758017,<mask>," eof = true;
            if (buffer == null || buffer.length - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {<mask>[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SA"
801,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,481,18986,18987,UnaryOperatorMutator,++,++;,2,1.7955797E-4,pos<mask>," pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos<mask>] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips"
802,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,481,18986,18987,UnaryOperatorMutator,++,+,3,1.1226093E-4,pos<mask>," pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos<mask>] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips"
803,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,481,18986,18987,UnaryOperatorMutator,++,--,4,7.178132E-5,pos<mask>," pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos<mask>] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips"
804,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,481,18983,18985,IdentifierMutator-Variable,pos,size,1,1.2489846E-4,<mask>," - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE sk"
805,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,481,18983,18985,IdentifierMutator-Variable,pos,len,2,1.1581752E-4,<mask>," - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE sk"
806,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,481,18983,18985,IdentifierMutator-Variable,pos,neg,3,7.4294054E-5,<mask>," - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE sk"
807,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,481,18983,18985,IdentifierMutator-Variable,pos,count,4,3.158705E-5,<mask>," - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE sk"
808,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,481,18983,18985,FieldReferenceMutator,pos,size,1,1.2489846E-4,<mask>," - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE sk"
809,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,481,18983,18985,FieldReferenceMutator,pos,len,2,1.1581752E-4,<mask>," - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE sk"
810,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,481,18983,18985,FieldReferenceMutator,pos,neg,3,7.4294054E-5,<mask>," - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE sk"
811,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,481,18983,18985,FieldReferenceMutator,pos,count,4,3.158705E-5,<mask>," - pos < encodeSize) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE sk"
812,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,481,18992,18994,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,SPACE,0,0.08046446,<mask>,"Size) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] =<mask>;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further"
813,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,481,18992,18994,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,ESC,1,0.061571576,<mask>,"Size) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] =<mask>;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further"
814,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,481,18992,18994,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,END,2,0.059094843,<mask>,"Size) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] =<mask>;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further"
815,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,481,18992,18994,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,CONTROL,3,0.04906223,<mask>,"Size) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] =<mask>;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further"
816,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,481,18992,18994,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,OP,4,0.03906672,<mask>,"Size) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] =<mask>;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further"
817,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,481,18992,18994,FieldReferenceMutator,PAD,SPACE,0,0.08046446,org.apache.commons.codec.binary.Base64.<mask>,"Size) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] =<mask>;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further"
818,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,481,18992,18994,FieldReferenceMutator,PAD,ESC,1,0.061571576,org.apache.commons.codec.binary.Base64.<mask>,"Size) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] =<mask>;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further"
819,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,481,18992,18994,FieldReferenceMutator,PAD,END,2,0.059094843,org.apache.commons.codec.binary.Base64.<mask>,"Size) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] =<mask>;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further"
820,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,481,18992,18994,FieldReferenceMutator,PAD,CONTROL,3,0.04906223,org.apache.commons.codec.binary.Base64.<mask>,"Size) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] =<mask>;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further"
821,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,481,18992,18994,FieldReferenceMutator,PAD,OP,4,0.03906672,org.apache.commons.codec.binary.Base64.<mask>,"Size) {
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] =<mask>;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further"
822,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,482,19034,19034,AssignmentMutator,buffer[pos++]=org.apache.commons.codec.binary.Base64.PAD,|,0,0.5270846,buffer[pos++] <mask>= org.apache.commons.codec.binary.Base64.PAD,"   }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++]<mask>= PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STAND"
823,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,482,19034,19034,AssignmentMutator,buffer[pos++]=org.apache.commons.codec.binary.Base64.PAD,^,1,0.28804612,buffer[pos++] <mask>= org.apache.commons.codec.binary.Base64.PAD,"   }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++]<mask>= PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STAND"
824,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,482,19034,19034,AssignmentMutator,buffer[pos++]=org.apache.commons.codec.binary.Base64.PAD,*,2,0.11740384,buffer[pos++] <mask>= org.apache.commons.codec.binary.Base64.PAD,"   }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++]<mask>= PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STAND"
825,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,482,19034,19034,AssignmentMutator,buffer[pos++]=org.apache.commons.codec.binary.Base64.PAD,&,3,0.021688653,buffer[pos++] <mask>= org.apache.commons.codec.binary.Base64.PAD,"   }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++]<mask>= PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STAND"
826,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,482,19034,19034,AssignmentMutator,buffer[pos++]=org.apache.commons.codec.binary.Base64.PAD,|,4,0.0054546776,buffer[pos++] <mask>= org.apache.commons.codec.binary.Base64.PAD,"   }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++]<mask>= PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STAND"
827,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,482,19028,19032,ArrayAccessMutator,pos++,pos,0,0.99240816,buffer[<mask>],"      }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[<mask>] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable =="
828,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,482,19028,19032,ArrayAccessMutator,pos++,++,1,7.495023E-4,buffer[<mask>],"      }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[<mask>] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable =="
829,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,482,19028,19032,ArrayAccessMutator,pos++,len,2,5.879905E-4,buffer[<mask>],"      }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[<mask>] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable =="
830,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,482,19028,19032,ArrayAccessMutator,pos++,size,3,5.464432E-4,buffer[<mask>],"      }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[<mask>] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable =="
831,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,482,19028,19032,ArrayAccessMutator,pos++,neg,4,3.9207624E-4,buffer[<mask>],"      }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[<mask>] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable =="
832,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,482,19021,19026,IdentifierMutator-Variable,buffer,pad,1,0.105922684,<mask>,"
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;<mask>[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (en"
833,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,482,19021,19026,IdentifierMutator-Variable,buffer,padding,2,0.103313886,<mask>,"
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;<mask>[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (en"
834,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,482,19021,19026,IdentifierMutator-Variable,buffer,output,3,0.047545757,<mask>,"
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;<mask>[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (en"
835,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,482,19021,19026,IdentifierMutator-Variable,buffer,out,4,0.018802049,<mask>,"
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;<mask>[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (en"
836,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,482,19021,19026,FieldReferenceMutator,buffer,pad,1,0.105922684,<mask>,"
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;<mask>[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (en"
837,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,482,19021,19026,FieldReferenceMutator,buffer,padding,2,0.103313886,<mask>,"
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;<mask>[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (en"
838,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,482,19021,19026,FieldReferenceMutator,buffer,output,3,0.047545757,<mask>,"
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;<mask>[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (en"
839,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,482,19021,19026,FieldReferenceMutator,buffer,out,4,0.018802049,<mask>,"
                resizeBuffer();
            }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;<mask>[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (en"
840,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,482,19031,19032,UnaryOperatorMutator,++,--,2,2.2116514E-4,pos<mask>,"     }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos<mask>] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable =="
841,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,482,19031,19032,UnaryOperatorMutator,++,++;,3,1.4731004E-4,pos<mask>,"     }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos<mask>] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable =="
842,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,482,19031,19032,UnaryOperatorMutator,++,+,4,1.0931901E-4,pos<mask>,"     }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos<mask>] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable =="
843,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,482,19028,19030,IdentifierMutator-Variable,pos,len,1,5.8309315E-4,<mask>,"      }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[<mask>++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable"
844,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,482,19028,19030,IdentifierMutator-Variable,pos,neg,2,4.683775E-4,<mask>,"      }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[<mask>++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable"
845,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,482,19028,19030,IdentifierMutator-Variable,pos,size,3,4.2802066E-4,<mask>,"      }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[<mask>++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable"
846,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,482,19028,19030,IdentifierMutator-Variable,pos,count,4,1.2716428E-4,<mask>,"      }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[<mask>++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable"
847,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,482,19028,19030,FieldReferenceMutator,pos,len,1,5.8309315E-4,<mask>,"      }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[<mask>++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable"
848,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,482,19028,19030,FieldReferenceMutator,pos,neg,2,4.683775E-4,<mask>,"      }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[<mask>++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable"
849,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,482,19028,19030,FieldReferenceMutator,pos,size,3,4.2802066E-4,<mask>,"      }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[<mask>++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable"
850,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,482,19028,19030,FieldReferenceMutator,pos,count,4,1.2716428E-4,<mask>,"      }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[<mask>++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable"
851,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,482,19037,19039,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,SPACE,0,0.12200858,<mask>,"  }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] =<mask>;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENC"
852,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,482,19037,19039,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,END,1,0.09355739,<mask>,"  }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] =<mask>;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENC"
853,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,482,19037,19039,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,0,2,0.054976795,<mask>,"  }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] =<mask>;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENC"
854,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,482,19037,19039,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,NULL,3,0.05491863,<mask>,"  }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] =<mask>;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENC"
855,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,482,19037,19039,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,WHITE,4,0.04002215,<mask>,"  }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] =<mask>;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENC"
856,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,482,19037,19039,FieldReferenceMutator,PAD,SPACE,0,0.12200858,org.apache.commons.codec.binary.Base64.<mask>,"  }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] =<mask>;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENC"
857,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,482,19037,19039,FieldReferenceMutator,PAD,END,1,0.09355739,org.apache.commons.codec.binary.Base64.<mask>,"  }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] =<mask>;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENC"
858,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,482,19037,19039,FieldReferenceMutator,PAD,0,2,0.054976795,org.apache.commons.codec.binary.Base64.<mask>,"  }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] =<mask>;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENC"
859,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,482,19037,19039,FieldReferenceMutator,PAD,NULL,3,0.05491863,org.apache.commons.codec.binary.Base64.<mask>,"  }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] =<mask>;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENC"
860,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,482,19037,19039,FieldReferenceMutator,PAD,WHITE,4,0.04002215,org.apache.commons.codec.binary.Base64.<mask>,"  }
            switch (modulus) {
                case 1 :
                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] =<mask>;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENC"
861,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,486,19113,19113,IdentifierMutator-Literal,2,10,0,0.08821452,<mask>,"] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case<mask> :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
  "
862,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,486,19113,19113,IdentifierMutator-Literal,2,32,2,0.051304154,<mask>,"] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case<mask> :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
  "
863,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,486,19113,19113,IdentifierMutator-Literal,2,8,3,0.04720085,<mask>,"] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case<mask> :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
  "
864,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,486,19113,19113,IdentifierMutator-Literal,2,13,4,0.046745274,<mask>,"] = encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case<mask> :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
  "
865,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19150,19150,AssignmentMutator,buffer[pos++]=encodeTable[(x>>10)&org.apache.commons.codec.binary.Base64.MASK_6BITS],|,0,0.55993384,buffer[pos++] <mask>= encodeTable[(x >> 10) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"            buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++]<mask>= encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
      "
866,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19150,19150,AssignmentMutator,buffer[pos++]=encodeTable[(x>>10)&org.apache.commons.codec.binary.Base64.MASK_6BITS],^,1,0.20096484,buffer[pos++] <mask>= encodeTable[(x >> 10) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"            buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++]<mask>= encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
      "
867,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19150,19150,AssignmentMutator,buffer[pos++]=encodeTable[(x>>10)&org.apache.commons.codec.binary.Base64.MASK_6BITS],*,2,0.1375762,buffer[pos++] <mask>= encodeTable[(x >> 10) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"            buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++]<mask>= encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
      "
868,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19150,19150,AssignmentMutator,buffer[pos++]=encodeTable[(x>>10)&org.apache.commons.codec.binary.Base64.MASK_6BITS],&,3,0.017520567,buffer[pos++] <mask>= encodeTable[(x >> 10) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"            buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++]<mask>= encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
      "
869,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19150,19150,AssignmentMutator,buffer[pos++]=encodeTable[(x>>10)&org.apache.commons.codec.binary.Base64.MASK_6BITS],||,4,0.013834343,buffer[pos++] <mask>= encodeTable[(x >> 10) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"            buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++]<mask>= encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
      "
870,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19144,19148,ArrayAccessMutator,pos++,pos,0,0.9974579,buffer[<mask>],"               buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[<mask>] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
     "
871,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19144,19148,ArrayAccessMutator,pos++,++,1,2.2722773E-4,buffer[<mask>],"               buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[<mask>] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
     "
872,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19144,19148,ArrayAccessMutator,pos++,position,2,1.3266483E-4,buffer[<mask>],"               buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[<mask>] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
     "
873,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19144,19148,ArrayAccessMutator,pos++,push,3,1.1517692E-4,buffer[<mask>],"               buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[<mask>] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
     "
874,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19144,19148,ArrayAccessMutator,pos++,len,4,1.0592083E-4,buffer[<mask>],"               buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[<mask>] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
     "
875,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19137,19142,IdentifierMutator-Variable,buffer,byte,2,0.0033770215,<mask>," encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :<mask>[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
  "
876,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19137,19142,IdentifierMutator-Variable,buffer,Buffer,3,0.0012441438,<mask>," encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :<mask>[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
  "
877,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19137,19142,IdentifierMutator-Variable,buffer,Buffer,4,8.9903094E-4,<mask>," encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :<mask>[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
  "
878,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19137,19142,FieldReferenceMutator,buffer,byte,2,0.0033770215,<mask>," encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :<mask>[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
  "
879,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19137,19142,FieldReferenceMutator,buffer,Buffer,3,0.0012441438,<mask>," encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :<mask>[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
  "
880,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19137,19142,FieldReferenceMutator,buffer,Buffer,4,8.9903094E-4,<mask>," encodeTable[(x >> 2) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :<mask>[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
  "
881,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19147,19148,UnaryOperatorMutator,++,+,2,8.97298E-5,pos<mask>,"              buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos<mask>] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
     "
882,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19147,19148,UnaryOperatorMutator,++,++;,3,4.1023275E-5,pos<mask>,"              buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos<mask>] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
     "
883,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19147,19148,UnaryOperatorMutator,++,+=,4,1.2975764E-5,pos<mask>,"              buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos<mask>] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
     "
884,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19144,19146,IdentifierMutator-Variable,pos,len,1,5.3168344E-5,<mask>,"               buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[<mask>++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
    "
885,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19144,19146,IdentifierMutator-Variable,pos,size,2,4.046301E-5,<mask>,"               buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[<mask>++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
    "
886,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19144,19146,IdentifierMutator-Variable,pos,neg,3,3.688734E-5,<mask>,"               buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[<mask>++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
    "
887,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19144,19146,FieldReferenceMutator,pos,len,1,5.3168344E-5,<mask>,"               buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[<mask>++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
    "
888,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19144,19146,FieldReferenceMutator,pos,size,2,4.046301E-5,<mask>,"               buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[<mask>++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
    "
889,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19144,19146,FieldReferenceMutator,pos,neg,3,3.688734E-5,<mask>,"               buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[<mask>++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
    "
890,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19165,19186,ArrayAccessMutator,(x>>10)&org.apache.commons.codec.binary.Base64.MASK_6BITS,x,0,0.76318437,encodeTable[<mask>],"        buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
         "
891,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19165,19186,ArrayAccessMutator,(x>>10)&org.apache.commons.codec.binary.Base64.MASK_6BITS,1,1,0.050167717,encodeTable[<mask>],"        buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
         "
892,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19165,19186,ArrayAccessMutator,(x>>10)&org.apache.commons.codec.binary.Base64.MASK_6BITS,2,2,0.037808243,encodeTable[<mask>],"        buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
         "
893,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19165,19186,ArrayAccessMutator,(x>>10)&org.apache.commons.codec.binary.Base64.MASK_6BITS,0,3,0.01987375,encodeTable[<mask>],"        buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
         "
894,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19165,19186,ArrayAccessMutator,(x>>10)&org.apache.commons.codec.binary.Base64.MASK_6BITS,i,4,0.014358742,encodeTable[<mask>],"        buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
         "
895,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19153,19163,IdentifierMutator-Variable,encodeTable,encode,0,0.23676376,<mask>,"           buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] =<mask>[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
         "
896,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19153,19163,IdentifierMutator-Variable,encodeTable,table,1,0.16934125,<mask>,"           buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] =<mask>[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
         "
897,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19153,19163,IdentifierMutator-Variable,encodeTable,buffer,2,0.052260287,<mask>,"           buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] =<mask>[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
         "
898,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19153,19163,IdentifierMutator-Variable,encodeTable,decode,3,0.052082166,<mask>,"           buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] =<mask>[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
         "
899,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19153,19163,IdentifierMutator-Variable,encodeTable,encoded,4,0.049330443,<mask>,"           buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] =<mask>[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
         "
900,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19153,19163,FieldReferenceMutator,encodeTable,encode,0,0.23676376,<mask>,"           buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] =<mask>[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
         "
901,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19153,19163,FieldReferenceMutator,encodeTable,table,1,0.16934125,<mask>,"           buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] =<mask>[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
         "
902,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19153,19163,FieldReferenceMutator,encodeTable,buffer,2,0.052260287,<mask>,"           buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] =<mask>[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
         "
903,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19153,19163,FieldReferenceMutator,encodeTable,decode,3,0.052082166,<mask>,"           buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] =<mask>[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
         "
904,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19153,19163,FieldReferenceMutator,encodeTable,encoded,4,0.049330443,<mask>,"           buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] =<mask>[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
         "
905,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19174,19176,BinaryOperatorMutator,&,|,2,2.3115605E-4,(x >> 10) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS,"   buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10)<mask>MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
   "
906,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19174,19176,BinaryOperatorMutator,&,^,3,3.7780846E-5,(x >> 10) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS,"   buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10)<mask>MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
   "
907,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19174,19176,BinaryOperatorMutator,&,+,4,2.1154929E-5,(x >> 10) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS,"   buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10)<mask>MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
   "
908,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19167,19170,BinaryOperatorMutator,>>,>>>,2,0.20307624,x <mask> 10,"      buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x<mask>10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
"
909,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19167,19170,BinaryOperatorMutator,>>,<<,3,0.16924475,x <mask> 10,"      buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x<mask>10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
"
910,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19167,19170,BinaryOperatorMutator,>>,>>>,4,0.022735298,x <mask> 10,"      buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x<mask>10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
"
911,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19166,19166,IdentifierMutator-Variable,x,y,1,2.1688893E-5,<mask>,"       buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(<mask> >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }"
912,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19166,19166,IdentifierMutator-Variable,x,xx,2,7.924042E-6,<mask>,"       buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(<mask> >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }"
913,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19166,19166,IdentifierMutator-Variable,x,X,3,6.468315E-6,<mask>,"       buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(<mask> >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }"
914,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19166,19166,FieldReferenceMutator,x,y,1,2.1688893E-5,<mask>,"       buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(<mask> >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }"
915,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19166,19166,FieldReferenceMutator,x,xx,2,7.924042E-6,<mask>,"       buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(<mask> >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }"
916,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19166,19166,FieldReferenceMutator,x,X,3,6.468315E-6,<mask>,"       buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(<mask> >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }"
917,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19171,19172,IdentifierMutator-Literal,10,6,0,0.4788991,<mask>,"     buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
 "
918,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19171,19172,IdentifierMutator-Literal,10,8,1,0.1464764,<mask>,"     buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
 "
919,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19171,19172,IdentifierMutator-Literal,10,5,2,0.09553842,<mask>,"     buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
 "
920,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19171,19172,IdentifierMutator-Literal,10,2,3,0.085164286,<mask>,"     buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
 "
921,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19171,19172,IdentifierMutator-Literal,10,7,4,0.068057455,<mask>,"     buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
 "
922,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19177,19186,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,7,0,0.12702222,<mask>,"  buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
         "
923,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19177,19186,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,mask,1,0.09988066,<mask>,"  buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
         "
924,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19177,19186,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,255,2,0.0651491,<mask>,"  buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
         "
925,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19177,19186,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,3,3,0.06439076,<mask>,"  buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
         "
926,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19177,19186,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,1,4,0.04845752,<mask>,"  buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
         "
927,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19177,19186,FieldReferenceMutator,MASK_6BITS,7,0,0.12702222,org.apache.commons.codec.binary.Base64.<mask>,"  buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
         "
928,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19177,19186,FieldReferenceMutator,MASK_6BITS,mask,1,0.09988066,org.apache.commons.codec.binary.Base64.<mask>,"  buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
         "
929,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19177,19186,FieldReferenceMutator,MASK_6BITS,255,2,0.0651491,org.apache.commons.codec.binary.Base64.<mask>,"  buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
         "
930,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19177,19186,FieldReferenceMutator,MASK_6BITS,3,3,0.06439076,org.apache.commons.codec.binary.Base64.<mask>,"  buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
         "
931,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,487,19177,19186,FieldReferenceMutator,MASK_6BITS,1,4,0.04845752,org.apache.commons.codec.binary.Base64.<mask>,"  buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
         "
932,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,488,19223,19223,AssignmentMutator,buffer[pos++]=encodeTable[(x>>4)&org.apache.commons.codec.binary.Base64.MASK_6BITS],|,0,0.5297001,buffer[pos++] <mask>= encodeTable[(x >> 4) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"            // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
           "
933,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,488,19223,19223,AssignmentMutator,buffer[pos++]=encodeTable[(x>>4)&org.apache.commons.codec.binary.Base64.MASK_6BITS],^,1,0.21699329,buffer[pos++] <mask>= encodeTable[(x >> 4) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"            // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
           "
934,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,488,19223,19223,AssignmentMutator,buffer[pos++]=encodeTable[(x>>4)&org.apache.commons.codec.binary.Base64.MASK_6BITS],*,2,0.13735306,buffer[pos++] <mask>= encodeTable[(x >> 4) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"            // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
           "
935,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,488,19223,19223,AssignmentMutator,buffer[pos++]=encodeTable[(x>>4)&org.apache.commons.codec.binary.Base64.MASK_6BITS],&,3,0.022625152,buffer[pos++] <mask>= encodeTable[(x >> 4) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"            // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
           "
936,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,488,19223,19223,AssignmentMutator,buffer[pos++]=encodeTable[(x>>4)&org.apache.commons.codec.binary.Base64.MASK_6BITS],||,4,0.013497411,buffer[pos++] <mask>= encodeTable[(x >> 4) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"            // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
           "
937,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,488,19217,19221,ArrayAccessMutator,pos++,pos,0,0.9963117,buffer[<mask>],"               // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
          "
938,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,488,19217,19221,ArrayAccessMutator,pos++,++,1,0.0010268332,buffer[<mask>],"               // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
          "
939,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,488,19217,19221,ArrayAccessMutator,pos++,push,2,2.1710286E-4,buffer[<mask>],"               // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
          "
940,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,488,19217,19221,ArrayAccessMutator,pos++,neg,3,1.8292603E-4,buffer[<mask>],"               // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
          "
941,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,488,19217,19221,ArrayAccessMutator,pos++,+,4,1.4297428E-4,buffer[<mask>],"               // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
          "
942,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,488,19210,19215,IdentifierMutator-Variable,buffer,byte,2,0.0029300281,<mask>," encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];<mask>[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
       "
943,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,488,19210,19215,IdentifierMutator-Variable,buffer,Buffer,3,0.0017636112,<mask>," encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];<mask>[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
       "
944,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,488,19210,19215,IdentifierMutator-Variable,buffer,byte,4,0.0016083259,<mask>," encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];<mask>[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
       "
945,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,488,19210,19215,FieldReferenceMutator,buffer,byte,2,0.0029300281,<mask>," encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];<mask>[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
       "
946,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,488,19210,19215,FieldReferenceMutator,buffer,Buffer,3,0.0017636112,<mask>," encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];<mask>[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
       "
947,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,488,19210,19215,FieldReferenceMutator,buffer,byte,4,0.0016083259,<mask>," encodeTable[(x << 4) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];<mask>[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
       "
948,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,488,19220,19221,UnaryOperatorMutator,++,+,2,1.1587008E-4,pos<mask>,"              // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos<mask>] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
          "
949,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,488,19220,19221,UnaryOperatorMutator,++,++;,3,5.3191947E-5,pos<mask>,"              // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos<mask>] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
          "
950,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,488,19220,19221,UnaryOperatorMutator,++,--,4,1.5739111E-5,pos<mask>,"              // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos<mask>] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
          "
951,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,488,19217,19219,IdentifierMutator-Variable,pos,len,2,2.567302E-5,<mask>,"               // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
         "
952,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,488,19217,19219,IdentifierMutator-Variable,pos,neg,3,2.4802452E-5,<mask>,"               // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
         "
953,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,488,19217,19219,IdentifierMutator-Variable,pos,size,4,2.0665399E-5,<mask>,"               // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
         "
954,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,488,19217,19219,FieldReferenceMutator,pos,len,2,2.567302E-5,<mask>,"               // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
         "
955,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,488,19217,19219,FieldReferenceMutator,pos,neg,3,2.4802452E-5,<mask>,"               // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
         "
956,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,488,19217,19219,FieldReferenceMutator,pos,size,4,2.0665399E-5,<mask>,"               // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
         "
957,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,488,19238,19258,ArrayAccessMutator,(x>>4)&org.apache.commons.codec.binary.Base64.MASK_6BITS,x,0,0.76009697,encodeTable[<mask>],"        // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0,"
958,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,488,19238,19258,ArrayAccessMutator,(x>>4)&org.apache.commons.codec.binary.Base64.MASK_6BITS,1,1,0.026352694,encodeTable[<mask>],"        // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0,"
959,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,488,19238,19258,ArrayAccessMutator,(x>>4)&org.apache.commons.codec.binary.Base64.MASK_6BITS,0,2,0.024082247,encodeTable[<mask>],"        // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0,"
960,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,488,19238,19258,ArrayAccessMutator,(x>>4)&org.apache.commons.codec.binary.Base64.MASK_6BITS,2,3,0.01902234,encodeTable[<mask>],"        // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0,"
961,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,488,19238,19258,ArrayAccessMutator,(x>>4)&org.apache.commons.codec.binary.Base64.MASK_6BITS,xx,4,0.011275223,encodeTable[<mask>],"        // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0,"
962,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,488,19226,19236,IdentifierMutator-Variable,encodeTable,encode,0,0.24245185,<mask>,"           // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
              "
963,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,488,19226,19236,IdentifierMutator-Variable,encodeTable,table,1,0.2208678,<mask>,"           // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
              "
964,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,488,19226,19236,IdentifierMutator-Variable,encodeTable,decode,2,0.08833705,<mask>,"           // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
              "
965,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,488,19226,19236,IdentifierMutator-Variable,encodeTable,buffer,3,0.07402167,<mask>,"           // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
              "
966,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,488,19226,19236,IdentifierMutator-Variable,encodeTable,encoded,4,0.027084071,<mask>,"           // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
              "
967,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,488,19226,19236,FieldReferenceMutator,encodeTable,encode,0,0.24245185,<mask>,"           // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
              "
968,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,488,19226,19236,FieldReferenceMutator,encodeTable,table,1,0.2208678,<mask>,"           // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
              "
969,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,488,19226,19236,FieldReferenceMutator,encodeTable,decode,2,0.08833705,<mask>,"           // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
              "
970,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,488,19226,19236,FieldReferenceMutator,encodeTable,buffer,3,0.07402167,<mask>,"           // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
              "
971,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,488,19226,19236,FieldReferenceMutator,encodeTable,encoded,4,0.027084071,<mask>,"           // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
              "
972,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,488,19246,19248,BinaryOperatorMutator,&,|,2,8.0903503E-4,(x >> 4) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS,"   // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4)<mask>MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(line"
973,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,488,19246,19248,BinaryOperatorMutator,&,^,3,7.6121454E-5,(x >> 4) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS,"   // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4)<mask>MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(line"
974,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,488,19246,19248,BinaryOperatorMutator,&,~,4,2.5047766E-5,(x >> 4) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS,"   // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4)<mask>MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(line"
975,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,488,19240,19243,BinaryOperatorMutator,>>,<<,0,0.3391889,x <mask> 4,"      // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x<mask>4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.array"
976,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,488,19240,19243,BinaryOperatorMutator,>>,<<,1,0.33032012,x <mask> 4,"      // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x<mask>4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.array"
977,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,488,19240,19243,BinaryOperatorMutator,>>,>>>,4,0.042499438,x <mask> 4,"      // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x<mask>4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.array"
978,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,488,19239,19239,IdentifierMutator-Variable,x,y,1,3.4249806E-5,<mask>,"       // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System."
979,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,488,19239,19239,IdentifierMutator-Variable,x,xx,2,2.1085285E-5,<mask>,"       // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System."
980,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,488,19239,19239,IdentifierMutator-Variable,x,wx,4,8.698228E-6,<mask>,"       // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System."
981,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,488,19239,19239,FieldReferenceMutator,x,y,1,3.4249806E-5,<mask>,"       // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System."
982,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,488,19239,19239,FieldReferenceMutator,x,xx,2,2.1085285E-5,<mask>,"       // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System."
983,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,488,19239,19239,FieldReferenceMutator,x,wx,4,8.698228E-6,<mask>,"       // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System."
984,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,488,19244,19244,IdentifierMutator-Literal,4,6,0,0.2945813,<mask>,"     // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy"
985,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,488,19244,19244,IdentifierMutator-Literal,4,5,2,0.109946884,<mask>,"     // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy"
986,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,488,19244,19244,IdentifierMutator-Literal,4,7,3,0.09871699,<mask>,"     // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy"
987,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,488,19244,19244,IdentifierMutator-Literal,4,3,4,0.08316801,<mask>,"     // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy"
988,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,488,19249,19258,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,3,0,0.16688965,<mask>,"  // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) &<mask>];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0,"
989,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,488,19249,19258,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,7,1,0.15878484,<mask>,"  // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) &<mask>];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0,"
990,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,488,19249,19258,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,1,2,0.0921082,<mask>,"  // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) &<mask>];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0,"
991,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,488,19249,19258,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,4,3,0.063080065,<mask>,"  // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) &<mask>];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0,"
992,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,488,19249,19258,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,2,4,0.04418742,<mask>,"  // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) &<mask>];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0,"
993,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,488,19249,19258,FieldReferenceMutator,MASK_6BITS,3,0,0.16688965,org.apache.commons.codec.binary.Base64.<mask>,"  // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) &<mask>];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0,"
994,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,488,19249,19258,FieldReferenceMutator,MASK_6BITS,7,1,0.15878484,org.apache.commons.codec.binary.Base64.<mask>,"  // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) &<mask>];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0,"
995,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,488,19249,19258,FieldReferenceMutator,MASK_6BITS,1,2,0.0921082,org.apache.commons.codec.binary.Base64.<mask>,"  // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) &<mask>];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0,"
996,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,488,19249,19258,FieldReferenceMutator,MASK_6BITS,4,3,0.063080065,org.apache.commons.codec.binary.Base64.<mask>,"  // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) &<mask>];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0,"
997,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,488,19249,19258,FieldReferenceMutator,MASK_6BITS,2,4,0.04418742,org.apache.commons.codec.binary.Base64.<mask>,"  // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) &<mask>];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0,"
998,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,489,19295,19295,AssignmentMutator,buffer[pos++]=encodeTable[(x<<2)&org.apache.commons.codec.binary.Base64.MASK_6BITS],|,0,0.7402295,buffer[pos++] <mask>= encodeTable[(x << 2) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
              "
999,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,489,19295,19295,AssignmentMutator,buffer[pos++]=encodeTable[(x<<2)&org.apache.commons.codec.binary.Base64.MASK_6BITS],^,1,0.15739428,buffer[pos++] <mask>= encodeTable[(x << 2) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
              "
1000,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,489,19295,19295,AssignmentMutator,buffer[pos++]=encodeTable[(x<<2)&org.apache.commons.codec.binary.Base64.MASK_6BITS],*,2,0.045090687,buffer[pos++] <mask>= encodeTable[(x << 2) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
              "
1001,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,489,19295,19295,AssignmentMutator,buffer[pos++]=encodeTable[(x<<2)&org.apache.commons.codec.binary.Base64.MASK_6BITS],&,3,0.010330504,buffer[pos++] <mask>= encodeTable[(x << 2) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
              "
1002,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,489,19295,19295,AssignmentMutator,buffer[pos++]=encodeTable[(x<<2)&org.apache.commons.codec.binary.Base64.MASK_6BITS],||,4,0.008814114,buffer[pos++] <mask>= encodeTable[(x << 2) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
              "
1003,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,489,19289,19293,ArrayAccessMutator,pos++,pos,0,0.9864862,buffer[<mask>],"       if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
             "
1004,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,489,19289,19293,ArrayAccessMutator,pos++,++,1,0.0037266272,buffer[<mask>],"       if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
             "
1005,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,489,19289,19293,ArrayAccessMutator,pos++,push,2,8.595456E-4,buffer[<mask>],"       if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
             "
1006,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,489,19289,19293,ArrayAccessMutator,pos++,size,3,4.756963E-4,buffer[<mask>],"       if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
             "
1007,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,489,19289,19293,ArrayAccessMutator,pos++,+,4,4.3693662E-4,buffer[<mask>],"       if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
             "
1008,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,489,19282,19287,IdentifierMutator-Variable,buffer,Buffer,2,0.0012239766,<mask>,"ips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];<mask>[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
          "
1009,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,489,19282,19287,IdentifierMutator-Variable,buffer,byte,3,0.0011830932,<mask>,"ips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];<mask>[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
          "
1010,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,489,19282,19287,IdentifierMutator-Variable,buffer,byte,4,0.0011270125,<mask>,"ips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];<mask>[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
          "
1011,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,489,19282,19287,FieldReferenceMutator,buffer,Buffer,2,0.0012239766,<mask>,"ips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];<mask>[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
          "
1012,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,489,19282,19287,FieldReferenceMutator,buffer,byte,3,0.0011830932,<mask>,"ips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];<mask>[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
          "
1013,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,489,19282,19287,FieldReferenceMutator,buffer,byte,4,0.0011270125,<mask>,"ips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];<mask>[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
          "
1014,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,489,19292,19293,UnaryOperatorMutator,++,+,2,1.195389E-4,pos<mask>,"      if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos<mask>] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
             "
1015,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,489,19292,19293,UnaryOperatorMutator,++,++;,3,7.291847E-5,pos<mask>,"      if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos<mask>] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
             "
1016,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,489,19292,19293,UnaryOperatorMutator,++,--,4,2.4648376E-5,pos<mask>,"      if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos<mask>] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
             "
1017,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,489,19289,19291,IdentifierMutator-Variable,pos,len,1,6.592597E-5,<mask>,"       if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
            "
1018,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,489,19289,19291,IdentifierMutator-Variable,pos,size,3,5.018656E-5,<mask>,"       if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
            "
1019,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,489,19289,19291,IdentifierMutator-Variable,pos,neg,4,4.5159315E-5,<mask>,"       if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
            "
1020,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,489,19289,19291,FieldReferenceMutator,pos,len,1,6.592597E-5,<mask>,"       if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
            "
1021,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,489,19289,19291,FieldReferenceMutator,pos,size,3,5.018656E-5,<mask>,"       if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
            "
1022,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,489,19289,19291,FieldReferenceMutator,pos,neg,4,4.5159315E-5,<mask>,"       if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
            "
1023,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,489,19310,19330,ArrayAccessMutator,(x<<2)&org.apache.commons.codec.binary.Base64.MASK_6BITS,x,0,0.32501307,encodeTable[<mask>]," (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
     "
1024,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,489,19310,19330,ArrayAccessMutator,(x<<2)&org.apache.commons.codec.binary.Base64.MASK_6BITS,0,1,0.08488165,encodeTable[<mask>]," (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
     "
1025,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,489,19310,19330,ArrayAccessMutator,(x<<2)&org.apache.commons.codec.binary.Base64.MASK_6BITS,1,2,0.07098488,encodeTable[<mask>]," (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
     "
1026,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,489,19310,19330,ArrayAccessMutator,(x<<2)&org.apache.commons.codec.binary.Base64.MASK_6BITS,pos,3,0.049747486,encodeTable[<mask>]," (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
     "
1027,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,489,19310,19330,ArrayAccessMutator,(x<<2)&org.apache.commons.codec.binary.Base64.MASK_6BITS,2,4,0.038435612,encodeTable[<mask>]," (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
     "
1028,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,489,19298,19308,IdentifierMutator-Variable,encodeTable,buffer,0,0.2287151,<mask>,"   if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos +="
1029,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,489,19298,19308,IdentifierMutator-Variable,encodeTable,padding,1,0.09239903,<mask>,"   if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos +="
1030,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,489,19298,19308,IdentifierMutator-Variable,encodeTable,encode,2,0.06309052,<mask>,"   if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos +="
1031,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,489,19298,19308,IdentifierMutator-Variable,encodeTable,table,3,0.036829483,<mask>,"   if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos +="
1032,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,489,19298,19308,IdentifierMutator-Variable,encodeTable,encoded,4,0.03361492,<mask>,"   if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos +="
1033,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,489,19298,19308,FieldReferenceMutator,encodeTable,buffer,0,0.2287151,<mask>,"   if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos +="
1034,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,489,19298,19308,FieldReferenceMutator,encodeTable,padding,1,0.09239903,<mask>,"   if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos +="
1035,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,489,19298,19308,FieldReferenceMutator,encodeTable,encode,2,0.06309052,<mask>,"   if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos +="
1036,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,489,19298,19308,FieldReferenceMutator,encodeTable,table,3,0.036829483,<mask>,"   if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos +="
1037,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,489,19298,19308,FieldReferenceMutator,encodeTable,encoded,4,0.03361492,<mask>,"   if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos +="
1038,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,489,19318,19320,BinaryOperatorMutator,&,|,2,0.006319396,(x << 2) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS," STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2)<mask>MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;"
1039,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,489,19318,19320,BinaryOperatorMutator,&,|,3,3.0868832E-4,(x << 2) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS," STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2)<mask>MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;"
1040,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,489,19318,19320,BinaryOperatorMutator,&,^,4,2.2057975E-4,(x << 2) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS," STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2)<mask>MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;"
1041,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,489,19312,19315,BinaryOperatorMutator,<<,>>,0,0.42384383,x <mask> 2,"codeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x<mask>2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator"
1042,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,489,19312,19315,BinaryOperatorMutator,<<,>>,1,0.2099288,x <mask> 2,"codeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x<mask>2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator"
1043,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,489,19312,19315,BinaryOperatorMutator,<<,-,3,0.03422512,x <mask> 2,"codeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x<mask>2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator"
1044,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,489,19311,19311,IdentifierMutator-Variable,x,y,1,1.0864724E-4,<mask>,"encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSepar"
1045,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,489,19311,19311,IdentifierMutator-Variable,x,xx,2,7.922586E-5,<mask>,"encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSepar"
1046,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,489,19311,19311,IdentifierMutator-Variable,x,1,4,2.2680024E-5,<mask>,"encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSepar"
1047,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,489,19311,19311,FieldReferenceMutator,x,y,1,1.0864724E-4,<mask>,"encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSepar"
1048,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,489,19311,19311,FieldReferenceMutator,x,xx,2,7.922586E-5,<mask>,"encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSepar"
1049,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,489,19311,19311,FieldReferenceMutator,x,1,4,2.2680024E-5,<mask>,"encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSepar"
1050,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,489,19316,19316,IdentifierMutator-Literal,2,3,1,0.18994637,<mask>,"Table == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x <<<mask>) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator."
1051,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,489,19316,19316,IdentifierMutator-Literal,2,1,2,0.0896128,<mask>,"Table == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x <<<mask>) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator."
1052,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,489,19316,19316,IdentifierMutator-Literal,2,6,3,0.037396092,<mask>,"Table == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x <<<mask>) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator."
1053,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,489,19316,19316,IdentifierMutator-Literal,2,0,4,0.036962956,<mask>,"Table == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x <<<mask>) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator."
1054,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,489,19321,19330,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,mask,0,0.23547813,<mask>,"ARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) &<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
     "
1055,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,489,19321,19330,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,1,1,0.19351144,<mask>,"ARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) &<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
     "
1056,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,489,19321,19330,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,7,2,0.09690851,<mask>,"ARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) &<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
     "
1057,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,489,19321,19330,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,3,3,0.059470437,<mask>,"ARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) &<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
     "
1058,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,489,19321,19330,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,255,4,0.050094225,<mask>,"ARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) &<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
     "
1059,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,489,19321,19330,FieldReferenceMutator,MASK_6BITS,mask,0,0.23547813,org.apache.commons.codec.binary.Base64.<mask>,"ARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) &<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
     "
1060,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,489,19321,19330,FieldReferenceMutator,MASK_6BITS,1,1,0.19351144,org.apache.commons.codec.binary.Base64.<mask>,"ARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) &<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
     "
1061,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,489,19321,19330,FieldReferenceMutator,MASK_6BITS,7,2,0.09690851,org.apache.commons.codec.binary.Base64.<mask>,"ARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) &<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
     "
1062,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,489,19321,19330,FieldReferenceMutator,MASK_6BITS,3,3,0.059470437,org.apache.commons.codec.binary.Base64.<mask>,"ARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) &<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
     "
1063,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,489,19321,19330,FieldReferenceMutator,MASK_6BITS,255,4,0.050094225,org.apache.commons.codec.binary.Base64.<mask>,"ARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                        buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) &<mask>];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
     "
1064,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,491,19443,19446,BinaryOperatorMutator,==,!=,2,0.095014386,encodeTable <mask> org.apache.commons.codec.binary.Base64.STANDARD_ENCODE_TABLE,"[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable<mask>STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
             "
1065,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,491,19443,19446,BinaryOperatorMutator,==,===,3,0.016412526,encodeTable <mask> org.apache.commons.codec.binary.Base64.STANDARD_ENCODE_TABLE,"[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable<mask>STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
             "
1066,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,491,19443,19446,BinaryOperatorMutator,==,_,4,0.014559802,encodeTable <mask> org.apache.commons.codec.binary.Base64.STANDARD_ENCODE_TABLE,"[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable<mask>STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
             "
1067,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,491,19432,19442,IdentifierMutator-Variable,encodeTable,x,0,0.15962929,<mask>,"   buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (<mask> == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
             "
1068,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,491,19432,19442,IdentifierMutator-Variable,encodeTable,type,1,0.15209433,<mask>,"   buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (<mask> == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
             "
1069,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,491,19432,19442,IdentifierMutator-Variable,encodeTable,mode,2,0.07210477,<mask>,"   buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (<mask> == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
             "
1070,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,491,19432,19442,IdentifierMutator-Variable,encodeTable,format,3,0.028690048,<mask>,"   buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (<mask> == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
             "
1071,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,491,19432,19442,IdentifierMutator-Variable,encodeTable,b,4,0.020672118,<mask>,"   buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (<mask> == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
             "
1072,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,491,19432,19442,FieldReferenceMutator,encodeTable,x,0,0.15962929,<mask>,"   buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (<mask> == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
             "
1073,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,491,19432,19442,FieldReferenceMutator,encodeTable,type,1,0.15209433,<mask>,"   buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (<mask> == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
             "
1074,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,491,19432,19442,FieldReferenceMutator,encodeTable,mode,2,0.07210477,<mask>,"   buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (<mask> == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
             "
1075,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,491,19432,19442,FieldReferenceMutator,encodeTable,format,3,0.028690048,<mask>,"   buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (<mask> == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
             "
1076,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,491,19432,19442,FieldReferenceMutator,encodeTable,b,4,0.020672118,<mask>,"   buffer[pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (<mask> == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
             "
1077,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,491,19447,19467,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.STANDARD_ENCODE_TABLE,null,0,0.4124047,<mask>,"pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable ==<mask>) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null ||"
1078,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,491,19447,19467,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.STANDARD_ENCODE_TABLE,1,1,0.11573551,<mask>,"pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable ==<mask>) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null ||"
1079,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,491,19447,19467,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.STANDARD_ENCODE_TABLE,0,2,0.09438745,<mask>,"pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable ==<mask>) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null ||"
1080,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,491,19447,19467,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.STANDARD_ENCODE_TABLE,2,3,0.081205286,<mask>,"pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable ==<mask>) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null ||"
1081,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,491,19447,19467,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.STANDARD_ENCODE_TABLE,3,4,0.0308826,<mask>,"pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable ==<mask>) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null ||"
1082,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,491,19447,19467,FieldReferenceMutator,STANDARD_ENCODE_TABLE,null,0,0.4124047,org.apache.commons.codec.binary.Base64.<mask>,"pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable ==<mask>) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null ||"
1083,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,491,19447,19467,FieldReferenceMutator,STANDARD_ENCODE_TABLE,1,1,0.11573551,org.apache.commons.codec.binary.Base64.<mask>,"pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable ==<mask>) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null ||"
1084,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,491,19447,19467,FieldReferenceMutator,STANDARD_ENCODE_TABLE,0,2,0.09438745,org.apache.commons.codec.binary.Base64.<mask>,"pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable ==<mask>) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null ||"
1085,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,491,19447,19467,FieldReferenceMutator,STANDARD_ENCODE_TABLE,2,3,0.081205286,org.apache.commons.codec.binary.Base64.<mask>,"pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable ==<mask>) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null ||"
1086,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,491,19447,19467,FieldReferenceMutator,STANDARD_ENCODE_TABLE,3,4,0.0308826,org.apache.commons.codec.binary.Base64.<mask>,"pos++] = PAD;
                    }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable ==<mask>) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null ||"
1087,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,492,19509,19509,AssignmentMutator,buffer[pos++]=org.apache.commons.codec.binary.Base64.PAD,|,0,0.74714583,buffer[pos++] <mask>= org.apache.commons.codec.binary.Base64.PAD,"           break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++]<mask>= PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resize"
1088,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,492,19509,19509,AssignmentMutator,buffer[pos++]=org.apache.commons.codec.binary.Base64.PAD,^,1,0.14103618,buffer[pos++] <mask>= org.apache.commons.codec.binary.Base64.PAD,"           break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++]<mask>= PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resize"
1089,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,492,19509,19509,AssignmentMutator,buffer[pos++]=org.apache.commons.codec.binary.Base64.PAD,*,2,0.08161489,buffer[pos++] <mask>= org.apache.commons.codec.binary.Base64.PAD,"           break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++]<mask>= PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resize"
1090,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,492,19509,19509,AssignmentMutator,buffer[pos++]=org.apache.commons.codec.binary.Base64.PAD,&,3,0.01056231,buffer[pos++] <mask>= org.apache.commons.codec.binary.Base64.PAD,"           break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++]<mask>= PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resize"
1091,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,492,19509,19509,AssignmentMutator,buffer[pos++]=org.apache.commons.codec.binary.Base64.PAD,<<,4,0.0064846696,buffer[pos++] <mask>= org.apache.commons.codec.binary.Base64.PAD,"           break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++]<mask>= PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resize"
1092,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,492,19503,19507,ArrayAccessMutator,pos++,pos,0,0.99443924,buffer[<mask>],"              break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                   "
1093,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,492,19503,19507,ArrayAccessMutator,pos++,++,1,5.0441327E-4,buffer[<mask>],"              break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                   "
1094,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,492,19503,19507,ArrayAccessMutator,pos++,len,2,3.9711234E-4,buffer[<mask>],"              break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                   "
1095,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,492,19503,19507,ArrayAccessMutator,pos++,offset,3,3.7979882E-4,buffer[<mask>],"              break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                   "
1096,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,492,19503,19507,ArrayAccessMutator,pos++,size,4,3.337856E-4,buffer[<mask>],"              break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                   "
1097,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,492,19496,19501,IdentifierMutator-Variable,buffer,buf,2,5.310403E-4,<mask>,"                   }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {<mask>[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                "
1098,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,492,19496,19501,IdentifierMutator-Variable,buffer,pad,3,4.2705913E-4,<mask>,"                   }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {<mask>[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                "
1099,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,492,19496,19501,IdentifierMutator-Variable,buffer,padding,4,2.9652216E-4,<mask>,"                   }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {<mask>[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                "
1100,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,492,19496,19501,FieldReferenceMutator,buffer,buf,2,5.310403E-4,<mask>,"                   }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {<mask>[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                "
1101,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,492,19496,19501,FieldReferenceMutator,buffer,pad,3,4.2705913E-4,<mask>,"                   }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {<mask>[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                "
1102,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,492,19496,19501,FieldReferenceMutator,buffer,padding,4,2.9652216E-4,<mask>,"                   }
                    break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {<mask>[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                "
1103,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,492,19506,19507,UnaryOperatorMutator,++,++;,2,6.1777784E-5,pos<mask>,"             break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos<mask>] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                   "
1104,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,492,19506,19507,UnaryOperatorMutator,++,+,3,5.112599E-5,pos<mask>,"             break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos<mask>] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                   "
1105,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,492,19506,19507,UnaryOperatorMutator,++,--,4,1.7274688E-5,pos<mask>,"             break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos<mask>] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                   "
1106,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,492,19503,19505,IdentifierMutator-Variable,pos,len,1,1.6041941E-4,<mask>,"              break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                  "
1107,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,492,19503,19505,IdentifierMutator-Variable,pos,size,2,1.3862847E-4,<mask>,"              break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                  "
1108,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,492,19503,19505,IdentifierMutator-Variable,pos,offset,4,5.0819417E-5,<mask>,"              break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                  "
1109,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,492,19503,19505,FieldReferenceMutator,pos,len,1,1.6041941E-4,<mask>,"              break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                  "
1110,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,492,19503,19505,FieldReferenceMutator,pos,size,2,1.3862847E-4,<mask>,"              break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                  "
1111,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,492,19503,19505,FieldReferenceMutator,pos,offset,4,5.0819417E-5,<mask>,"              break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[<mask>++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                  "
1112,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,492,19512,19514,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,x,0,0.55746853,<mask>,"          break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] =<mask>;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
"
1113,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,492,19512,19514,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,0,1,0.168952,<mask>,"          break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] =<mask>;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
"
1114,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,492,19512,19514,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,"''",2,0.042754926,<mask>,"          break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] =<mask>;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
"
1115,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,492,19512,19514,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,"""""",3,0.03778507,<mask>,"          break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] =<mask>;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
"
1116,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,492,19512,19514,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,null,4,0.033318948,<mask>,"          break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] =<mask>;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
"
1117,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,492,19512,19514,FieldReferenceMutator,PAD,x,0,0.55746853,org.apache.commons.codec.binary.Base64.<mask>,"          break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] =<mask>;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
"
1118,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,492,19512,19514,FieldReferenceMutator,PAD,0,1,0.168952,org.apache.commons.codec.binary.Base64.<mask>,"          break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] =<mask>;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
"
1119,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,492,19512,19514,FieldReferenceMutator,PAD,"''",2,0.042754926,org.apache.commons.codec.binary.Base64.<mask>,"          break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] =<mask>;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
"
1120,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,492,19512,19514,FieldReferenceMutator,PAD,"""""",3,0.03778507,org.apache.commons.codec.binary.Base64.<mask>,"          break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] =<mask>;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
"
1121,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,492,19512,19514,FieldReferenceMutator,PAD,null,4,0.033318948,org.apache.commons.codec.binary.Base64.<mask>,"          break;

                case 2 :
                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] =<mask>;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
"
1122,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,496,19610,19613,BinaryOperatorMutator,&&,||,2,0.047093447,(lineLength > 0) <mask> (pos > 0),"                buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0<mask>pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
       "
1123,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,496,19610,19613,BinaryOperatorMutator,&&,|,3,0.023211166,(lineLength > 0) <mask> (pos > 0),"                buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0<mask>pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
       "
1124,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,496,19610,19613,BinaryOperatorMutator,&&,+,4,0.02307327,(lineLength > 0) <mask> (pos > 0),"                buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0<mask>pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
       "
1125,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,496,19606,19608,BinaryOperatorMutator,>,==,2,0.23655224,lineLength <mask> 0,"                  buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength<mask>0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
     "
1126,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,496,19606,19608,BinaryOperatorMutator,>,==,3,0.03507341,lineLength <mask> 0,"                  buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength<mask>0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
     "
1127,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,496,19606,19608,BinaryOperatorMutator,>,!=,4,0.011662802,lineLength <mask> 0,"                  buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength<mask>0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
     "
1128,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,496,19596,19605,IdentifierMutator-Variable,lineLength,buffer,0,0.80018413,<mask>,"                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (<mask> > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
    "
1129,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,496,19596,19605,IdentifierMutator-Variable,lineLength,length,1,0.038591832,<mask>,"                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (<mask> > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
    "
1130,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,496,19596,19605,IdentifierMutator-Variable,lineLength,pos,2,0.012767276,<mask>,"                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (<mask> > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
    "
1131,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,496,19596,19605,IdentifierMutator-Variable,lineLength,size,3,0.010971412,<mask>,"                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (<mask> > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
    "
1132,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,496,19596,19605,IdentifierMutator-Variable,lineLength,offset,4,0.010061023,<mask>,"                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (<mask> > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
    "
1133,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,496,19596,19605,FieldReferenceMutator,lineLength,buffer,0,0.80018413,<mask>,"                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (<mask> > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
    "
1134,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,496,19596,19605,FieldReferenceMutator,lineLength,length,1,0.038591832,<mask>,"                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (<mask> > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
    "
1135,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,496,19596,19605,FieldReferenceMutator,lineLength,pos,2,0.012767276,<mask>,"                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (<mask> > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
    "
1136,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,496,19596,19605,FieldReferenceMutator,lineLength,size,3,0.010971412,<mask>,"                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (<mask> > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
    "
1137,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,496,19596,19605,FieldReferenceMutator,lineLength,offset,4,0.010061023,<mask>,"                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (<mask> > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
    "
1138,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,496,19609,19609,IdentifierMutator-Literal,0,1,1,0.059038393,<mask>,"                 buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength ><mask> && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
      "
1139,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,496,19609,19609,IdentifierMutator-Literal,0,2,2,0.0053756633,<mask>,"                 buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength ><mask> && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
      "
1140,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,496,19609,19609,IdentifierMutator-Literal,0,3,3,0.001344272,<mask>,"                 buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength ><mask> && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
      "
1141,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,496,19609,19609,IdentifierMutator-Literal,0,4,4,0.0011896865,<mask>,"                 buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength ><mask> && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
      "
1142,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,496,19617,19619,BinaryOperatorMutator,>,==,1,0.17634995,pos <mask> 0,"              buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos<mask>0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
         "
1143,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,496,19617,19619,BinaryOperatorMutator,>,==,3,0.050473865,pos <mask> 0,"              buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos<mask>0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
         "
1144,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,496,19617,19619,BinaryOperatorMutator,>,>=,4,0.043412216,pos <mask> 0,"              buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos<mask>0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
         "
1145,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,496,19614,19616,IdentifierMutator-Variable,pos,offset,1,0.015939124,<mask>,"               buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 &&<mask> > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
        "
1146,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,496,19614,19616,IdentifierMutator-Variable,pos,position,2,0.014173968,<mask>,"               buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 &&<mask> > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
        "
1147,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,496,19614,19616,IdentifierMutator-Variable,pos,index,3,0.0041875197,<mask>,"               buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 &&<mask> > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
        "
1148,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,496,19614,19616,IdentifierMutator-Variable,pos,length,4,0.0037898691,<mask>,"               buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 &&<mask> > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
        "
1149,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,496,19614,19616,FieldReferenceMutator,pos,offset,1,0.015939124,<mask>,"               buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 &&<mask> > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
        "
1150,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,496,19614,19616,FieldReferenceMutator,pos,position,2,0.014173968,<mask>,"               buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 &&<mask> > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
        "
1151,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,496,19614,19616,FieldReferenceMutator,pos,index,3,0.0041875197,<mask>,"               buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 &&<mask> > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
        "
1152,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,496,19614,19616,FieldReferenceMutator,pos,length,4,0.0037898691,<mask>,"               buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 &&<mask> > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
        "
1153,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,496,19620,19620,IdentifierMutator-Literal,0,start,1,0.009996922,<mask>,"             buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos ><mask>) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
          "
1154,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,496,19620,19620,IdentifierMutator-Literal,0,limit,2,0.0070491247,<mask>,"             buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos ><mask>) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
          "
1155,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,496,19620,19620,IdentifierMutator-Literal,0,pos,3,0.0058853226,<mask>,"             buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos ><mask>) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
          "
1156,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,496,19620,19620,IdentifierMutator-Literal,0,1,4,0.0048765177,<mask>,"             buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos ><mask>) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
          "
1157,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,497,19648,19656,MethodCallMutator,arraycopy,printf,0,0.4575249,"System.<mask>(lineSeparator, 0, buffer, pos, lineSeparator.length)","(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.<mask>(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
         "
1158,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,497,19648,19656,MethodCallMutator,arraycopy,copy,1,0.31570378,"System.<mask>(lineSeparator, 0, buffer, pos, lineSeparator.length)","(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.<mask>(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
         "
1159,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,497,19648,19656,MethodCallMutator,arraycopy,format,2,0.052819908,"System.<mask>(lineSeparator, 0, buffer, pos, lineSeparator.length)","(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.<mask>(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
         "
1160,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,497,19648,19656,MethodCallMutator,arraycopy,write,3,0.05220404,"System.<mask>(lineSeparator, 0, buffer, pos, lineSeparator.length)","(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.<mask>(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
         "
1161,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,497,19648,19656,MethodCallMutator,arraycopy,replace,4,0.011798085,"System.<mask>(lineSeparator, 0, buffer, pos, lineSeparator.length)","(x >> 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.<mask>(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
         "
1162,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,497,19658,19670,IdentifierMutator-Variable,lineSeparator,in,0,0.41719532,<mask>," 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(<mask>, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
              "
1163,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,497,19658,19670,IdentifierMutator-Variable,lineSeparator,buffer,1,0.3444904,<mask>," 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(<mask>, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
              "
1164,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,497,19658,19670,IdentifierMutator-Variable,lineSeparator,line,2,0.079513244,<mask>," 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(<mask>, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
              "
1165,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,497,19658,19670,IdentifierMutator-Variable,lineSeparator,lines,3,0.06415421,<mask>," 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(<mask>, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
              "
1166,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,497,19658,19670,IdentifierMutator-Variable,lineSeparator,out,4,0.00818442,<mask>," 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(<mask>, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
              "
1167,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,497,19658,19670,FieldReferenceMutator,lineSeparator,in,0,0.41719532,<mask>," 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(<mask>, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
              "
1168,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,497,19658,19670,FieldReferenceMutator,lineSeparator,buffer,1,0.3444904,<mask>," 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(<mask>, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
              "
1169,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,497,19658,19670,FieldReferenceMutator,lineSeparator,line,2,0.079513244,<mask>," 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(<mask>, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
              "
1170,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,497,19658,19670,FieldReferenceMutator,lineSeparator,lines,3,0.06415421,<mask>," 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(<mask>, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
              "
1171,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,497,19658,19670,FieldReferenceMutator,lineSeparator,out,4,0.00818442,<mask>," 4) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(<mask>, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
              "
1172,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,497,19673,19673,IdentifierMutator-Literal,0,1,2,0.0018115321,<mask>,"_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator,<mask>, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                "
1173,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,497,19673,19673,IdentifierMutator-Literal,0,pos,3,5.1056716E-4,<mask>,"_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator,<mask>, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                "
1174,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,497,19673,19673,IdentifierMutator-Literal,0,offset,4,3.5733078E-4,<mask>,"_6BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator,<mask>, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                "
1175,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,497,19676,19681,IdentifierMutator-Variable,buffer,in,1,0.0059449216,<mask>,"BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0,<mask>, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                  "
1176,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,497,19676,19681,IdentifierMutator-Variable,buffer,buf,2,0.0011486965,<mask>,"BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0,<mask>, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                  "
1177,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,497,19676,19681,IdentifierMutator-Variable,buffer,line,3,0.0011190659,<mask>,"BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0,<mask>, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                  "
1178,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,497,19676,19681,IdentifierMutator-Variable,buffer,out,4,0.0010440564,<mask>,"BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0,<mask>, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                  "
1179,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,497,19676,19681,FieldReferenceMutator,buffer,in,1,0.0059449216,<mask>,"BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0,<mask>, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                  "
1180,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,497,19676,19681,FieldReferenceMutator,buffer,buf,2,0.0011486965,<mask>,"BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0,<mask>, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                  "
1181,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,497,19676,19681,FieldReferenceMutator,buffer,line,3,0.0011190659,<mask>,"BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0,<mask>, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                  "
1182,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,497,19676,19681,FieldReferenceMutator,buffer,out,4,0.0010440564,<mask>,"BITS];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0,<mask>, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                  "
1183,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,497,19684,19686,IdentifierMutator-Variable,pos,0,1,0.011068404,<mask>,"];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer,<mask>, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b"
1184,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,497,19684,19686,IdentifierMutator-Variable,pos,1,3,6.6461036E-4,<mask>,"];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer,<mask>, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b"
1185,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,497,19684,19686,IdentifierMutator-Variable,pos,offset,4,5.925577E-4,<mask>,"];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer,<mask>, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b"
1186,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,497,19684,19686,FieldReferenceMutator,pos,0,1,0.011068404,<mask>,"];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer,<mask>, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b"
1187,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,497,19684,19686,FieldReferenceMutator,pos,1,3,6.6461036E-4,<mask>,"];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer,<mask>, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b"
1188,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,497,19684,19686,FieldReferenceMutator,pos,offset,4,5.925577E-4,<mask>,"];
                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer,<mask>, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b"
1189,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,497,19689,19708,IdentifierMutator-Variable,lineSeparator.length,len,0,0.5981063,<mask>,"                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos,<mask>);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
   "
1190,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,497,19689,19708,IdentifierMutator-Variable,lineSeparator.length,length,1,0.10379741,<mask>,"                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos,<mask>);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
   "
1191,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,497,19689,19708,IdentifierMutator-Variable,lineSeparator.length,n,2,0.07983037,<mask>,"                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos,<mask>);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
   "
1192,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,497,19689,19708,IdentifierMutator-Variable,lineSeparator.length,pos,3,0.036363974,<mask>,"                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos,<mask>);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
   "
1193,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,497,19689,19708,IdentifierMutator-Variable,lineSeparator.length,len,4,0.013404466,<mask>,"                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos,<mask>);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
   "
1194,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,497,19689,19701,IdentifierMutator-Variable,lineSeparator,buffer,0,0.9907803,<mask>,"                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos,<mask>.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
 "
1195,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,497,19689,19701,IdentifierMutator-Variable,lineSeparator,buffer,1,0.004720448,<mask>,"                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos,<mask>.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
 "
1196,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,497,19689,19701,IdentifierMutator-Variable,lineSeparator,line,2,0.0014906409,<mask>,"                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos,<mask>.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
 "
1197,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,497,19689,19701,IdentifierMutator-Variable,lineSeparator,buf,3,3.0753633E-4,<mask>,"                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos,<mask>.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
 "
1198,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,497,19689,19701,IdentifierMutator-Variable,lineSeparator,Buffer,4,2.605978E-4,<mask>,"                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos,<mask>.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
 "
1199,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,497,19689,19701,FieldReferenceMutator,lineSeparator,buffer,0,0.9907803,<mask>,"                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos,<mask>.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
 "
1200,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,497,19689,19701,FieldReferenceMutator,lineSeparator,buffer,1,0.004720448,<mask>,"                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos,<mask>.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
 "
1201,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,497,19689,19701,FieldReferenceMutator,lineSeparator,line,2,0.0014906409,<mask>,"                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos,<mask>.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
 "
1202,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,497,19689,19701,FieldReferenceMutator,lineSeparator,buf,3,3.0753633E-4,<mask>,"                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos,<mask>.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
 "
1203,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,497,19689,19701,FieldReferenceMutator,lineSeparator,Buffer,4,2.605978E-4,<mask>,"                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos,<mask>.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
 "
1204,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,497,19703,19708,FieldReferenceMutator,length,len,1,7.863087E-5,lineSeparator.<mask>,"               buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.<mask>);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
   "
1205,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,497,19703,19708,FieldReferenceMutator,length,position,2,3.2318705E-5,lineSeparator.<mask>,"               buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.<mask>);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
   "
1206,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,497,19703,19708,FieldReferenceMutator,length,count,4,1.1865282E-5,lineSeparator.<mask>,"               buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.<mask>);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
   "
1207,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,498,19731,19731,AssignmentMutator,pos+=lineSeparator.length,++,0,0.8251513,pos <mask>= lineSeparator.length," = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos<mask>+= lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
    "
1208,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,498,19731,19731,AssignmentMutator,pos+=lineSeparator.length,*,1,0.04038883,pos <mask>= lineSeparator.length," = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos<mask>+= lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
    "
1209,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,498,19731,19731,AssignmentMutator,pos+=lineSeparator.length,*,2,0.018502941,pos <mask>= lineSeparator.length," = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos<mask>+= lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
    "
1210,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,498,19731,19731,AssignmentMutator,pos+=lineSeparator.length,//,3,0.017402723,pos <mask>= lineSeparator.length," = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos<mask>+= lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
    "
1211,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,498,19731,19731,AssignmentMutator,pos+=lineSeparator.length,|,4,0.012794839,pos <mask>= lineSeparator.length," = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos<mask>+= lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
    "
1212,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,498,19728,19730,IdentifierMutator-Variable,pos,position,2,4.3460948E-4,<mask>,"             buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);<mask> += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
    "
1213,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,498,19728,19730,IdentifierMutator-Variable,pos,Pos,3,1.5368845E-4,<mask>,"             buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);<mask> += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
    "
1214,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,498,19728,19730,IdentifierMutator-Variable,pos,offset,4,1.2691536E-4,<mask>,"             buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);<mask> += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
    "
1215,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,498,19728,19730,FieldReferenceMutator,pos,position,2,4.3460948E-4,<mask>,"             buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);<mask> += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
    "
1216,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,498,19728,19730,FieldReferenceMutator,pos,Pos,3,1.5368845E-4,<mask>,"             buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);<mask> += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
    "
1217,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,498,19728,19730,FieldReferenceMutator,pos,offset,4,1.2691536E-4,<mask>,"             buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);<mask> += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
    "
1218,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,498,19735,19754,IdentifierMutator-Variable,lineSeparator.length,length,0,0.13518956,<mask>," encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos +=<mask>;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
           "
1219,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,498,19735,19754,IdentifierMutator-Variable,lineSeparator.length,2,1,0.1337497,<mask>," encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos +=<mask>;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
           "
1220,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,498,19735,19754,IdentifierMutator-Variable,lineSeparator.length,1,2,0.11780608,<mask>," encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos +=<mask>;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
           "
1221,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,498,19735,19754,IdentifierMutator-Variable,lineSeparator.length,4,3,0.07759516,<mask>," encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos +=<mask>;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
           "
1222,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,498,19735,19754,IdentifierMutator-Variable,lineSeparator.length,len,4,0.052620254,<mask>," encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos +=<mask>;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
           "
1223,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,498,19735,19747,IdentifierMutator-Variable,lineSeparator,buffer,0,0.9921069,<mask>," encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos +=<mask>.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
         "
1224,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,498,19735,19747,IdentifierMutator-Variable,lineSeparator,line,1,0.0033804025,<mask>," encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos +=<mask>.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
         "
1225,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,498,19735,19747,IdentifierMutator-Variable,lineSeparator,buf,2,5.8461976E-4,<mask>," encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos +=<mask>.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
         "
1226,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,498,19735,19747,IdentifierMutator-Variable,lineSeparator,buffer,3,2.2123357E-4,<mask>," encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos +=<mask>.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
         "
1227,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,498,19735,19747,IdentifierMutator-Variable,lineSeparator,text,4,1.9107935E-4,<mask>," encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos +=<mask>.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
         "
1228,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,498,19735,19747,FieldReferenceMutator,lineSeparator,buffer,0,0.9921069,<mask>," encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos +=<mask>.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
         "
1229,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,498,19735,19747,FieldReferenceMutator,lineSeparator,line,1,0.0033804025,<mask>," encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos +=<mask>.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
         "
1230,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,498,19735,19747,FieldReferenceMutator,lineSeparator,buf,2,5.8461976E-4,<mask>," encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos +=<mask>.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
         "
1231,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,498,19735,19747,FieldReferenceMutator,lineSeparator,buffer,3,2.2123357E-4,<mask>," encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos +=<mask>.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
         "
1232,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,498,19735,19747,FieldReferenceMutator,lineSeparator,text,4,1.9107935E-4,<mask>," encodeTable[(x << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos +=<mask>.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
         "
1233,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,498,19749,19754,FieldReferenceMutator,length,position,1,3.4089544E-4,lineSeparator.<mask>," << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.<mask>;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
           "
1234,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,498,19749,19754,FieldReferenceMutator,length,len,2,1.9360203E-4,lineSeparator.<mask>," << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.<mask>;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
           "
1235,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,498,19749,19754,FieldReferenceMutator,length,width,3,7.743036E-5,lineSeparator.<mask>," << 2) & MASK_6BITS];
                    // URL-SAFE skips the padding to further reduce size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.<mask>;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
           "
1236,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,501,19813,19813,IdentifierMutator-Literal,0,pos,1,0.0058404254,<mask>," size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i =<mask>; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
    "
1237,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,501,19813,19813,IdentifierMutator-Literal,0,1,2,0.0052376254,<mask>," size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i =<mask>; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
    "
1238,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,501,19813,19813,IdentifierMutator-Literal,0,offset,3,0.0019229413,<mask>," size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i =<mask>; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
    "
1239,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,501,19813,19813,IdentifierMutator-Literal,0,start,4,0.001858975,<mask>," size.
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i =<mask>; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
    "
1240,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,501,19817,19819,BinaryOperatorMutator,<,++,2,0.0017309716,i <mask> inAvail,"                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i<mask>inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
       "
1241,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,501,19817,19819,BinaryOperatorMutator,<,<=,3,9.2930626E-4,i <mask> inAvail,"                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i<mask>inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
       "
1242,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,501,19817,19819,BinaryOperatorMutator,<,==,4,8.852311E-4,i <mask> inAvail,"                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i<mask>inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
       "
1243,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,501,19816,19816,IdentifierMutator-Variable,i,I,2,1.2223773E-4,<mask>,"
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0;<mask> < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
      "
1244,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,501,19816,19816,IdentifierMutator-Variable,i,I,3,3.1330077E-5,<mask>,"
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0;<mask> < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
      "
1245,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,501,19816,19816,IdentifierMutator-Variable,i,ii,4,2.9303501E-5,<mask>,"
                    if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0;<mask> < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
      "
1246,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,501,19820,19826,IdentifierMutator-Variable,inAvail,size,0,0.14366975,<mask>,"                   if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i <<mask>; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
          "
1247,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,501,19820,19826,IdentifierMutator-Variable,inAvail,length,1,0.0788649,<mask>,"                   if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i <<mask>; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
          "
1248,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,501,19820,19826,IdentifierMutator-Variable,inAvail,256,2,0.07440925,<mask>,"                   if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i <<mask>; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
          "
1249,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,501,19820,19826,IdentifierMutator-Variable,inAvail,len,3,0.07136424,<mask>,"                   if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i <<mask>; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
          "
1250,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,501,19820,19826,IdentifierMutator-Variable,inAvail,n,4,0.059067473,<mask>,"                   if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i <<mask>; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
          "
1251,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,501,19830,19831,UnaryOperatorMutator,++,++),2,0.0013965091,i<mask>,"              if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i<mask>) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
            "
1252,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,501,19830,19831,UnaryOperatorMutator,++,++;,3,3.3227907E-4,i<mask>,"              if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i<mask>) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
            "
1253,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,501,19830,19831,UnaryOperatorMutator,++,--,4,2.5739544E-4,i<mask>,"              if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i<mask>) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
            "
1254,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,501,19829,19829,IdentifierMutator-Variable,i,I,2,6.9920214E-5,<mask>,"               if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail;<mask>++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
            "
1255,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,501,19829,19829,IdentifierMutator-Variable,i,,3,3.514921E-5,<mask>,"               if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail;<mask>++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
            "
1256,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,501,19829,19829,IdentifierMutator-Variable,i,j,4,2.9864277E-5,<mask>,"               if (encodeTable == STANDARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail;<mask>++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
            "
1257,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,502,19870,19873,BinaryOperatorMutator,||,|,2,0.009690151,(buffer == null) <mask> ((buffer.length - pos) < encodeSize),"ODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null<mask>buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK"
1258,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,502,19870,19873,BinaryOperatorMutator,||,.,3,0.0044482853,(buffer == null) <mask> ((buffer.length - pos) < encodeSize),"ODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null<mask>buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK"
1259,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,502,19870,19873,BinaryOperatorMutator,||,?,4,0.0017501197,(buffer == null) <mask> ((buffer.length - pos) < encodeSize),"ODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null<mask>buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK"
1260,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,502,19862,19865,BinaryOperatorMutator,==,=,2,0.012145824,buffer <mask> null,"_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer<mask>null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) &"
1261,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,502,19862,19865,BinaryOperatorMutator,==,===,3,0.005809828,buffer <mask> null,"_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer<mask>null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) &"
1262,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,502,19862,19865,BinaryOperatorMutator,==,===,4,0.001195325,buffer <mask> null,"_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer<mask>null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) &"
1263,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,502,19856,19861,IdentifierMutator-Variable,buffer,Buffer,2,0.0029023364,<mask>,"ARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (<mask> == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18)"
1264,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,502,19856,19861,IdentifierMutator-Variable,buffer,buf,3,0.0014749382,<mask>,"ARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (<mask> == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18)"
1265,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,502,19856,19861,IdentifierMutator-Variable,buffer,in,4,0.0011709792,<mask>,"ARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (<mask> == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18)"
1266,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,502,19856,19861,FieldReferenceMutator,buffer,Buffer,2,0.0029023364,<mask>,"ARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (<mask> == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18)"
1267,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,502,19856,19861,FieldReferenceMutator,buffer,buf,3,0.0014749382,<mask>,"ARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (<mask> == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18)"
1268,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,502,19856,19861,FieldReferenceMutator,buffer,in,4,0.0011709792,<mask>,"ARD_ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (<mask> == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18)"
1269,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,502,19866,19869,IdentifierMutator-Literal,null,nil,1,0.0016498294,<mask>,"ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer ==<mask> || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MAS"
1270,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,502,19866,19869,IdentifierMutator-Literal,null,NULL,2,7.17349E-4,<mask>,"ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer ==<mask> || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MAS"
1271,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,502,19866,19869,IdentifierMutator-Literal,null,undefined,4,4.8640807E-4,<mask>,"ENCODE_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer ==<mask> || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MAS"
1272,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,502,19893,19895,BinaryOperatorMutator,<,>,1,0.20770806,(buffer.length - pos) <mask> encodeSize,"                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos<mask>encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];"
1273,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,502,19893,19895,BinaryOperatorMutator,<,>,3,0.11078587,(buffer.length - pos) <mask> encodeSize,"                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos<mask>encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];"
1274,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,502,19893,19895,BinaryOperatorMutator,<,==,4,0.09896263,(buffer.length - pos) <mask> encodeSize,"                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos<mask>encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];"
1275,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,502,19887,19889,BinaryOperatorMutator,-,+,1,0.18878353,buffer.length <mask> pos," {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length<mask>pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS"
1276,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,502,19887,19889,BinaryOperatorMutator,-,*,2,0.082328506,buffer.length <mask> pos," {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length<mask>pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS"
1277,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,502,19887,19889,BinaryOperatorMutator,-,_,4,0.006510122,buffer.length <mask> pos," {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length<mask>pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS"
1278,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,502,19874,19886,IdentifierMutator-Variable,buffer.length,i,0,0.18425716,<mask>,"_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null ||<mask> - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BIT"
1279,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,502,19874,19886,IdentifierMutator-Variable,buffer.length,size,1,0.14102772,<mask>,"_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null ||<mask> - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BIT"
1280,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,502,19874,19886,IdentifierMutator-Variable,buffer.length,length,2,0.0968811,<mask>,"_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null ||<mask> - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BIT"
1281,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,502,19874,19886,IdentifierMutator-Variable,buffer.length,limit,3,0.058803067,<mask>,"_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null ||<mask> - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BIT"
1282,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,502,19874,19886,IdentifierMutator-Variable,buffer.length,256,4,0.03123311,<mask>,"_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null ||<mask> - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BIT"
1283,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,502,19874,19879,IdentifierMutator-Variable,buffer,in,1,0.0010918559,<mask>,"_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null ||<mask>.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_"
1284,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,502,19874,19879,IdentifierMutator-Variable,buffer,buf,2,6.573179E-4,<mask>,"_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null ||<mask>.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_"
1285,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,502,19874,19879,IdentifierMutator-Variable,buffer,input,3,3.919257E-4,<mask>,"_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null ||<mask>.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_"
1286,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,502,19874,19879,FieldReferenceMutator,buffer,in,1,0.0010918559,<mask>,"_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null ||<mask>.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_"
1287,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,502,19874,19879,FieldReferenceMutator,buffer,buf,2,6.573179E-4,<mask>,"_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null ||<mask>.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_"
1288,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,502,19874,19879,FieldReferenceMutator,buffer,input,3,3.919257E-4,<mask>,"_TABLE) {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null ||<mask>.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_"
1289,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,502,19881,19886,FieldReferenceMutator,length,position,1,0.0041366075,buffer.<mask>,") {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.<mask> - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BIT"
1290,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,502,19881,19886,FieldReferenceMutator,length,size,2,0.0011246969,buffer.<mask>,") {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.<mask> - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BIT"
1291,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,502,19881,19886,FieldReferenceMutator,length,len,3,0.001039405,buffer.<mask>,") {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.<mask> - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BIT"
1292,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,502,19881,19886,FieldReferenceMutator,length,capacity,4,4.4905336E-4,buffer.<mask>,") {
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.<mask> - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BIT"
1293,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,502,19890,19892,IdentifierMutator-Variable,pos,i,1,0.4091551,<mask>,"
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length -<mask> < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];"
1294,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,502,19890,19892,IdentifierMutator-Variable,pos,1,2,0.008814072,<mask>,"
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length -<mask> < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];"
1295,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,502,19890,19892,IdentifierMutator-Variable,pos,index,3,0.008114432,<mask>,"
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length -<mask> < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];"
1296,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,502,19890,19892,IdentifierMutator-Variable,pos,offset,4,0.003906174,<mask>,"
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length -<mask> < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];"
1297,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,502,19890,19892,FieldReferenceMutator,pos,i,1,0.4091551,<mask>,"
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length -<mask> < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];"
1298,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,502,19890,19892,FieldReferenceMutator,pos,1,2,0.008814072,<mask>,"
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length -<mask> < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];"
1299,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,502,19890,19892,FieldReferenceMutator,pos,index,3,0.008114432,<mask>,"
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length -<mask> < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];"
1300,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,502,19890,19892,FieldReferenceMutator,pos,offset,4,0.003906174,<mask>,"
                        buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length -<mask> < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];"
1301,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,502,19896,19905,IdentifierMutator-Variable,encodeSize,0,0,0.31298754,<mask>,"                       buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos <<mask>) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
  "
1302,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,502,19896,19905,IdentifierMutator-Variable,encodeSize,1,1,0.069835626,<mask>,"                       buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos <<mask>) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
  "
1303,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,502,19896,19905,IdentifierMutator-Variable,encodeSize,3,2,0.062432777,<mask>,"                       buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos <<mask>) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
  "
1304,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,502,19896,19905,IdentifierMutator-Variable,encodeSize,2,3,0.049996737,<mask>,"                       buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos <<mask>) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
  "
1305,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,502,19896,19905,IdentifierMutator-Variable,encodeSize,4,4,0.03850666,<mask>,"                       buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos <<mask>) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
  "
1306,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,502,19896,19905,FieldReferenceMutator,encodeSize,0,0,0.31298754,<mask>,"                       buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos <<mask>) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
  "
1307,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,502,19896,19905,FieldReferenceMutator,encodeSize,1,1,0.069835626,<mask>,"                       buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos <<mask>) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
  "
1308,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,502,19896,19905,FieldReferenceMutator,encodeSize,3,2,0.062432777,<mask>,"                       buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos <<mask>) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
  "
1309,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,502,19896,19905,FieldReferenceMutator,encodeSize,2,3,0.049996737,<mask>,"                       buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos <<mask>) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
  "
1310,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,502,19896,19905,FieldReferenceMutator,encodeSize,4,4,0.03850666,<mask>,"                       buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos <<mask>) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
  "
1311,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,503,19930,19941,MethodCallMutator,resizeBuffer,flush,0,0.2299465,<mask>(),"                   buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {<mask>();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encode"
1312,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,503,19930,19941,MethodCallMutator,resizeBuffer,break,1,0.14850865,<mask>(),"                   buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {<mask>();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encode"
1313,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,503,19930,19941,MethodCallMutator,resizeBuffer,close,2,0.14498119,<mask>(),"                   buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {<mask>();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encode"
1314,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,503,19930,19941,MethodCallMutator,resizeBuffer,reset,3,0.022870919,<mask>(),"                   buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {<mask>();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encode"
1315,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,503,19930,19941,MethodCallMutator,resizeBuffer,return,4,0.019781845,<mask>(),"                   buffer[pos++] = PAD;
                    }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {<mask>();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encode"
1316,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,505,19987,19987,AssignmentMutator,modulus=(++modulus)%3,|,0,0.47851506,modulus <mask>= (++modulus) % 3,"           break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus<mask>= (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer"
1317,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,505,19987,19987,AssignmentMutator,modulus=(++modulus)%3,^,1,0.29056475,modulus <mask>= (++modulus) % 3,"           break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus<mask>= (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer"
1318,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,505,19987,19987,AssignmentMutator,modulus=(++modulus)%3,*,2,0.13664393,modulus <mask>= (++modulus) % 3,"           break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus<mask>= (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer"
1319,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,505,19987,19987,AssignmentMutator,modulus=(++modulus)%3,~,3,0.025976336,modulus <mask>= (++modulus) % 3,"           break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus<mask>= (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer"
1320,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,505,19987,19987,AssignmentMutator,modulus=(++modulus)%3,&,4,0.022402443,modulus <mask>= (++modulus) % 3,"           break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus<mask>= (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer"
1321,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,505,19980,19986,IdentifierMutator-Variable,modulus,mod,0,0.366039,<mask>,"        }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }<mask> = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer"
1322,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,505,19980,19986,IdentifierMutator-Variable,modulus,i,1,0.22918198,<mask>,"        }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }<mask> = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer"
1323,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,505,19980,19986,IdentifierMutator-Variable,modulus,shift,2,0.037381936,<mask>,"        }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }<mask> = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer"
1324,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,505,19980,19986,IdentifierMutator-Variable,modulus,x,3,0.034641884,<mask>,"        }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }<mask> = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer"
1325,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,505,19980,19986,IdentifierMutator-Variable,modulus,b,4,0.02758909,<mask>,"        }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }<mask> = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer"
1326,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,505,19980,19986,FieldReferenceMutator,modulus,mod,0,0.366039,<mask>,"        }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }<mask> = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer"
1327,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,505,19980,19986,FieldReferenceMutator,modulus,i,1,0.22918198,<mask>,"        }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }<mask> = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer"
1328,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,505,19980,19986,FieldReferenceMutator,modulus,shift,2,0.037381936,<mask>,"        }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }<mask> = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer"
1329,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,505,19980,19986,FieldReferenceMutator,modulus,x,3,0.034641884,<mask>,"        }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }<mask> = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer"
1330,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,505,19980,19986,FieldReferenceMutator,modulus,b,4,0.02758909,<mask>,"        }
                    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }<mask> = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer"
1331,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,505,20001,20003,BinaryOperatorMutator,%,<<,0,0.2591907,(++modulus) <mask> 3,"     break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus)<mask>3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable"
1332,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,505,20001,20003,BinaryOperatorMutator,%,^,1,0.110905826,(++modulus) <mask> 3,"     break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus)<mask>3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable"
1333,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,505,20001,20003,BinaryOperatorMutator,%,*,2,0.0977899,(++modulus) <mask> 3,"     break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus)<mask>3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable"
1334,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,505,20001,20003,BinaryOperatorMutator,%,/,3,0.097750545,(++modulus) <mask> 3,"     break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus)<mask>3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable"
1335,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,505,20001,20003,BinaryOperatorMutator,%,>>>,4,0.090635665,(++modulus) <mask> 3,"     break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus)<mask>3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable"
1336,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,505,19990,19992,UnaryOperatorMutator,++,(,0,0.89161223,<mask>modulus,"          break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus =<mask>modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++"
1337,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,505,19990,19992,UnaryOperatorMutator,++,((,1,0.040229503,<mask>modulus,"          break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus =<mask>modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++"
1338,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,505,19990,19992,UnaryOperatorMutator,++,(-,2,0.019966546,<mask>modulus,"          break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus =<mask>modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++"
1339,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,505,19990,19992,UnaryOperatorMutator,++,$(,3,0.019793415,<mask>modulus,"          break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus =<mask>modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++"
1340,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,505,19990,19992,UnaryOperatorMutator,++,(,4,0.014999445,<mask>modulus,"          break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus =<mask>modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++"
1341,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,505,19993,19999,IdentifierMutator-Variable,modulus,pos,0,0.3082645,<mask>,"        break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++<mask>) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] ="
1342,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,505,19993,19999,IdentifierMutator-Variable,modulus,i,1,0.13752128,<mask>,"        break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++<mask>) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] ="
1343,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,505,19993,19999,IdentifierMutator-Variable,modulus,x,2,0.028434496,<mask>,"        break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++<mask>) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] ="
1344,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,505,19993,19999,IdentifierMutator-Variable,modulus,shift,3,0.023058115,<mask>,"        break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++<mask>) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] ="
1345,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,505,19993,19999,IdentifierMutator-Variable,modulus,32,4,0.012451312,<mask>,"        break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++<mask>) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] ="
1346,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,505,19993,19999,FieldReferenceMutator,modulus,pos,0,0.3082645,<mask>,"        break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++<mask>) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] ="
1347,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,505,19993,19999,FieldReferenceMutator,modulus,i,1,0.13752128,<mask>,"        break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++<mask>) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] ="
1348,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,505,19993,19999,FieldReferenceMutator,modulus,x,2,0.028434496,<mask>,"        break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++<mask>) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] ="
1349,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,505,19993,19999,FieldReferenceMutator,modulus,shift,3,0.023058115,<mask>,"        break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++<mask>) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] ="
1350,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,505,19993,19999,FieldReferenceMutator,modulus,32,4,0.012451312,<mask>,"        break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++<mask>) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] ="
1351,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,505,20004,20004,IdentifierMutator-Literal,3,256,0,0.6057818,<mask>,"    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) %<mask>;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable["
1352,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,505,20004,20004,IdentifierMutator-Literal,3,8,1,0.12547572,<mask>,"    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) %<mask>;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable["
1353,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,505,20004,20004,IdentifierMutator-Literal,3,7,2,0.034191027,<mask>,"    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) %<mask>;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable["
1354,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,505,20004,20004,IdentifierMutator-Literal,3,32,3,0.03331981,<mask>,"    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) %<mask>;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable["
1355,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,505,20004,20004,IdentifierMutator-Literal,3,4,4,0.02795065,<mask>,"    break;
            }
            if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) %<mask>;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable["
1356,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,506,20034,20040,ArrayAccessMutator,inPos++,i,0,0.66938376,in[<mask>],"        if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[<mask>];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
           "
1357,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,506,20034,20040,ArrayAccessMutator,inPos++,pos,1,0.294579,in[<mask>],"        if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[<mask>];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
           "
1358,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,506,20034,20040,ArrayAccessMutator,inPos++,0,2,0.0031445394,in[<mask>],"        if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[<mask>];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
           "
1359,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,506,20034,20040,ArrayAccessMutator,inPos++,j,3,0.0020748985,in[<mask>],"        if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[<mask>];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
           "
1360,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,506,20034,20040,ArrayAccessMutator,inPos++,i,4,0.0020171243,in[<mask>],"        if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[<mask>];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
           "
1361,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,506,20031,20032,IdentifierMutator-Variable,in,buffer,0,0.6025827,<mask>,"          if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b =<mask>[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
       "
1362,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,506,20031,20032,IdentifierMutator-Variable,in,bytes,2,0.027596995,<mask>,"          if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b =<mask>[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
       "
1363,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,506,20031,20032,IdentifierMutator-Variable,in,buf,3,0.024895383,<mask>,"          if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b =<mask>[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
       "
1364,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,506,20031,20032,IdentifierMutator-Variable,in,data,4,0.02476139,<mask>,"          if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b =<mask>[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
       "
1365,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,506,20039,20040,UnaryOperatorMutator,++,--,2,9.5790206E-4,inPos<mask>,"      if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos<mask>];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
           "
1366,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,506,20039,20040,UnaryOperatorMutator,++,x,3,8.321881E-4,inPos<mask>,"      if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos<mask>];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
           "
1367,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,506,20039,20040,UnaryOperatorMutator,++,i,4,3.1109917E-4,inPos<mask>,"      if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos<mask>];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
           "
1368,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,506,20034,20038,IdentifierMutator-Variable,inPos,pos,0,0.9789731,<mask>,"        if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[<mask>++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
          "
1369,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,506,20034,20038,IdentifierMutator-Variable,inPos,i,1,0.008143472,<mask>,"        if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[<mask>++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
          "
1370,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,506,20034,20038,IdentifierMutator-Variable,inPos,pos,2,0.0050295508,<mask>,"        if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[<mask>++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
          "
1371,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,506,20034,20038,IdentifierMutator-Variable,inPos,index,3,6.505765E-4,<mask>,"        if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[<mask>++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
          "
1372,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,506,20034,20038,IdentifierMutator-Variable,inPos,offset,4,5.82215E-4,<mask>,"        if (lineLength > 0 && pos > 0) {
                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[<mask>++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
          "
1373,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,507,20065,20067,BinaryOperatorMutator,<,>,1,0.19194485,b <mask> 0,"             System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b<mask>0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK"
1374,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,507,20065,20067,BinaryOperatorMutator,<,==,2,0.18435054,b <mask> 0,"             System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b<mask>0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK"
1375,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,507,20065,20067,BinaryOperatorMutator,<,==,4,0.060205013,b <mask> 0,"             System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b<mask>0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK"
1376,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,507,20064,20064,IdentifierMutator-Variable,b,bb,1,0.0012546774,<mask>,"              System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (<mask> < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MAS"
1377,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,507,20064,20064,IdentifierMutator-Variable,b,bc,2,0.001182256,<mask>,"              System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (<mask> < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MAS"
1378,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,507,20064,20064,IdentifierMutator-Variable,b,a,3,6.7194423E-4,<mask>,"              System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (<mask> < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MAS"
1379,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,507,20068,20068,IdentifierMutator-Literal,0,256,1,0.21156868,<mask>,"            System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b <<mask>) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_"
1380,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,507,20068,20068,IdentifierMutator-Literal,0,128,2,0.04199126,<mask>,"            System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b <<mask>) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_"
1381,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,507,20068,20068,IdentifierMutator-Literal,0,1,3,0.011147414,<mask>,"            System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b <<mask>) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_"
1382,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,507,20068,20068,IdentifierMutator-Literal,0,255,4,0.009976119,<mask>,"            System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b <<mask>) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_"
1383,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,508,20094,20094,AssignmentMutator,b+=256,*,0,0.47544602,b <mask>= 256,", pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b<mask>+= 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                  "
1384,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,508,20094,20094,AssignmentMutator,b+=256,&,1,0.17089388,b <mask>= 256,", pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b<mask>+= 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                  "
1385,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,508,20094,20094,AssignmentMutator,b+=256,|,2,0.09240969,b <mask>= 256,", pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b<mask>+= 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                  "
1386,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,508,20094,20094,AssignmentMutator,b+=256,>>>,3,0.055562455,b <mask>= 256,", pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b<mask>+= 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                  "
1387,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,508,20094,20094,AssignmentMutator,b+=256,/,4,0.039260786,b <mask>= 256,", pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b<mask>+= 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                  "
1388,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,508,20093,20093,IdentifierMutator-Variable,b,x,2,0.0023339507,<mask>,"         System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {<mask> += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                  "
1389,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,508,20093,20093,IdentifierMutator-Variable,b,a,3,6.8368885E-4,<mask>,"         System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {<mask> += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                  "
1390,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,508,20093,20093,IdentifierMutator-Variable,b,x,4,3.4877277E-4,<mask>,"         System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {<mask> += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                  "
1391,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,508,20098,20100,IdentifierMutator-Literal,256,b,0,0.5066582,<mask>," pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b +=<mask>;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    current"
1392,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,508,20098,20100,IdentifierMutator-Literal,256,1,1,0.18218191,<mask>," pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b +=<mask>;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    current"
1393,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,508,20098,20100,IdentifierMutator-Literal,256,3,2,0.057953328,<mask>," pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b +=<mask>;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    current"
1394,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,508,20098,20100,IdentifierMutator-Literal,256,a,3,0.03459489,<mask>," pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b +=<mask>;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    current"
1395,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,508,20098,20100,IdentifierMutator-Literal,256,4,4,0.018121801,<mask>," pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b +=<mask>;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    current"
1396,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,510,20138,20138,AssignmentMutator,x=(x<<8)+b,^,0,0.64949256,x <mask>= (x << 8) + b,"           }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x<mask>= (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <="
1397,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,510,20138,20138,AssignmentMutator,x=(x<<8)+b,|,1,0.1648105,x <mask>= (x << 8) + b,"           }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x<mask>= (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <="
1398,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,510,20138,20138,AssignmentMutator,x=(x<<8)+b,*,2,0.063775286,x <mask>= (x << 8) + b,"           }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x<mask>= (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <="
1399,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,510,20138,20138,AssignmentMutator,x=(x<<8)+b,>>,3,0.023959793,x <mask>= (x << 8) + b,"           }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x<mask>= (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <="
1400,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,510,20138,20138,AssignmentMutator,x=(x<<8)+b,&,4,0.013052157,x <mask>= (x << 8) + b,"           }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x<mask>= (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <="
1401,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,510,20137,20137,IdentifierMutator-Variable,x,xx,2,0.0056569874,<mask>,"       pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }<mask> = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <="
1402,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,510,20137,20137,IdentifierMutator-Variable,x,b,3,0.005582003,<mask>,"       pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }<mask> = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <="
1403,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,510,20137,20137,IdentifierMutator-Variable,x,pos,4,0.003914058,<mask>,"       pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }<mask> = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <="
1404,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,510,20137,20137,FieldReferenceMutator,x,xx,2,0.0056569874,<mask>,"       pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }<mask> = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <="
1405,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,510,20137,20137,FieldReferenceMutator,x,b,3,0.005582003,<mask>,"       pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }<mask> = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <="
1406,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,510,20137,20137,FieldReferenceMutator,x,pos,4,0.003914058,<mask>,"       pos += lineSeparator.length;
            }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }<mask> = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <="
1407,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,510,20149,20151,BinaryOperatorMutator,+,|,0,0.4727424,(x << 8) <mask> b,"     }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8)<mask>b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
 "
1408,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,510,20149,20151,BinaryOperatorMutator,+,^,1,0.24300185,(x << 8) <mask> b,"     }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8)<mask>b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
 "
1409,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,510,20149,20151,BinaryOperatorMutator,+,^,2,0.06435483,(x << 8) <mask> b,"     }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8)<mask>b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
 "
1410,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,510,20149,20151,BinaryOperatorMutator,+,*,4,0.03675517,(x << 8) <mask> b,"     }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8)<mask>b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
 "
1411,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,510,20143,20146,BinaryOperatorMutator,<<,*,2,0.052197065,x <mask> 8,"        }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x<mask>8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos)"
1412,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,510,20143,20146,BinaryOperatorMutator,<<,*,3,0.04134577,x <mask> 8,"        }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x<mask>8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos)"
1413,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,510,20143,20146,BinaryOperatorMutator,<<,>>,4,0.039283052,x <mask> 8,"        }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x<mask>8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos)"
1414,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,510,20142,20142,IdentifierMutator-Variable,x,1,1,0.02460696,<mask>,"         }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (<mask> << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos"
1415,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,510,20142,20142,IdentifierMutator-Variable,x,a,2,0.018948747,<mask>,"         }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (<mask> << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos"
1416,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,510,20142,20142,IdentifierMutator-Variable,x,0,3,0.0052235285,<mask>,"         }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (<mask> << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos"
1417,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,510,20142,20142,IdentifierMutator-Variable,x,i,4,0.004632921,<mask>,"         }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (<mask> << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos"
1418,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,510,20142,20142,FieldReferenceMutator,x,1,1,0.02460696,<mask>,"         }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (<mask> << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos"
1419,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,510,20142,20142,FieldReferenceMutator,x,a,2,0.018948747,<mask>,"         }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (<mask> << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos"
1420,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,510,20142,20142,FieldReferenceMutator,x,0,3,0.0052235285,<mask>,"         }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (<mask> << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos"
1421,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,510,20142,20142,FieldReferenceMutator,x,i,4,0.004632921,<mask>,"         }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (<mask> << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos"
1422,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,510,20147,20147,IdentifierMutator-Literal,8,3,0,0.487876,<mask>,"       }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x <<<mask>) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {"
1423,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,510,20147,20147,IdentifierMutator-Literal,8,6,1,0.09101585,<mask>,"       }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x <<<mask>) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {"
1424,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,510,20147,20147,IdentifierMutator-Literal,8,7,2,0.068030104,<mask>,"       }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x <<<mask>) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {"
1425,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,510,20147,20147,IdentifierMutator-Literal,8,4,3,0.06388681,<mask>,"       }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x <<<mask>) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {"
1426,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,510,20147,20147,IdentifierMutator-Literal,8,1,4,0.058835242,<mask>,"       }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x <<<mask>) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {"
1427,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,510,20152,20152,IdentifierMutator-Variable,b,1,1,0.06379104,<mask>,"    }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) +<mask>;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
  "
1428,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,510,20152,20152,IdentifierMutator-Variable,b,0,2,0.003952813,<mask>,"    }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) +<mask>;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
  "
1429,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,510,20152,20152,IdentifierMutator-Variable,b,2,3,0.0034723906,<mask>,"    }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) +<mask>;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
  "
1430,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,510,20152,20152,IdentifierMutator-Variable,b,a,4,0.0033479622,<mask>,"    }
        } else {
            for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) +<mask>;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
  "
1431,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,511,20176,20179,BinaryOperatorMutator,==,<,0,0.26369897,0 <mask> modulus,"       for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0<mask>modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                       "
1432,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,511,20176,20179,BinaryOperatorMutator,==,<,3,0.16148953,0 <mask> modulus,"       for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0<mask>modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                       "
1433,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,511,20176,20179,BinaryOperatorMutator,==,!=,4,0.076652415,0 <mask> modulus,"       for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0<mask>modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                       "
1434,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,511,20175,20175,IdentifierMutator-Literal,0,b,0,0.7616199,<mask>,"        for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (<mask> == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                      "
1435,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,511,20175,20175,IdentifierMutator-Literal,0,x,1,0.09502475,<mask>,"        for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (<mask> == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                      "
1436,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,511,20175,20175,IdentifierMutator-Literal,0,a,2,0.027436377,<mask>,"        for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (<mask> == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                      "
1437,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,511,20175,20175,IdentifierMutator-Literal,0,3,4,0.012158273,<mask>,"        for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (<mask> == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                      "
1438,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,511,20180,20186,IdentifierMutator-Variable,modulus,x,0,0.47359556,<mask>,"      for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 ==<mask>) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System."
1439,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,511,20180,20186,IdentifierMutator-Variable,modulus,b,1,0.41289622,<mask>,"      for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 ==<mask>) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System."
1440,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,511,20180,20186,IdentifierMutator-Variable,modulus,c,2,0.0117913615,<mask>,"      for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 ==<mask>) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System."
1441,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,511,20180,20186,IdentifierMutator-Variable,modulus,f,3,0.0065254415,<mask>,"      for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 ==<mask>) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System."
1442,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,511,20180,20186,IdentifierMutator-Variable,modulus,i,4,0.006065281,<mask>,"      for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 ==<mask>) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System."
1443,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,511,20180,20186,FieldReferenceMutator,modulus,x,0,0.47359556,<mask>,"      for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 ==<mask>) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System."
1444,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,511,20180,20186,FieldReferenceMutator,modulus,b,1,0.41289622,<mask>,"      for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 ==<mask>) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System."
1445,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,511,20180,20186,FieldReferenceMutator,modulus,c,2,0.0117913615,<mask>,"      for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 ==<mask>) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System."
1446,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,511,20180,20186,FieldReferenceMutator,modulus,f,3,0.0065254415,<mask>,"      for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 ==<mask>) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System."
1447,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,511,20180,20186,FieldReferenceMutator,modulus,i,4,0.006065281,<mask>,"      for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 ==<mask>) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System."
1448,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,512,20224,20224,AssignmentMutator,buffer[pos++]=encodeTable[(x>>18)&org.apache.commons.codec.binary.Base64.MASK_6BITS],|,0,0.58595383,buffer[pos++] <mask>= encodeTable[(x >> 18) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"         if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++]<mask>= encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
     "
1449,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,512,20224,20224,AssignmentMutator,buffer[pos++]=encodeTable[(x>>18)&org.apache.commons.codec.binary.Base64.MASK_6BITS],^,1,0.2882388,buffer[pos++] <mask>= encodeTable[(x >> 18) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"         if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++]<mask>= encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
     "
1450,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,512,20224,20224,AssignmentMutator,buffer[pos++]=encodeTable[(x>>18)&org.apache.commons.codec.binary.Base64.MASK_6BITS],*,2,0.043555997,buffer[pos++] <mask>= encodeTable[(x >> 18) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"         if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++]<mask>= encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
     "
1451,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,512,20224,20224,AssignmentMutator,buffer[pos++]=encodeTable[(x>>18)&org.apache.commons.codec.binary.Base64.MASK_6BITS],&,3,0.015775343,buffer[pos++] <mask>= encodeTable[(x >> 18) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"         if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++]<mask>= encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
     "
1452,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,512,20224,20224,AssignmentMutator,buffer[pos++]=encodeTable[(x>>18)&org.apache.commons.codec.binary.Base64.MASK_6BITS],+,4,0.007666908,buffer[pos++] <mask>= encodeTable[(x >> 18) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"         if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++]<mask>= encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
     "
1453,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,512,20218,20222,ArrayAccessMutator,pos++,pos,0,0.9988036,buffer[<mask>],"            if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[<mask>] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
    "
1454,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,512,20218,20222,ArrayAccessMutator,pos++,++,1,1.4204906E-4,buffer[<mask>],"            if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[<mask>] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
    "
1455,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,512,20218,20222,ArrayAccessMutator,pos++,0,2,1.1054925E-4,buffer[<mask>],"            if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[<mask>] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
    "
1456,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,512,20218,20222,ArrayAccessMutator,pos++,neg,3,7.330352E-5,buffer[<mask>],"            if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[<mask>] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
    "
1457,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,512,20218,20222,ArrayAccessMutator,pos++,position,4,6.649292E-5,buffer[<mask>],"            if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[<mask>] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
    "
1458,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,512,20211,20216,IdentifierMutator-Variable,buffer,Buffer,2,5.7525554E-4,<mask>,"  for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {<mask>[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
 "
1459,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,512,20211,20216,IdentifierMutator-Variable,buffer,byte,3,3.3002844E-4,<mask>,"  for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {<mask>[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
 "
1460,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,512,20211,20216,IdentifierMutator-Variable,buffer,byte,4,2.2382181E-4,<mask>,"  for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {<mask>[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
 "
1461,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,512,20211,20216,FieldReferenceMutator,buffer,Buffer,2,5.7525554E-4,<mask>,"  for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {<mask>[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
 "
1462,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,512,20211,20216,FieldReferenceMutator,buffer,byte,3,3.3002844E-4,<mask>,"  for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {<mask>[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
 "
1463,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,512,20211,20216,FieldReferenceMutator,buffer,byte,4,2.2382181E-4,<mask>,"  for (int i = 0; i < inAvail; i++) {
                if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {<mask>[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
 "
1464,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,512,20221,20222,UnaryOperatorMutator,++,+,1,1.0852303E-4,pos<mask>,"           if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos<mask>] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
    "
1465,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,512,20221,20222,UnaryOperatorMutator,++,++;,3,4.3012962E-5,pos<mask>,"           if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos<mask>] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
    "
1466,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,512,20221,20222,UnaryOperatorMutator,++,--,4,3.441421E-5,pos<mask>,"           if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos<mask>] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
    "
1467,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,512,20218,20220,IdentifierMutator-Variable,pos,len,1,2.4805724E-5,<mask>,"            if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[<mask>++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
   "
1468,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,512,20218,20220,IdentifierMutator-Variable,pos,neg,2,2.326667E-5,<mask>,"            if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[<mask>++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
   "
1469,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,512,20218,20220,IdentifierMutator-Variable,pos,size,3,1.9429799E-5,<mask>,"            if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[<mask>++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
   "
1470,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,512,20218,20220,FieldReferenceMutator,pos,len,1,2.4805724E-5,<mask>,"            if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[<mask>++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
   "
1471,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,512,20218,20220,FieldReferenceMutator,pos,neg,2,2.326667E-5,<mask>,"            if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[<mask>++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
   "
1472,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,512,20218,20220,FieldReferenceMutator,pos,size,3,1.9429799E-5,<mask>,"            if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[<mask>++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
   "
1473,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,512,20239,20260,ArrayAccessMutator,(x>>18)&org.apache.commons.codec.binary.Base64.MASK_6BITS,x,0,0.88661486,encodeTable[<mask>],"     if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                     "
1474,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,512,20239,20260,ArrayAccessMutator,(x>>18)&org.apache.commons.codec.binary.Base64.MASK_6BITS,0,1,0.020588694,encodeTable[<mask>],"     if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                     "
1475,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,512,20239,20260,ArrayAccessMutator,(x>>18)&org.apache.commons.codec.binary.Base64.MASK_6BITS,1,2,0.0059377034,encodeTable[<mask>],"     if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                     "
1476,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,512,20239,20260,ArrayAccessMutator,(x>>18)&org.apache.commons.codec.binary.Base64.MASK_6BITS,xx,3,0.004727886,encodeTable[<mask>],"     if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                     "
1477,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,512,20239,20260,ArrayAccessMutator,(x>>18)&org.apache.commons.codec.binary.Base64.MASK_6BITS,i,4,0.004462088,encodeTable[<mask>],"     if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                     "
1478,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,512,20227,20237,IdentifierMutator-Variable,encodeTable,table,0,0.28265503,<mask>,"        if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] =<mask>[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
        "
1479,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,512,20227,20237,IdentifierMutator-Variable,encodeTable,encode,1,0.143001,<mask>,"        if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] =<mask>[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
        "
1480,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,512,20227,20237,IdentifierMutator-Variable,encodeTable,decode,2,0.039326105,<mask>,"        if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] =<mask>[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
        "
1481,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,512,20227,20237,IdentifierMutator-Variable,encodeTable,byte,3,0.031816043,<mask>,"        if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] =<mask>[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
        "
1482,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,512,20227,20237,IdentifierMutator-Variable,encodeTable,buffer,4,0.027764978,<mask>,"        if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] =<mask>[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
        "
1483,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,512,20227,20237,FieldReferenceMutator,encodeTable,table,0,0.28265503,<mask>,"        if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] =<mask>[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
        "
1484,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,512,20227,20237,FieldReferenceMutator,encodeTable,encode,1,0.143001,<mask>,"        if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] =<mask>[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
        "
1485,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,512,20227,20237,FieldReferenceMutator,encodeTable,decode,2,0.039326105,<mask>,"        if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] =<mask>[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
        "
1486,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,512,20227,20237,FieldReferenceMutator,encodeTable,byte,3,0.031816043,<mask>,"        if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] =<mask>[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
        "
1487,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,512,20227,20237,FieldReferenceMutator,encodeTable,buffer,4,0.027764978,<mask>,"        if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] =<mask>[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
        "
1488,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,512,20248,20250,BinaryOperatorMutator,&,|,2,7.0039235E-4,(x >> 18) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS," (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18)<mask>MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
               "
1489,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,512,20248,20250,BinaryOperatorMutator,&,^,3,8.209885E-5,(x >> 18) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS," (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18)<mask>MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
               "
1490,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,512,20248,20250,BinaryOperatorMutator,&,~,4,2.6727665E-5,(x >> 18) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS," (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18)<mask>MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
               "
1491,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,512,20241,20244,BinaryOperatorMutator,>>,>>>,2,0.014077157,x <mask> 18,"   if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x<mask>18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
            "
1492,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,512,20241,20244,BinaryOperatorMutator,>>,<<,3,0.011360025,x <mask> 18,"   if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x<mask>18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
            "
1493,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,512,20241,20244,BinaryOperatorMutator,>>,>>>,4,0.0023995826,x <mask> 18,"   if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x<mask>18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
            "
1494,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,512,20240,20240,IdentifierMutator-Variable,x,y,1,2.184737E-5,<mask>,"    if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(<mask> >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
           "
1495,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,512,20240,20240,IdentifierMutator-Variable,x,b,3,6.949012E-6,<mask>,"    if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(<mask> >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
           "
1496,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,512,20240,20240,IdentifierMutator-Variable,x,xx,4,6.0042985E-6,<mask>,"    if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(<mask> >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
           "
1497,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,512,20240,20240,FieldReferenceMutator,x,y,1,2.184737E-5,<mask>,"    if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(<mask> >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
           "
1498,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,512,20240,20240,FieldReferenceMutator,x,b,3,6.949012E-6,<mask>,"    if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(<mask> >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
           "
1499,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,512,20240,20240,FieldReferenceMutator,x,xx,4,6.0042985E-6,<mask>,"    if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(<mask> >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
           "
1500,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,512,20245,20246,IdentifierMutator-Literal,18,6,0,0.30219615,<mask>,"  if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
             "
1501,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,512,20245,20246,IdentifierMutator-Literal,18,14,2,0.15861839,<mask>,"  if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
             "
1502,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,512,20245,20246,IdentifierMutator-Literal,18,16,3,0.12405489,<mask>,"  if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
             "
1503,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,512,20245,20246,IdentifierMutator-Literal,18,13,4,0.044997454,<mask>,"  if (buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
             "
1504,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,512,20251,20260,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,7,0,0.10203409,<mask>,"buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                     "
1505,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,512,20251,20260,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,63,1,0.07741652,<mask>,"buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                     "
1506,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,512,20251,20260,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,mask,2,0.07146262,<mask>,"buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                     "
1507,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,512,20251,20260,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,bits,3,0.06290492,<mask>,"buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                     "
1508,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,512,20251,20260,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,6,4,0.056504957,<mask>,"buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                     "
1509,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,512,20251,20260,FieldReferenceMutator,MASK_6BITS,7,0,0.10203409,org.apache.commons.codec.binary.Base64.<mask>,"buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                     "
1510,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,512,20251,20260,FieldReferenceMutator,MASK_6BITS,63,1,0.07741652,org.apache.commons.codec.binary.Base64.<mask>,"buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                     "
1511,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,512,20251,20260,FieldReferenceMutator,MASK_6BITS,mask,2,0.07146262,org.apache.commons.codec.binary.Base64.<mask>,"buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                     "
1512,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,512,20251,20260,FieldReferenceMutator,MASK_6BITS,bits,3,0.06290492,org.apache.commons.codec.binary.Base64.<mask>,"buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                     "
1513,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,512,20251,20260,FieldReferenceMutator,MASK_6BITS,6,4,0.056504957,org.apache.commons.codec.binary.Base64.<mask>,"buffer == null || buffer.length - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                     "
1514,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,513,20297,20297,AssignmentMutator,buffer[pos++]=encodeTable[(x>>12)&org.apache.commons.codec.binary.Base64.MASK_6BITS],|,0,0.6265021,buffer[pos++] <mask>= encodeTable[(x >> 12) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"   resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
              "
1515,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,513,20297,20297,AssignmentMutator,buffer[pos++]=encodeTable[(x>>12)&org.apache.commons.codec.binary.Base64.MASK_6BITS],^,1,0.20987435,buffer[pos++] <mask>= encodeTable[(x >> 12) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"   resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
              "
1516,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,513,20297,20297,AssignmentMutator,buffer[pos++]=encodeTable[(x>>12)&org.apache.commons.codec.binary.Base64.MASK_6BITS],*,2,0.05411837,buffer[pos++] <mask>= encodeTable[(x >> 12) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"   resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
              "
1517,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,513,20297,20297,AssignmentMutator,buffer[pos++]=encodeTable[(x>>12)&org.apache.commons.codec.binary.Base64.MASK_6BITS],&,3,0.024408977,buffer[pos++] <mask>= encodeTable[(x >> 12) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"   resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
              "
1518,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,513,20297,20297,AssignmentMutator,buffer[pos++]=encodeTable[(x>>12)&org.apache.commons.codec.binary.Base64.MASK_6BITS],+,4,0.00917603,buffer[pos++] <mask>= encodeTable[(x >> 12) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"   resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
              "
1519,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,513,20291,20295,ArrayAccessMutator,pos++,pos,0,0.99518543,buffer[<mask>],"      resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
             "
1520,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,513,20291,20295,ArrayAccessMutator,pos++,++,1,0.0020608834,buffer[<mask>],"      resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
             "
1521,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,513,20291,20295,ArrayAccessMutator,pos++,push,2,2.4151117E-4,buffer[<mask>],"      resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
             "
1522,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,513,20291,20295,ArrayAccessMutator,pos++,+,3,1.6428687E-4,buffer[<mask>],"      resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
             "
1523,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,513,20291,20295,ArrayAccessMutator,pos++,position,4,1.6262548E-4,buffer[<mask>],"      resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
             "
1524,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,513,20284,20289,IdentifierMutator-Variable,buffer,Buffer,2,0.0017264769,<mask>," - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];<mask>[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
          "
1525,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,513,20284,20289,IdentifierMutator-Variable,buffer,byte,3,0.0013109291,<mask>," - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];<mask>[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
          "
1526,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,513,20284,20289,IdentifierMutator-Variable,buffer,byte,4,5.684142E-4,<mask>," - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];<mask>[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
          "
1527,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,513,20284,20289,FieldReferenceMutator,buffer,Buffer,2,0.0017264769,<mask>," - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];<mask>[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
          "
1528,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,513,20284,20289,FieldReferenceMutator,buffer,byte,3,0.0013109291,<mask>," - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];<mask>[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
          "
1529,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,513,20284,20289,FieldReferenceMutator,buffer,byte,4,5.684142E-4,<mask>," - pos < encodeSize) {
                    resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];<mask>[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
          "
1530,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,513,20294,20295,UnaryOperatorMutator,++,+,1,1.08531625E-4,pos<mask>,"     resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos<mask>] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
             "
1531,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,513,20294,20295,UnaryOperatorMutator,++,++;,3,5.0732004E-5,pos<mask>,"     resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos<mask>] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
             "
1532,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,513,20294,20295,UnaryOperatorMutator,++,--,4,3.8721104E-5,pos<mask>,"     resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos<mask>] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
             "
1533,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,513,20291,20293,IdentifierMutator-Variable,pos,len,1,3.1099207E-5,<mask>,"      resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
            "
1534,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,513,20291,20293,IdentifierMutator-Variable,pos,size,3,2.2258011E-5,<mask>,"      resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
            "
1535,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,513,20291,20293,IdentifierMutator-Variable,pos,neg,4,1.7419106E-5,<mask>,"      resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
            "
1536,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,513,20291,20293,FieldReferenceMutator,pos,len,1,3.1099207E-5,<mask>,"      resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
            "
1537,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,513,20291,20293,FieldReferenceMutator,pos,size,3,2.2258011E-5,<mask>,"      resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
            "
1538,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,513,20291,20293,FieldReferenceMutator,pos,neg,4,1.7419106E-5,<mask>,"      resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
            "
1539,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,513,20312,20333,ArrayAccessMutator,(x>>12)&org.apache.commons.codec.binary.Base64.MASK_6BITS,x,0,0.95328385,encodeTable[<mask>],"();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
"
1540,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,513,20312,20333,ArrayAccessMutator,(x>>12)&org.apache.commons.codec.binary.Base64.MASK_6BITS,0,1,0.008241688,encodeTable[<mask>],"();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
"
1541,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,513,20312,20333,ArrayAccessMutator,(x>>12)&org.apache.commons.codec.binary.Base64.MASK_6BITS,16,2,0.0026908512,encodeTable[<mask>],"();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
"
1542,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,513,20312,20333,ArrayAccessMutator,(x>>12)&org.apache.commons.codec.binary.Base64.MASK_6BITS,1,3,0.0022774427,encodeTable[<mask>],"();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
"
1543,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,513,20312,20333,ArrayAccessMutator,(x>>12)&org.apache.commons.codec.binary.Base64.MASK_6BITS,xx,4,0.0016143019,encodeTable[<mask>],"();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
"
1544,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,513,20300,20310,IdentifierMutator-Variable,encodeTable,table,0,0.48148024,<mask>,"  resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                 "
1545,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,513,20300,20310,IdentifierMutator-Variable,encodeTable,encode,1,0.14044945,<mask>,"  resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                 "
1546,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,513,20300,20310,IdentifierMutator-Variable,encodeTable,decode,2,0.03432762,<mask>,"  resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                 "
1547,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,513,20300,20310,IdentifierMutator-Variable,encodeTable,buffer,3,0.027771132,<mask>,"  resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                 "
1548,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,513,20300,20310,IdentifierMutator-Variable,encodeTable,encoded,4,0.01158907,<mask>,"  resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                 "
1549,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,513,20300,20310,FieldReferenceMutator,encodeTable,table,0,0.48148024,<mask>,"  resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                 "
1550,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,513,20300,20310,FieldReferenceMutator,encodeTable,encode,1,0.14044945,<mask>,"  resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                 "
1551,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,513,20300,20310,FieldReferenceMutator,encodeTable,decode,2,0.03432762,<mask>,"  resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                 "
1552,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,513,20300,20310,FieldReferenceMutator,encodeTable,buffer,3,0.027771132,<mask>,"  resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                 "
1553,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,513,20300,20310,FieldReferenceMutator,encodeTable,encoded,4,0.01158907,<mask>,"  resizeBuffer();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                 "
1554,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,513,20321,20323,BinaryOperatorMutator,&,|,2,0.0011354018,(x >> 12) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS,"             }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12)<mask>MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        current"
1555,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,513,20321,20323,BinaryOperatorMutator,&,^,3,1.1328529E-4,(x >> 12) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS,"             }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12)<mask>MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        current"
1556,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,513,20321,20323,BinaryOperatorMutator,&,~,4,3.3629418E-5,(x >> 12) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS,"             }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12)<mask>MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        current"
1557,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,513,20314,20317,BinaryOperatorMutator,>>,<<,2,0.052085314,x <mask> 12,"                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x<mask>12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                     "
1558,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,513,20314,20317,BinaryOperatorMutator,>>,>>>,3,0.011910077,x <mask> 12,"                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x<mask>12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                     "
1559,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,513,20314,20317,BinaryOperatorMutator,>>,<<,4,0.00887428,x <mask> 12,"                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x<mask>12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                     "
1560,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,513,20313,20313,IdentifierMutator-Variable,x,y,1,1.0916224E-5,<mask>,"
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                    "
1561,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,513,20313,20313,IdentifierMutator-Variable,x,xx,3,3.9245033E-6,<mask>,"
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                    "
1562,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,513,20313,20313,IdentifierMutator-Variable,x,X,4,2.8354457E-6,<mask>,"
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                    "
1563,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,513,20313,20313,FieldReferenceMutator,x,y,1,1.0916224E-5,<mask>,"
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                    "
1564,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,513,20313,20313,FieldReferenceMutator,x,xx,3,3.9245033E-6,<mask>,"
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                    "
1565,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,513,20313,20313,FieldReferenceMutator,x,X,4,2.8354457E-6,<mask>,"
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                    "
1566,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,513,20318,20319,IdentifierMutator-Literal,12,6,1,0.17941055,<mask>,"               }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                      "
1567,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,513,20318,20319,IdentifierMutator-Literal,12,14,2,0.06264525,<mask>,"               }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                      "
1568,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,513,20318,20319,IdentifierMutator-Literal,12,7,3,0.060345404,<mask>,"               }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                      "
1569,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,513,20318,20319,IdentifierMutator-Literal,12,16,4,0.046771787,<mask>,"               }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                      "
1570,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,513,20324,20333,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,7,0,0.13090064,<mask>,"            }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
"
1571,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,513,20324,20333,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,3,1,0.07710009,<mask>,"            }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
"
1572,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,513,20324,20333,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,mask,2,0.07468237,<mask>,"            }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
"
1573,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,513,20324,20333,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,63,3,0.07388949,<mask>,"            }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
"
1574,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,513,20324,20333,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,1,4,0.056199297,<mask>,"            }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
"
1575,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,513,20324,20333,FieldReferenceMutator,MASK_6BITS,7,0,0.13090064,org.apache.commons.codec.binary.Base64.<mask>,"            }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
"
1576,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,513,20324,20333,FieldReferenceMutator,MASK_6BITS,3,1,0.07710009,org.apache.commons.codec.binary.Base64.<mask>,"            }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
"
1577,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,513,20324,20333,FieldReferenceMutator,MASK_6BITS,mask,2,0.07468237,org.apache.commons.codec.binary.Base64.<mask>,"            }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
"
1578,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,513,20324,20333,FieldReferenceMutator,MASK_6BITS,63,3,0.07388949,org.apache.commons.codec.binary.Base64.<mask>,"            }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
"
1579,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,513,20324,20333,FieldReferenceMutator,MASK_6BITS,1,4,0.056199297,org.apache.commons.codec.binary.Base64.<mask>,"            }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) &<mask>];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
"
1580,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,514,20370,20370,AssignmentMutator,buffer[pos++]=encodeTable[(x>>6)&org.apache.commons.codec.binary.Base64.MASK_6BITS],|,0,0.65121436,buffer[pos++] <mask>= encodeTable[(x >> 6) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
     "
1581,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,514,20370,20370,AssignmentMutator,buffer[pos++]=encodeTable[(x>>6)&org.apache.commons.codec.binary.Base64.MASK_6BITS],^,1,0.21317977,buffer[pos++] <mask>= encodeTable[(x >> 6) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
     "
1582,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,514,20370,20370,AssignmentMutator,buffer[pos++]=encodeTable[(x>>6)&org.apache.commons.codec.binary.Base64.MASK_6BITS],*,2,0.04482653,buffer[pos++] <mask>= encodeTable[(x >> 6) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
     "
1583,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,514,20370,20370,AssignmentMutator,buffer[pos++]=encodeTable[(x>>6)&org.apache.commons.codec.binary.Base64.MASK_6BITS],&,3,0.019286197,buffer[pos++] <mask>= encodeTable[(x >> 6) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
     "
1584,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,514,20370,20370,AssignmentMutator,buffer[pos++]=encodeTable[(x>>6)&org.apache.commons.codec.binary.Base64.MASK_6BITS],||,4,0.007369323,buffer[pos++] <mask>= encodeTable[(x >> 6) & org.apache.commons.codec.binary.Base64.MASK_6BITS],"++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
     "
1585,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,514,20364,20368,ArrayAccessMutator,pos++,pos,0,0.98372895,buffer[<mask>],"ulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
    "
1586,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,514,20364,20368,ArrayAccessMutator,pos++,++,1,0.010866406,buffer[<mask>],"ulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
    "
1587,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,514,20364,20368,ArrayAccessMutator,pos++,push,2,5.2627426E-4,buffer[<mask>],"ulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
    "
1588,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,514,20364,20368,ArrayAccessMutator,pos++,+,3,4.1251088E-4,buffer[<mask>],"ulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
    "
1589,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,514,20364,20368,ArrayAccessMutator,pos++,position,4,2.7012572E-4,buffer[<mask>],"ulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
    "
1590,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,514,20357,20362,IdentifierMutator-Variable,buffer,Buffer,2,0.0017312749,<mask>,"     }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];<mask>[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
 "
1591,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,514,20357,20362,IdentifierMutator-Variable,buffer,byte,3,0.0016420389,<mask>,"     }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];<mask>[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
 "
1592,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,514,20357,20362,IdentifierMutator-Variable,buffer,byte,4,9.167108E-4,<mask>,"     }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];<mask>[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
 "
1593,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,514,20357,20362,FieldReferenceMutator,buffer,Buffer,2,0.0017312749,<mask>,"     }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];<mask>[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
 "
1594,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,514,20357,20362,FieldReferenceMutator,buffer,byte,3,0.0016420389,<mask>,"     }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];<mask>[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
 "
1595,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,514,20357,20362,FieldReferenceMutator,buffer,byte,4,9.167108E-4,<mask>,"     }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];<mask>[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
 "
1596,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,514,20367,20368,UnaryOperatorMutator,++,+,1,1.7133576E-4,pos<mask>," = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos<mask>] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
    "
1597,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,514,20367,20368,UnaryOperatorMutator,++,--,3,7.310897E-5,pos<mask>," = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos<mask>] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
    "
1598,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,514,20367,20368,UnaryOperatorMutator,++,++;,4,7.2908304E-5,pos<mask>," = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos<mask>] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
    "
1599,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,514,20364,20366,IdentifierMutator-Variable,pos,len,1,5.3808442E-5,<mask>,"ulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
   "
1600,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,514,20364,20366,IdentifierMutator-Variable,pos,neg,3,2.9870067E-5,<mask>,"ulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
   "
1601,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,514,20364,20366,IdentifierMutator-Variable,pos,size,4,2.5797883E-5,<mask>,"ulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
   "
1602,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,514,20364,20366,FieldReferenceMutator,pos,len,1,5.3808442E-5,<mask>,"ulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
   "
1603,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,514,20364,20366,FieldReferenceMutator,pos,neg,3,2.9870067E-5,<mask>,"ulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
   "
1604,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,514,20364,20366,FieldReferenceMutator,pos,size,4,2.5797883E-5,<mask>,"ulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
   "
1605,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,514,20385,20405,ArrayAccessMutator,(x>>6)&org.apache.commons.codec.binary.Base64.MASK_6BITS,x,0,0.95006937,encodeTable[<mask>]," % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
    "
1606,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,514,20385,20405,ArrayAccessMutator,(x>>6)&org.apache.commons.codec.binary.Base64.MASK_6BITS,0,1,0.007493759,encodeTable[<mask>]," % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
    "
1607,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,514,20385,20405,ArrayAccessMutator,(x>>6)&org.apache.commons.codec.binary.Base64.MASK_6BITS,xx,2,0.0029070026,encodeTable[<mask>]," % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
    "
1608,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,514,20385,20405,ArrayAccessMutator,(x>>6)&org.apache.commons.codec.binary.Base64.MASK_6BITS,1,3,0.0026921376,encodeTable[<mask>]," % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
    "
1609,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,514,20385,20405,ArrayAccessMutator,(x>>6)&org.apache.commons.codec.binary.Base64.MASK_6BITS,i,4,0.0020907486,encodeTable[<mask>]," % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
    "
1610,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,514,20373,20383,IdentifierMutator-Variable,encodeTable,table,0,0.4588444,<mask>,"modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
        "
1611,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,514,20373,20383,IdentifierMutator-Variable,encodeTable,encode,1,0.08936572,<mask>,"modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
        "
1612,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,514,20373,20383,IdentifierMutator-Variable,encodeTable,buffer,2,0.06389635,<mask>,"modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
        "
1613,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,514,20373,20383,IdentifierMutator-Variable,encodeTable,decode,3,0.030876225,<mask>,"modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
        "
1614,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,514,20373,20383,IdentifierMutator-Variable,encodeTable,code,4,0.010733704,<mask>,"modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
        "
1615,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,514,20373,20383,FieldReferenceMutator,encodeTable,table,0,0.4588444,<mask>,"modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
        "
1616,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,514,20373,20383,FieldReferenceMutator,encodeTable,encode,1,0.08936572,<mask>,"modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
        "
1617,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,514,20373,20383,FieldReferenceMutator,encodeTable,buffer,2,0.06389635,<mask>,"modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
        "
1618,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,514,20373,20383,FieldReferenceMutator,encodeTable,decode,3,0.030876225,<mask>,"modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
        "
1619,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,514,20373,20383,FieldReferenceMutator,encodeTable,code,4,0.010733704,<mask>,"modulus) % 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] =<mask>[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
        "
1620,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,514,20393,20395,BinaryOperatorMutator,&,|,2,0.0015251794,(x >> 6) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS,"               int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6)<mask>MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
               "
1621,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,514,20393,20395,BinaryOperatorMutator,&,^,3,1.3367423E-4,(x >> 6) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS,"               int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6)<mask>MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
               "
1622,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,514,20393,20395,BinaryOperatorMutator,&,~,4,4.563869E-5,(x >> 6) <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS,"               int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6)<mask>MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
               "
1623,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,514,20387,20390,BinaryOperatorMutator,>>,>>>,2,0.014577287,x <mask> 6,";
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x<mask>6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
            "
1624,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,514,20387,20390,BinaryOperatorMutator,>>,<<,3,0.005326201,x <mask> 6,";
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x<mask>6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
            "
1625,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,514,20387,20390,BinaryOperatorMutator,>>,<<,4,0.0021441604,x <mask> 6,";
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x<mask>6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
            "
1626,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,514,20386,20386,IdentifierMutator-Variable,x,y,1,1.4756923E-5,<mask>," 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
           "
1627,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,514,20386,20386,IdentifierMutator-Variable,x,xx,2,8.941584E-6,<mask>," 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
           "
1628,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,514,20386,20386,IdentifierMutator-Variable,x,X,4,4.0363348E-6,<mask>," 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
           "
1629,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,514,20386,20386,FieldReferenceMutator,x,y,1,1.4756923E-5,<mask>," 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
           "
1630,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,514,20386,20386,FieldReferenceMutator,x,xx,2,8.941584E-6,<mask>," 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
           "
1631,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,514,20386,20386,FieldReferenceMutator,x,X,4,4.0363348E-6,<mask>," 3;
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(<mask> >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
           "
1632,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,514,20391,20391,IdentifierMutator-Literal,6,8,1,0.16930921,<mask>,"
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
             "
1633,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,514,20391,20391,IdentifierMutator-Literal,6,7,2,0.07269451,<mask>,"
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
             "
1634,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,514,20391,20391,IdentifierMutator-Literal,6,4,3,0.05644892,<mask>,"
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
             "
1635,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,514,20391,20391,IdentifierMutator-Literal,6,5,4,0.04977193,<mask>,"
                int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >><mask>) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
             "
1636,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,514,20396,20405,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,7,0,0.20099264,<mask>,"              int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) &<mask>];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
    "
1637,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,514,20396,20405,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,1,1,0.091443405,<mask>,"              int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) &<mask>];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
    "
1638,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,514,20396,20405,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,3,2,0.08155483,<mask>,"              int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) &<mask>];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
    "
1639,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,514,20396,20405,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,63,3,0.08051241,<mask>,"              int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) &<mask>];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
    "
1640,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,514,20396,20405,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,6,4,0.06678464,<mask>,"              int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) &<mask>];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
    "
1641,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,514,20396,20405,FieldReferenceMutator,MASK_6BITS,7,0,0.20099264,org.apache.commons.codec.binary.Base64.<mask>,"              int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) &<mask>];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
    "
1642,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,514,20396,20405,FieldReferenceMutator,MASK_6BITS,1,1,0.091443405,org.apache.commons.codec.binary.Base64.<mask>,"              int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) &<mask>];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
    "
1643,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,514,20396,20405,FieldReferenceMutator,MASK_6BITS,3,2,0.08155483,org.apache.commons.codec.binary.Base64.<mask>,"              int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) &<mask>];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
    "
1644,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,514,20396,20405,FieldReferenceMutator,MASK_6BITS,63,3,0.08051241,org.apache.commons.codec.binary.Base64.<mask>,"              int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) &<mask>];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
    "
1645,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,514,20396,20405,FieldReferenceMutator,MASK_6BITS,6,4,0.06678464,org.apache.commons.codec.binary.Base64.<mask>,"              int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) &<mask>];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
    "
1646,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,515,20442,20442,AssignmentMutator,buffer[pos++]=encodeTable[x&org.apache.commons.codec.binary.Base64.MASK_6BITS],|,0,0.64512175,buffer[pos++] <mask>= encodeTable[x & org.apache.commons.codec.binary.Base64.MASK_6BITS],"       if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1647,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,515,20442,20442,AssignmentMutator,buffer[pos++]=encodeTable[x&org.apache.commons.codec.binary.Base64.MASK_6BITS],^,1,0.21509565,buffer[pos++] <mask>= encodeTable[x & org.apache.commons.codec.binary.Base64.MASK_6BITS],"       if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1648,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,515,20442,20442,AssignmentMutator,buffer[pos++]=encodeTable[x&org.apache.commons.codec.binary.Base64.MASK_6BITS],*,2,0.05649529,buffer[pos++] <mask>= encodeTable[x & org.apache.commons.codec.binary.Base64.MASK_6BITS],"       if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1649,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,515,20442,20442,AssignmentMutator,buffer[pos++]=encodeTable[x&org.apache.commons.codec.binary.Base64.MASK_6BITS],&,3,0.012102621,buffer[pos++] <mask>= encodeTable[x & org.apache.commons.codec.binary.Base64.MASK_6BITS],"       if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1650,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,515,20442,20442,AssignmentMutator,buffer[pos++]=encodeTable[x&org.apache.commons.codec.binary.Base64.MASK_6BITS],||,4,0.008375433,buffer[pos++] <mask>= encodeTable[x & org.apache.commons.codec.binary.Base64.MASK_6BITS],"       if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++]<mask>= encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1651,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,515,20436,20440,ArrayAccessMutator,pos++,pos,0,0.9776703,buffer[<mask>],"          if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1652,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,515,20436,20440,ArrayAccessMutator,pos++,++,1,0.008991658,buffer[<mask>],"          if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1653,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,515,20436,20440,ArrayAccessMutator,pos++,len,2,9.916008E-4,buffer[<mask>],"          if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1654,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,515,20436,20440,ArrayAccessMutator,pos++,push,3,6.236473E-4,buffer[<mask>],"          if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1655,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,515,20436,20440,ArrayAccessMutator,pos++,size,4,5.041644E-4,buffer[<mask>],"          if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[<mask>] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1656,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,515,20429,20434,IdentifierMutator-Variable,buffer,in,2,0.0036895804,<mask>,"       int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];<mask>[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1657,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,515,20429,20434,IdentifierMutator-Variable,buffer,out,3,0.0026296019,<mask>,"       int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];<mask>[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1658,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,515,20429,20434,IdentifierMutator-Variable,buffer,Buffer,4,0.0021281603,<mask>,"       int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];<mask>[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1659,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,515,20429,20434,FieldReferenceMutator,buffer,in,2,0.0036895804,<mask>,"       int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];<mask>[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1660,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,515,20429,20434,FieldReferenceMutator,buffer,out,3,0.0026296019,<mask>,"       int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];<mask>[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1661,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,515,20429,20434,FieldReferenceMutator,buffer,Buffer,4,0.0021281603,<mask>,"       int b = in[inPos++];
                if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];<mask>[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1662,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,515,20439,20440,UnaryOperatorMutator,++,+,2,1.21851E-4,pos<mask>,"         if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos<mask>] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1663,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,515,20439,20440,UnaryOperatorMutator,++,++;,3,8.960821E-5,pos<mask>,"         if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos<mask>] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1664,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,515,20439,20440,UnaryOperatorMutator,++,--,4,6.255811E-5,pos<mask>,"         if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos<mask>] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1665,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,515,20436,20438,IdentifierMutator-Variable,pos,len,1,1.621372E-4,<mask>,"          if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1666,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,515,20436,20438,IdentifierMutator-Variable,pos,neg,2,5.3722943E-5,<mask>,"          if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1667,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,515,20436,20438,IdentifierMutator-Variable,pos,size,3,5.3070828E-5,<mask>,"          if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1668,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,515,20436,20438,FieldReferenceMutator,pos,len,1,1.621372E-4,<mask>,"          if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1669,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,515,20436,20438,FieldReferenceMutator,pos,neg,2,5.3722943E-5,<mask>,"          if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1670,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,515,20436,20438,FieldReferenceMutator,pos,size,3,5.3070828E-5,<mask>,"          if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[<mask>++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1671,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,515,20457,20470,ArrayAccessMutator,x&org.apache.commons.codec.binary.Base64.MASK_6BITS,x,0,0.24399617,encodeTable[<mask>],"   if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1672,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,515,20457,20470,ArrayAccessMutator,x&org.apache.commons.codec.binary.Base64.MASK_6BITS,0,1,0.11902633,encodeTable[<mask>],"   if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1673,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,515,20457,20470,ArrayAccessMutator,x&org.apache.commons.codec.binary.Base64.MASK_6BITS,1,2,0.046845116,encodeTable[<mask>],"   if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1674,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,515,20457,20470,ArrayAccessMutator,x&org.apache.commons.codec.binary.Base64.MASK_6BITS,6,3,0.044247672,encodeTable[<mask>],"   if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1675,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,515,20457,20470,ArrayAccessMutator,x&org.apache.commons.codec.binary.Base64.MASK_6BITS,4,4,0.0390516,encodeTable[<mask>],"   if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask>];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1676,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,515,20445,20455,IdentifierMutator-Variable,encodeTable,table,0,0.34797645,<mask>,"      if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] =<mask>[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1677,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,515,20445,20455,IdentifierMutator-Variable,encodeTable,buffer,1,0.14833394,<mask>,"      if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] =<mask>[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1678,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,515,20445,20455,IdentifierMutator-Variable,encodeTable,code,2,0.021642365,<mask>,"      if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] =<mask>[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1679,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,515,20445,20455,IdentifierMutator-Variable,encodeTable,encode,3,0.018327847,<mask>,"      if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] =<mask>[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1680,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,515,20445,20455,IdentifierMutator-Variable,encodeTable,alphabet,4,0.016969493,<mask>,"      if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] =<mask>[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1681,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,515,20445,20455,FieldReferenceMutator,encodeTable,table,0,0.34797645,<mask>,"      if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] =<mask>[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1682,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,515,20445,20455,FieldReferenceMutator,encodeTable,buffer,1,0.14833394,<mask>,"      if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] =<mask>[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1683,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,515,20445,20455,FieldReferenceMutator,encodeTable,code,2,0.021642365,<mask>,"      if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] =<mask>[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1684,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,515,20445,20455,FieldReferenceMutator,encodeTable,encode,3,0.018327847,<mask>,"      if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] =<mask>[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1685,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,515,20445,20455,FieldReferenceMutator,encodeTable,alphabet,4,0.016969493,<mask>,"      if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] =<mask>[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1686,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,515,20458,20460,BinaryOperatorMutator,&,-,2,0.012634097,x <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS,"  if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x<mask>MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1687,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,515,20458,20460,BinaryOperatorMutator,&,+,3,0.0102019785,x <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS,"  if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x<mask>MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1688,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,515,20458,20460,BinaryOperatorMutator,&,<<,4,0.009637333,x <mask> org.apache.commons.codec.binary.Base64.MASK_6BITS,"  if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x<mask>MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1689,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,515,20457,20457,IdentifierMutator-Variable,x,xx,1,7.230686E-4,<mask>,"   if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask> & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1690,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,515,20457,20457,IdentifierMutator-Variable,x,1,2,6.211949E-4,<mask>,"   if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask> & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1691,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,515,20457,20457,IdentifierMutator-Variable,x,y,3,4.0198036E-4,<mask>,"   if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask> & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1692,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,515,20457,20457,IdentifierMutator-Variable,x,0,4,3.4021927E-4,<mask>,"   if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask> & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1693,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,515,20457,20457,FieldReferenceMutator,x,xx,1,7.230686E-4,<mask>,"   if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask> & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1694,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,515,20457,20457,FieldReferenceMutator,x,1,2,6.211949E-4,<mask>,"   if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask> & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1695,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,515,20457,20457,FieldReferenceMutator,x,y,3,4.0198036E-4,<mask>,"   if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask> & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1696,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,515,20457,20457,FieldReferenceMutator,x,0,4,3.4021927E-4,<mask>,"   if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[<mask> & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1697,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,515,20461,20470,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,7,0,0.23924552,<mask>," if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x &<mask>];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1698,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,515,20461,20470,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,63,1,0.16866417,<mask>," if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x &<mask>];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1699,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,515,20461,20470,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,3,2,0.13106935,<mask>," if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x &<mask>];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1700,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,515,20461,20470,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,1,3,0.057394836,<mask>," if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x &<mask>];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1701,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,515,20461,20470,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_6BITS,6,4,0.05220101,<mask>," if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x &<mask>];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1702,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,515,20461,20470,FieldReferenceMutator,MASK_6BITS,7,0,0.23924552,org.apache.commons.codec.binary.Base64.<mask>," if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x &<mask>];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1703,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,515,20461,20470,FieldReferenceMutator,MASK_6BITS,63,1,0.16866417,org.apache.commons.codec.binary.Base64.<mask>," if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x &<mask>];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1704,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,515,20461,20470,FieldReferenceMutator,MASK_6BITS,3,2,0.13106935,org.apache.commons.codec.binary.Base64.<mask>," if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x &<mask>];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1705,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,515,20461,20470,FieldReferenceMutator,MASK_6BITS,1,3,0.057394836,org.apache.commons.codec.binary.Base64.<mask>," if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x &<mask>];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1706,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,515,20461,20470,FieldReferenceMutator,MASK_6BITS,6,4,0.05220101,org.apache.commons.codec.binary.Base64.<mask>," if (b < 0) {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x &<mask>];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1707,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,516,20508,20508,AssignmentMutator,currentLinePos+=4,*,0,0.34029716,currentLinePos <mask>= 4,";
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos<mask>+= 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1708,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,516,20508,20508,AssignmentMutator,currentLinePos+=4,++,1,0.18653326,currentLinePos <mask>= 4,";
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos<mask>+= 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1709,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,516,20508,20508,AssignmentMutator,currentLinePos+=4,*,2,0.12206475,currentLinePos <mask>= 4,";
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos<mask>+= 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1710,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,516,20508,20508,AssignmentMutator,currentLinePos+=4,//,3,0.04192252,currentLinePos <mask>= 4,";
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos<mask>+= 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1711,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,516,20508,20508,AssignmentMutator,currentLinePos+=4,|,4,0.03014381,currentLinePos <mask>= 4,";
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos<mask>+= 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1712,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,516,20494,20507,IdentifierMutator-Variable,currentLinePos,pos,0,0.5798388,<mask>,"
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];<mask> += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1713,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,516,20494,20507,IdentifierMutator-Variable,currentLinePos,pos,1,0.40308696,<mask>,"
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];<mask> += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1714,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,516,20494,20507,IdentifierMutator-Variable,currentLinePos,x,2,0.0028060998,<mask>,"
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];<mask> += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1715,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,516,20494,20507,IdentifierMutator-Variable,currentLinePos,Pos,3,0.0018321931,<mask>,"
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];<mask> += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1716,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,516,20494,20507,IdentifierMutator-Variable,currentLinePos,position,4,0.0013593595,<mask>,"
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];<mask> += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1717,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,516,20494,20507,FieldReferenceMutator,currentLinePos,pos,0,0.5798388,<mask>,"
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];<mask> += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1718,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,516,20494,20507,FieldReferenceMutator,currentLinePos,pos,1,0.40308696,<mask>,"
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];<mask> += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1719,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,516,20494,20507,FieldReferenceMutator,currentLinePos,x,2,0.0028060998,<mask>,"
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];<mask> += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1720,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,516,20494,20507,FieldReferenceMutator,currentLinePos,Pos,3,0.0018321931,<mask>,"
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];<mask> += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1721,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,516,20494,20507,FieldReferenceMutator,currentLinePos,position,4,0.0013593595,<mask>,"
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];<mask> += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1722,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,516,20512,20512,IdentifierMutator-Literal,4,pos,0,0.45371884,<mask>,"
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos +=<mask>;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1723,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,516,20512,20512,IdentifierMutator-Literal,4,1,1,0.22995412,<mask>,"
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos +=<mask>;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1724,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,516,20512,20512,IdentifierMutator-Literal,4,2,2,0.07983624,<mask>,"
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos +=<mask>;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1725,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,516,20512,20512,IdentifierMutator-Literal,4,length,4,0.017705763,<mask>,"
                }
                x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos +=<mask>;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1726,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,517,20553,20556,BinaryOperatorMutator,&&,&,2,0.02042675,(lineLength > 0) <mask> (lineLength <= currentLinePos),"      x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0<mask>lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1727,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,517,20553,20556,BinaryOperatorMutator,&&,AND,3,0.0021275724,(lineLength > 0) <mask> (lineLength <= currentLinePos),"      x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0<mask>lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1728,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,517,20553,20556,BinaryOperatorMutator,&&,and,4,8.8561187E-4,(lineLength > 0) <mask> (lineLength <= currentLinePos),"      x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0<mask>lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1729,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,517,20549,20551,BinaryOperatorMutator,>,!=,2,0.03354259,lineLength <mask> 0,"        x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength<mask>0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1730,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,517,20549,20551,BinaryOperatorMutator,>,==,3,0.023923254,lineLength <mask> 0,"        x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength<mask>0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1731,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,517,20549,20551,BinaryOperatorMutator,>,>=,4,0.009211616,lineLength <mask> 0,"        x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength<mask>0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1732,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,517,20539,20548,IdentifierMutator-Variable,lineLength,pos,0,0.8061634,<mask>,"          x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (<mask> > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1733,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,517,20539,20548,IdentifierMutator-Variable,lineLength,length,1,0.081273995,<mask>,"          x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (<mask> > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1734,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,517,20539,20548,IdentifierMutator-Variable,lineLength,position,2,0.03991801,<mask>,"          x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (<mask> > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1735,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,517,20539,20548,IdentifierMutator-Variable,lineLength,offset,3,0.008178057,<mask>,"          x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (<mask> > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1736,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,517,20539,20548,IdentifierMutator-Variable,lineLength,len,4,0.0050431336,<mask>,"          x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (<mask> > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1737,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,517,20539,20548,FieldReferenceMutator,lineLength,pos,0,0.8061634,<mask>,"          x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (<mask> > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1738,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,517,20539,20548,FieldReferenceMutator,lineLength,length,1,0.081273995,<mask>,"          x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (<mask> > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1739,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,517,20539,20548,FieldReferenceMutator,lineLength,position,2,0.03991801,<mask>,"          x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (<mask> > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1740,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,517,20539,20548,FieldReferenceMutator,lineLength,offset,3,0.008178057,<mask>,"          x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (<mask> > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1741,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,517,20539,20548,FieldReferenceMutator,lineLength,len,4,0.0050431336,<mask>,"          x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (<mask> > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1742,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,517,20552,20552,IdentifierMutator-Literal,0,1,1,0.036307774,<mask>,"       x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength ><mask> && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1743,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,517,20552,20552,IdentifierMutator-Literal,0,2,2,0.005767462,<mask>,"       x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength ><mask> && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1744,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,517,20552,20552,IdentifierMutator-Literal,0,4,3,0.0027120064,<mask>,"       x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength ><mask> && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1745,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,517,20552,20552,IdentifierMutator-Literal,0,pos,4,0.0024671396,<mask>,"       x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength ><mask> && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1746,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,517,20567,20570,BinaryOperatorMutator,<=,<,0,0.39389122,lineLength <mask> currentLinePos,"   x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength<mask>currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1747,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,517,20567,20570,BinaryOperatorMutator,<=,==,1,0.27772817,lineLength <mask> currentLinePos,"   x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength<mask>currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1748,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,517,20567,20570,BinaryOperatorMutator,<=,>,2,0.09517997,lineLength <mask> currentLinePos,"   x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength<mask>currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1749,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,517,20567,20570,BinaryOperatorMutator,<=,<,3,0.07151448,lineLength <mask> currentLinePos,"   x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength<mask>currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1750,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,517,20557,20566,IdentifierMutator-Variable,lineLength,pos,0,0.95054585,<mask>,"     x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 &&<mask> <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1751,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,517,20557,20566,IdentifierMutator-Variable,lineLength,0,1,0.029080542,<mask>,"     x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 &&<mask> <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1752,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,517,20557,20566,IdentifierMutator-Variable,lineLength,position,2,0.0041239043,<mask>,"     x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 &&<mask> <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1753,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,517,20557,20566,IdentifierMutator-Variable,lineLength,start,3,0.0018849447,<mask>,"     x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 &&<mask> <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1754,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,517,20557,20566,IdentifierMutator-Variable,lineLength,1,4,0.0018175166,<mask>,"     x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 &&<mask> <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1755,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,517,20557,20566,FieldReferenceMutator,lineLength,pos,0,0.95054585,<mask>,"     x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 &&<mask> <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1756,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,517,20557,20566,FieldReferenceMutator,lineLength,0,1,0.029080542,<mask>,"     x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 &&<mask> <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1757,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,517,20557,20566,FieldReferenceMutator,lineLength,position,2,0.0041239043,<mask>,"     x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 &&<mask> <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1758,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,517,20557,20566,FieldReferenceMutator,lineLength,start,3,0.0018849447,<mask>,"     x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 &&<mask> <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1759,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,517,20557,20566,FieldReferenceMutator,lineLength,1,4,0.0018175166,<mask>,"     x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 &&<mask> <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1760,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,517,20571,20584,IdentifierMutator-Variable,currentLinePos,256,0,0.08368058,<mask>,"  x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <=<mask>) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1761,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,517,20571,20584,IdentifierMutator-Variable,currentLinePos,255,1,0.05682104,<mask>,"  x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <=<mask>) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1762,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,517,20571,20584,IdentifierMutator-Variable,currentLinePos,1,2,0.044809103,<mask>,"  x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <=<mask>) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1763,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,517,20571,20584,IdentifierMutator-Variable,currentLinePos,127,3,0.03487211,<mask>,"  x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <=<mask>) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1764,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,517,20571,20584,IdentifierMutator-Variable,currentLinePos,4,4,0.030467179,<mask>,"  x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <=<mask>) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1765,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,517,20571,20584,FieldReferenceMutator,currentLinePos,256,0,0.08368058,<mask>,"  x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <=<mask>) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1766,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,517,20571,20584,FieldReferenceMutator,currentLinePos,255,1,0.05682104,<mask>,"  x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <=<mask>) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1767,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,517,20571,20584,FieldReferenceMutator,currentLinePos,1,2,0.044809103,<mask>,"  x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <=<mask>) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1768,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,517,20571,20584,FieldReferenceMutator,currentLinePos,127,3,0.03487211,<mask>,"  x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <=<mask>) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1769,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,517,20571,20584,FieldReferenceMutator,currentLinePos,4,4,0.030467179,<mask>,"  x = (x << 8) + b;
                if (0 == modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <=<mask>) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1770,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,518,20620,20628,MethodCallMutator,arraycopy,copy,0,0.44838908,"System.<mask>(lineSeparator, 0, buffer, pos, lineSeparator.length)"," modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.<mask>(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1771,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,518,20620,20628,MethodCallMutator,arraycopy,printf,1,0.27453634,"System.<mask>(lineSeparator, 0, buffer, pos, lineSeparator.length)"," modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.<mask>(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1772,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,518,20620,20628,MethodCallMutator,arraycopy,format,2,0.103110895,"System.<mask>(lineSeparator, 0, buffer, pos, lineSeparator.length)"," modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.<mask>(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1773,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,518,20620,20628,MethodCallMutator,arraycopy,write,3,0.034942545,"System.<mask>(lineSeparator, 0, buffer, pos, lineSeparator.length)"," modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.<mask>(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1774,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,518,20620,20628,MethodCallMutator,arraycopy,replace,4,0.014357003,"System.<mask>(lineSeparator, 0, buffer, pos, lineSeparator.length)"," modulus) {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.<mask>(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1775,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,518,20630,20642,IdentifierMutator-Variable,lineSeparator,buffer,0,0.8169459,<mask>," {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(<mask>, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1776,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,518,20630,20642,IdentifierMutator-Variable,lineSeparator,line,1,0.04690348,<mask>," {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(<mask>, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1777,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,518,20630,20642,IdentifierMutator-Variable,lineSeparator,lines,2,0.021744726,<mask>," {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(<mask>, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1778,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,518,20630,20642,IdentifierMutator-Variable,lineSeparator,buf,3,0.009267252,<mask>," {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(<mask>, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1779,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,518,20630,20642,IdentifierMutator-Variable,lineSeparator,string,4,0.008680807,<mask>," {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(<mask>, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1780,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,518,20630,20642,FieldReferenceMutator,lineSeparator,buffer,0,0.8169459,<mask>," {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(<mask>, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1781,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,518,20630,20642,FieldReferenceMutator,lineSeparator,line,1,0.04690348,<mask>," {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(<mask>, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1782,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,518,20630,20642,FieldReferenceMutator,lineSeparator,lines,2,0.021744726,<mask>," {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(<mask>, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1783,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,518,20630,20642,FieldReferenceMutator,lineSeparator,buf,3,0.009267252,<mask>," {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(<mask>, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1784,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,518,20630,20642,FieldReferenceMutator,lineSeparator,string,4,0.008680807,<mask>," {
                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(<mask>, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1785,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,518,20645,20645,IdentifierMutator-Literal,0,1,2,0.0038664232,<mask>,"                 buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator,<mask>, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1786,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,518,20645,20645,IdentifierMutator-Literal,0,pos,3,0.0010919744,<mask>,"                 buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator,<mask>, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1787,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,518,20645,20645,IdentifierMutator-Literal,0,4,4,0.0010349891,<mask>,"                 buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator,<mask>, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1788,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,518,20648,20653,IdentifierMutator-Variable,buffer,line,2,3.8841917E-4,<mask>,"               buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0,<mask>, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1789,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,518,20648,20653,IdentifierMutator-Variable,buffer,buf,3,1.9171674E-4,<mask>,"               buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0,<mask>, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1790,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,518,20648,20653,IdentifierMutator-Variable,buffer,source,4,1.4794039E-4,<mask>,"               buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0,<mask>, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1791,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,518,20648,20653,FieldReferenceMutator,buffer,line,2,3.8841917E-4,<mask>,"               buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0,<mask>, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1792,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,518,20648,20653,FieldReferenceMutator,buffer,buf,3,1.9171674E-4,<mask>,"               buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0,<mask>, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1793,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,518,20648,20653,FieldReferenceMutator,buffer,source,4,1.4794039E-4,<mask>,"               buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0,<mask>, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1794,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,518,20656,20658,IdentifierMutator-Variable,pos,0,1,0.01524594,<mask>,"             buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer,<mask>, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1795,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,518,20656,20658,IdentifierMutator-Variable,pos,1,3,0.001386155,<mask>,"             buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer,<mask>, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1796,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,518,20656,20658,IdentifierMutator-Variable,pos,position,4,7.9083163E-4,<mask>,"             buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer,<mask>, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1797,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,518,20656,20658,FieldReferenceMutator,pos,0,1,0.01524594,<mask>,"             buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer,<mask>, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1798,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,518,20656,20658,FieldReferenceMutator,pos,1,3,0.001386155,<mask>,"             buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer,<mask>, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1799,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,518,20656,20658,FieldReferenceMutator,pos,position,4,7.9083163E-4,<mask>,"             buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer,<mask>, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1800,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,518,20661,20680,IdentifierMutator-Variable,lineSeparator.length,len,0,0.40724584,<mask>,"           buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos,<mask>);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1801,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,518,20661,20680,IdentifierMutator-Variable,lineSeparator.length,length,1,0.1738978,<mask>,"           buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos,<mask>);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1802,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,518,20661,20680,IdentifierMutator-Variable,lineSeparator.length,4,2,0.07947996,<mask>,"           buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos,<mask>);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1803,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,518,20661,20680,IdentifierMutator-Variable,lineSeparator.length,n,3,0.040844593,<mask>,"           buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos,<mask>);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1804,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,518,20661,20680,IdentifierMutator-Variable,lineSeparator.length,line,4,0.025696028,<mask>,"           buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos,<mask>);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1805,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,518,20661,20673,IdentifierMutator-Variable,lineSeparator,buffer,0,0.9938554,<mask>,"           buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos,<mask>.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1806,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,518,20661,20673,IdentifierMutator-Variable,lineSeparator,buffer,1,0.002136814,<mask>,"           buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos,<mask>.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1807,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,518,20661,20673,IdentifierMutator-Variable,lineSeparator,line,2,0.0013068112,<mask>,"           buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos,<mask>.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1808,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,518,20661,20673,IdentifierMutator-Variable,lineSeparator,buf,3,3.138145E-4,<mask>,"           buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos,<mask>.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1809,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,518,20661,20673,IdentifierMutator-Variable,lineSeparator,text,4,1.8696343E-4,<mask>,"           buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos,<mask>.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1810,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,518,20661,20673,FieldReferenceMutator,lineSeparator,buffer,0,0.9938554,<mask>,"           buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos,<mask>.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1811,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,518,20661,20673,FieldReferenceMutator,lineSeparator,buffer,1,0.002136814,<mask>,"           buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos,<mask>.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1812,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,518,20661,20673,FieldReferenceMutator,lineSeparator,line,2,0.0013068112,<mask>,"           buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos,<mask>.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1813,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,518,20661,20673,FieldReferenceMutator,lineSeparator,buf,3,3.138145E-4,<mask>,"           buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos,<mask>.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1814,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,518,20661,20673,FieldReferenceMutator,lineSeparator,text,4,1.8696343E-4,<mask>,"           buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos,<mask>.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1815,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,518,20675,20680,FieldReferenceMutator,length,len,1,2.4772357E-4,lineSeparator.<mask>,"      buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.<mask>);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1816,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,518,20675,20680,FieldReferenceMutator,length,position,2,4.939695E-5,lineSeparator.<mask>,"      buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.<mask>);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1817,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,518,20675,20680,FieldReferenceMutator,length,count,3,2.6590738E-5,lineSeparator.<mask>,"      buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.<mask>);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1818,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,519,20711,20711,AssignmentMutator,pos+=lineSeparator.length,++,0,0.9640786,pos <mask>= lineSeparator.length,"
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos<mask>+= lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1819,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,519,20711,20711,AssignmentMutator,pos+=lineSeparator.length,+,1,0.008239496,pos <mask>= lineSeparator.length,"
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos<mask>+= lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1820,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,519,20711,20711,AssignmentMutator,pos+=lineSeparator.length,++,2,0.0036510515,pos <mask>= lineSeparator.length,"
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos<mask>+= lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1821,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,519,20711,20711,AssignmentMutator,pos+=lineSeparator.length,*,3,0.003487082,pos <mask>= lineSeparator.length,"
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos<mask>+= lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1822,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,519,20711,20711,AssignmentMutator,pos+=lineSeparator.length,+,4,0.0025446527,pos <mask>= lineSeparator.length,"
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos<mask>+= lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1823,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,519,20708,20710,IdentifierMutator-Variable,pos,position,2,0.0014238023,<mask>,"    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);<mask> += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1824,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,519,20708,20710,IdentifierMutator-Variable,pos,Pos,3,4.3400706E-4,<mask>,"    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);<mask> += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1825,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,519,20708,20710,IdentifierMutator-Variable,pos,offset,4,8.658397E-5,<mask>,"    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);<mask> += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1826,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,519,20708,20710,FieldReferenceMutator,pos,position,2,0.0014238023,<mask>,"    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);<mask> += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1827,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,519,20708,20710,FieldReferenceMutator,pos,Pos,3,4.3400706E-4,<mask>,"    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);<mask> += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1828,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,519,20708,20710,FieldReferenceMutator,pos,offset,4,8.658397E-5,<mask>,"    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);<mask> += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1829,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,519,20715,20734,IdentifierMutator-Variable,lineSeparator.length,4,0,0.79304135,<mask>,"                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos +=<mask>;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1830,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,519,20715,20734,IdentifierMutator-Variable,lineSeparator.length,2,1,0.054201618,<mask>,"                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos +=<mask>;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1831,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,519,20715,20734,IdentifierMutator-Variable,lineSeparator.length,5,2,0.023471013,<mask>,"                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos +=<mask>;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1832,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,519,20715,20734,IdentifierMutator-Variable,lineSeparator.length,1,3,0.022097014,<mask>,"                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos +=<mask>;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1833,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,519,20715,20734,IdentifierMutator-Variable,lineSeparator.length,3,4,0.020625181,<mask>,"                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos +=<mask>;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1834,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,519,20715,20727,IdentifierMutator-Variable,lineSeparator,buffer,0,0.97794867,<mask>,"                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos +=<mask>.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1835,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,519,20715,20727,IdentifierMutator-Variable,lineSeparator,line,1,0.007852801,<mask>,"                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos +=<mask>.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1836,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,519,20715,20727,IdentifierMutator-Variable,lineSeparator,buf,2,0.0023001505,<mask>,"                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos +=<mask>.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1837,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,519,20715,20727,IdentifierMutator-Variable,lineSeparator,text,3,0.0010461648,<mask>,"                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos +=<mask>.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1838,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,519,20715,20727,IdentifierMutator-Variable,lineSeparator,code,4,3.7937233E-4,<mask>,"                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos +=<mask>.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1839,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,519,20715,20727,FieldReferenceMutator,lineSeparator,buffer,0,0.97794867,<mask>,"                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos +=<mask>.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1840,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,519,20715,20727,FieldReferenceMutator,lineSeparator,line,1,0.007852801,<mask>,"                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos +=<mask>.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1841,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,519,20715,20727,FieldReferenceMutator,lineSeparator,buf,2,0.0023001505,<mask>,"                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos +=<mask>.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1842,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,519,20715,20727,FieldReferenceMutator,lineSeparator,text,3,0.0010461648,<mask>,"                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos +=<mask>.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1843,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,519,20715,20727,FieldReferenceMutator,lineSeparator,code,4,3.7937233E-4,<mask>,"                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos +=<mask>.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1844,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,519,20729,20734,FieldReferenceMutator,length,position,1,1.9497819E-4,lineSeparator.<mask>,"               buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.<mask>;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1845,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,519,20729,20734,FieldReferenceMutator,length,len,2,1.6991064E-4,lineSeparator.<mask>,"               buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.<mask>;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1846,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,519,20729,20734,FieldReferenceMutator,length,width,4,2.8037513E-5,lineSeparator.<mask>,"               buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.<mask>;
                        currentLinePos = 0;
                    }
                }
            }
        }
   "
1847,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,520,20775,20775,AssignmentMutator,currentLinePos=0,*,0,0.4809754,currentLinePos <mask>= 0," MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos<mask>= 0;
                    }
                }
            }
        }
   "
1848,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,520,20775,20775,AssignmentMutator,currentLinePos=0,||,1,0.19663772,currentLinePos <mask>= 0," MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos<mask>= 0;
                    }
                }
            }
        }
   "
1849,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,520,20775,20775,AssignmentMutator,currentLinePos=0,^,2,0.08168908,currentLinePos <mask>= 0," MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos<mask>= 0;
                    }
                }
            }
        }
   "
1850,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,520,20775,20775,AssignmentMutator,currentLinePos=0,|,3,0.079475954,currentLinePos <mask>= 0," MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos<mask>= 0;
                    }
                }
            }
        }
   "
1851,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,520,20775,20775,AssignmentMutator,currentLinePos=0,>>,4,0.02047174,currentLinePos <mask>= 0," MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos<mask>= 0;
                    }
                }
            }
        }
   "
1852,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,520,20761,20774,IdentifierMutator-Variable,currentLinePos,buffer,0,0.2174502,<mask>,"             buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;<mask> = 0;
                    }
                }
            }
        }
   "
1853,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,520,20761,20774,IdentifierMutator-Variable,currentLinePos,line,1,0.09240584,<mask>,"             buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;<mask> = 0;
                    }
                }
            }
        }
   "
1854,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,520,20761,20774,IdentifierMutator-Variable,currentLinePos,pos,2,0.078489065,<mask>,"             buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;<mask> = 0;
                    }
                }
            }
        }
   "
1855,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,520,20761,20774,IdentifierMutator-Variable,currentLinePos,buf,3,0.03820603,<mask>,"             buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;<mask> = 0;
                    }
                }
            }
        }
   "
1856,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,520,20761,20774,IdentifierMutator-Variable,currentLinePos,length,4,0.03634959,<mask>,"             buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;<mask> = 0;
                    }
                }
            }
        }
   "
1857,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,520,20761,20774,FieldReferenceMutator,currentLinePos,buffer,0,0.2174502,<mask>,"             buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;<mask> = 0;
                    }
                }
            }
        }
   "
1858,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,520,20761,20774,FieldReferenceMutator,currentLinePos,line,1,0.09240584,<mask>,"             buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;<mask> = 0;
                    }
                }
            }
        }
   "
1859,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,520,20761,20774,FieldReferenceMutator,currentLinePos,pos,2,0.078489065,<mask>,"             buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;<mask> = 0;
                    }
                }
            }
        }
   "
1860,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,520,20761,20774,FieldReferenceMutator,currentLinePos,buf,3,0.03820603,<mask>,"             buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;<mask> = 0;
                    }
                }
            }
        }
   "
1861,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,520,20761,20774,FieldReferenceMutator,currentLinePos,length,4,0.03634959,<mask>,"             buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;<mask> = 0;
                    }
                }
            }
        }
   "
1862,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,520,20778,20778,IdentifierMutator-Literal,0,pos,0,0.9606277,<mask>,"K_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos =<mask>;
                    }
                }
            }
        }
   "
1863,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,520,20778,20778,IdentifierMutator-Literal,0,position,2,0.0030007649,<mask>,"K_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos =<mask>;
                    }
                }
            }
        }
   "
1864,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,520,20778,20778,IdentifierMutator-Literal,0,index,3,9.940353E-4,<mask>,"K_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos =<mask>;
                    }
                }
            }
        }
   "
1865,Base64.java,encode,"void encode(byte[] in, int inPos, int inAvail)",464,520,20778,20778,IdentifierMutator-Literal,0,i,4,7.2437775E-4,<mask>,"K_6BITS];
                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];
                    buffer[pos++] = encodeTable[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos) {
                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos =<mask>;
                    }
                }
            }
        }
   "
1866,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,551,22056,22058,IdentifierMutator-Variable,eof,done,0,0.30600673,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (<mask>) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1867,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,551,22056,22058,IdentifierMutator-Variable,eof,finished,1,0.1257539,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (<mask>) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1868,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,551,22056,22058,IdentifierMutator-Variable,eof,stop,2,0.07442391,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (<mask>) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1869,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,551,22056,22058,IdentifierMutator-Variable,eof,exit,3,0.050556906,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (<mask>) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1870,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,551,22056,22058,IdentifierMutator-Variable,eof,end,4,0.04960955,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (<mask>) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1871,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,551,22056,22058,FieldReferenceMutator,eof,done,0,0.30600673,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (<mask>) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1872,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,551,22056,22058,FieldReferenceMutator,eof,finished,1,0.1257539,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (<mask>) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1873,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,551,22056,22058,FieldReferenceMutator,eof,stop,2,0.07442391,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (<mask>) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1874,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,551,22056,22058,FieldReferenceMutator,eof,exit,3,0.050556906,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (<mask>) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1875,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,551,22056,22058,FieldReferenceMutator,eof,end,4,0.04960955,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (<mask>) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1876,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,554,22112,22114,BinaryOperatorMutator,<,==,0,0.223451,inAvail <mask> 0,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail<mask>0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1877,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,554,22112,22114,BinaryOperatorMutator,<,==,1,0.21845761,inAvail <mask> 0,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail<mask>0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1878,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,554,22112,22114,BinaryOperatorMutator,<,>,2,0.21460688,inAvail <mask> 0,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail<mask>0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1879,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,554,22112,22114,BinaryOperatorMutator,<,<=,4,0.08764514,inAvail <mask> 0,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail<mask>0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1880,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,554,22105,22111,IdentifierMutator-Variable,inAvail,pos,0,0.6025664,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (<mask> < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                       "
1881,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,554,22105,22111,IdentifierMutator-Variable,inAvail,i,1,0.060962595,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (<mask> < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                       "
1882,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,554,22105,22111,IdentifierMutator-Variable,inAvail,offset,2,0.01839406,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (<mask> < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                       "
1883,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,554,22105,22111,IdentifierMutator-Variable,inAvail,position,3,0.013375317,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (<mask> < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                       "
1884,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,554,22105,22111,IdentifierMutator-Variable,inAvail,b,4,0.012427245,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (<mask> < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                       "
1885,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,554,22115,22115,IdentifierMutator-Literal,0,1,1,0.04096003,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail <<mask>) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1886,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,554,22115,22115,IdentifierMutator-Literal,0,pos,2,0.017515754,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail <<mask>) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1887,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,554,22115,22115,IdentifierMutator-Literal,0,2,3,0.0140517065,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail <<mask>) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1888,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,554,22115,22115,IdentifierMutator-Literal,0,i,4,0.012964744,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail <<mask>) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1889,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,555,22135,22135,AssignmentMutator,eof=true,|,0,0.9368005,eof <mask>= true,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof<mask>= true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                    "
1890,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,555,22135,22135,AssignmentMutator,eof=true,&,1,0.03523596,eof <mask>= true,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof<mask>= true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                    "
1891,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,555,22135,22135,AssignmentMutator,eof=true,||,2,0.0063775703,eof <mask>= true,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof<mask>= true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                    "
1892,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,555,22135,22135,AssignmentMutator,eof=true,^,3,0.0046112183,eof <mask>= true,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof<mask>= true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                    "
1893,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,555,22135,22135,AssignmentMutator,eof=true,!,4,0.0037213026,eof <mask>= true,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof<mask>= true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                    "
1894,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,555,22132,22134,IdentifierMutator-Variable,eof,done,0,0.5852882,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {<mask> = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = ("
1895,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,555,22132,22134,IdentifierMutator-Variable,eof,finished,1,0.081278555,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {<mask> = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = ("
1896,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,555,22132,22134,IdentifierMutator-Variable,eof,end,2,0.034523726,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {<mask> = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = ("
1897,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,555,22132,22134,IdentifierMutator-Variable,eof,ended,3,0.029406138,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {<mask> = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = ("
1898,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,555,22132,22134,IdentifierMutator-Variable,eof,closed,4,0.027027369,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {<mask> = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = ("
1899,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,555,22132,22134,FieldReferenceMutator,eof,done,0,0.5852882,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {<mask> = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = ("
1900,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,555,22132,22134,FieldReferenceMutator,eof,finished,1,0.081278555,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {<mask> = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = ("
1901,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,555,22132,22134,FieldReferenceMutator,eof,end,2,0.034523726,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {<mask> = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = ("
1902,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,555,22132,22134,FieldReferenceMutator,eof,ended,3,0.029406138,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {<mask> = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = ("
1903,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,555,22132,22134,FieldReferenceMutator,eof,closed,4,0.027027369,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {<mask> = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = ("
1904,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,555,22138,22141,IdentifierMutator-Literal,true,false,1,0.028067522,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof =<mask>;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1905,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,555,22138,22141,IdentifierMutator-Literal,true,TRUE,3,1.3249651E-4,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof =<mask>;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1906,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,555,22138,22141,IdentifierMutator-Literal,true,1,4,9.629265E-5,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof =<mask>;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1907,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,557,22175,22175,IdentifierMutator-Literal,0,pos,1,0.08268388,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i =<mask>; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1908,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,557,22175,22175,IdentifierMutator-Literal,0,1,2,0.006390756,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i =<mask>; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1909,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,557,22175,22175,IdentifierMutator-Literal,0,offset,4,0.001435486,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i =<mask>; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1910,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,557,22179,22181,BinaryOperatorMutator,<,<=,2,0.0032129693,i <mask> inAvail,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i<mask>inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1911,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,557,22179,22181,BinaryOperatorMutator,<,++,3,0.0017119371,i <mask> inAvail,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i<mask>inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1912,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,557,22179,22181,BinaryOperatorMutator,<,+,4,4.137092E-4,i <mask> inAvail,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i<mask>inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1913,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,557,22178,22178,IdentifierMutator-Variable,i,pos,2,0.0014674164,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0;<mask> < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1914,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,557,22178,22178,IdentifierMutator-Variable,i,j,3,1.1250476E-4,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0;<mask> < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1915,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,557,22178,22178,IdentifierMutator-Variable,i,0,4,1.07833E-4,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0;<mask> < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1916,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,557,22182,22188,IdentifierMutator-Variable,inAvail,n,0,0.14292932,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i <<mask>; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                       "
1917,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,557,22182,22188,IdentifierMutator-Variable,inAvail,size,1,0.115542,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i <<mask>; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                       "
1918,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,557,22182,22188,IdentifierMutator-Variable,inAvail,len,2,0.1027158,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i <<mask>; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                       "
1919,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,557,22182,22188,IdentifierMutator-Variable,inAvail,pos,3,0.07468494,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i <<mask>; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                       "
1920,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,557,22182,22188,IdentifierMutator-Variable,inAvail,limit,4,0.072005756,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i <<mask>; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                       "
1921,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,557,22192,22193,UnaryOperatorMutator,++,++),2,0.0037155217,i<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i<mask>) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                    "
1922,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,557,22192,22193,UnaryOperatorMutator,++,++;,3,3.471651E-4,i<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i<mask>) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                    "
1923,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,557,22192,22193,UnaryOperatorMutator,++,--,4,2.0901115E-4,i<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i<mask>) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                    "
1924,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,557,22191,22191,IdentifierMutator-Variable,i,++,2,1.087855E-4,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail;<mask>++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1925,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,557,22191,22191,IdentifierMutator-Variable,i,I,3,5.2334315E-5,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail;<mask>++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1926,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,557,22191,22191,IdentifierMutator-Variable,i,j,4,5.0137125E-5,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail;<mask>++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1927,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,558,22228,22231,BinaryOperatorMutator,||,|,2,0.009832157,(buffer == null) <mask> ((buffer.length - pos) < decodeSize),"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null<mask>buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1928,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,558,22228,22231,BinaryOperatorMutator,||,.,3,0.008927607,(buffer == null) <mask> ((buffer.length - pos) < decodeSize),"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null<mask>buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1929,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,558,22228,22231,BinaryOperatorMutator,||,?,4,0.0031648385,(buffer == null) <mask> ((buffer.length - pos) < decodeSize),"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null<mask>buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1930,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,558,22220,22223,BinaryOperatorMutator,==,=,2,0.009059136,buffer <mask> null,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer<mask>null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1931,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,558,22220,22223,BinaryOperatorMutator,==,===,3,0.0014111465,buffer <mask> null,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer<mask>null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1932,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,558,22220,22223,BinaryOperatorMutator,==,!=,4,6.824041E-4,buffer <mask> null,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer<mask>null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1933,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,558,22214,22219,IdentifierMutator-Variable,buffer,Buffer,2,0.0018047302,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (<mask> == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1934,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,558,22214,22219,IdentifierMutator-Variable,buffer,buf,3,9.906832E-4,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (<mask> == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1935,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,558,22214,22219,IdentifierMutator-Variable,buffer,queue,4,5.849453E-4,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (<mask> == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1936,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,558,22214,22219,FieldReferenceMutator,buffer,Buffer,2,0.0018047302,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (<mask> == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1937,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,558,22214,22219,FieldReferenceMutator,buffer,buf,3,9.906832E-4,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (<mask> == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1938,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,558,22214,22219,FieldReferenceMutator,buffer,queue,4,5.849453E-4,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (<mask> == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1939,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,558,22224,22227,IdentifierMutator-Literal,null,nil,1,0.0012571932,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer ==<mask> || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1940,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,558,22224,22227,IdentifierMutator-Literal,null,NULL,2,0.0010901536,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer ==<mask> || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1941,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,558,22224,22227,IdentifierMutator-Literal,null,undefined,4,2.1016036E-4,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer ==<mask> || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1942,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,558,22251,22253,BinaryOperatorMutator,<,>,1,0.2302898,(buffer.length - pos) <mask> decodeSize,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos<mask>decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                    "
1943,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,558,22251,22253,BinaryOperatorMutator,<,>,3,0.09603589,(buffer.length - pos) <mask> decodeSize,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos<mask>decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                    "
1944,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,558,22251,22253,BinaryOperatorMutator,<,>=,4,0.0836145,(buffer.length - pos) <mask> decodeSize,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos<mask>decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                    "
1945,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,558,22245,22247,BinaryOperatorMutator,-,*,1,0.19134657,buffer.length <mask> pos,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length<mask>pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1946,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,558,22245,22247,BinaryOperatorMutator,-,+,2,0.15388948,buffer.length <mask> pos,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length<mask>pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1947,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,558,22245,22247,BinaryOperatorMutator,-,_,3,0.052787326,buffer.length <mask> pos,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length<mask>pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1948,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,558,22245,22247,BinaryOperatorMutator,-,/,4,0.035744138,buffer.length <mask> pos,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length<mask>pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1949,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,558,22232,22244,IdentifierMutator-Variable,buffer.length,i,0,0.5350913,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null ||<mask> - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                       "
1950,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,558,22232,22244,IdentifierMutator-Variable,buffer.length,size,1,0.09398828,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null ||<mask> - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                       "
1951,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,558,22232,22244,IdentifierMutator-Variable,buffer.length,limit,2,0.040866785,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null ||<mask> - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                       "
1952,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,558,22232,22244,IdentifierMutator-Variable,buffer.length,length,3,0.03957807,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null ||<mask> - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                       "
1953,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,558,22232,22244,IdentifierMutator-Variable,buffer.length,buffer,4,0.020405691,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null ||<mask> - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                       "
1954,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,558,22232,22237,IdentifierMutator-Variable,buffer,in,1,0.06961245,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null ||<mask>.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1955,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,558,22232,22237,IdentifierMutator-Variable,buffer,buf,2,0.0075013856,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null ||<mask>.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1956,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,558,22232,22237,IdentifierMutator-Variable,buffer,input,3,0.002350563,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null ||<mask>.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1957,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,558,22232,22237,IdentifierMutator-Variable,buffer,out,4,0.0018378728,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null ||<mask>.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1958,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,558,22232,22237,FieldReferenceMutator,buffer,in,1,0.06961245,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null ||<mask>.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1959,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,558,22232,22237,FieldReferenceMutator,buffer,buf,2,0.0075013856,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null ||<mask>.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1960,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,558,22232,22237,FieldReferenceMutator,buffer,input,3,0.002350563,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null ||<mask>.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1961,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,558,22232,22237,FieldReferenceMutator,buffer,out,4,0.0018378728,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null ||<mask>.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1962,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,558,22239,22244,FieldReferenceMutator,length,position,1,0.002160781,buffer.<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.<mask> - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1963,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,558,22239,22244,FieldReferenceMutator,length,size,2,0.0020418996,buffer.<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.<mask> - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1964,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,558,22239,22244,FieldReferenceMutator,length,len,3,0.0015271057,buffer.<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.<mask> - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1965,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,558,22239,22244,FieldReferenceMutator,length,read,4,8.278441E-4,buffer.<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.<mask> - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1966,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,558,22248,22250,IdentifierMutator-Variable,pos,i,0,0.9898303,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length -<mask> < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1967,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,558,22248,22250,IdentifierMutator-Variable,pos,1,1,0.0022602202,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length -<mask> < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1968,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,558,22248,22250,IdentifierMutator-Variable,pos,i,2,9.841333E-4,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length -<mask> < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1969,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,558,22248,22250,IdentifierMutator-Variable,pos,8,3,9.110976E-4,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length -<mask> < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1970,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,558,22248,22250,IdentifierMutator-Variable,pos,index,4,5.5149256E-4,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length -<mask> < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1971,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,558,22248,22250,FieldReferenceMutator,pos,i,0,0.9898303,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length -<mask> < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1972,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,558,22248,22250,FieldReferenceMutator,pos,1,1,0.0022602202,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length -<mask> < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1973,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,558,22248,22250,FieldReferenceMutator,pos,i,2,9.841333E-4,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length -<mask> < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1974,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,558,22248,22250,FieldReferenceMutator,pos,8,3,9.110976E-4,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length -<mask> < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1975,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,558,22248,22250,FieldReferenceMutator,pos,index,4,5.5149256E-4,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length -<mask> < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1976,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,558,22254,22263,IdentifierMutator-Variable,decodeSize,0,0,0.38190857,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1977,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,558,22254,22263,IdentifierMutator-Variable,decodeSize,limit,1,0.1105233,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1978,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,558,22254,22263,IdentifierMutator-Variable,decodeSize,i,2,0.11033225,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1979,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,558,22254,22263,IdentifierMutator-Variable,decodeSize,len,3,0.047684494,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1980,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,558,22254,22263,IdentifierMutator-Variable,decodeSize,size,4,0.026908359,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1981,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,558,22254,22263,FieldReferenceMutator,decodeSize,0,0,0.38190857,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1982,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,558,22254,22263,FieldReferenceMutator,decodeSize,limit,1,0.1105233,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1983,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,558,22254,22263,FieldReferenceMutator,decodeSize,i,2,0.11033225,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1984,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,558,22254,22263,FieldReferenceMutator,decodeSize,len,3,0.047684494,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1985,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,558,22254,22263,FieldReferenceMutator,decodeSize,size,4,0.026908359,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
1986,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,559,22284,22295,MethodCallMutator,resizeBuffer,close,0,0.3517236,<mask>(),"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {<mask>();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x"
1987,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,559,22284,22295,MethodCallMutator,resizeBuffer,flush,1,0.14769296,<mask>(),"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {<mask>();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x"
1988,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,559,22284,22295,MethodCallMutator,resizeBuffer,decode,2,0.052173354,<mask>(),"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {<mask>();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x"
1989,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,559,22284,22295,MethodCallMutator,resizeBuffer,break,3,0.038577206,<mask>(),"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {<mask>();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x"
1990,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,559,22284,22295,MethodCallMutator,resizeBuffer,complete,4,0.028946027,<mask>(),"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {<mask>();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x"
1991,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,561,22338,22344,ArrayAccessMutator,inPos++,i,0,0.6254486,in[<mask>],"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[<mask>];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                       "
1992,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,561,22338,22344,ArrayAccessMutator,inPos++,pos,1,0.35539037,in[<mask>],"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[<mask>];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                       "
1993,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,561,22338,22344,ArrayAccessMutator,inPos++,0,2,0.0029729423,in[<mask>],"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[<mask>];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                       "
1994,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,561,22338,22344,ArrayAccessMutator,inPos++,p,3,9.37085E-4,in[<mask>],"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[<mask>];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                       "
1995,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,561,22338,22344,ArrayAccessMutator,inPos++,Pos,4,8.155088E-4,in[<mask>],"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[<mask>];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                       "
1996,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,561,22335,22336,IdentifierMutator-Variable,in,buffer,1,0.037988707,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b =<mask>[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1997,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,561,22335,22336,IdentifierMutator-Variable,in,bytes,2,0.023616761,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b =<mask>[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1998,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,561,22335,22336,IdentifierMutator-Variable,in,input,3,0.016035194,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b =<mask>[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
1999,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,561,22335,22336,IdentifierMutator-Variable,in,data,4,0.012918302,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b =<mask>[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
2000,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,561,22343,22344,UnaryOperatorMutator,++,--,2,9.3166454E-4,inPos<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos<mask>];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
2001,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,561,22343,22344,UnaryOperatorMutator,++,*/,3,3.0580416E-4,inPos<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos<mask>];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
2002,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,561,22343,22344,UnaryOperatorMutator,++,+,4,2.5941827E-4,inPos<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos<mask>];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
2003,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,561,22338,22342,IdentifierMutator-Variable,inPos,pos,0,0.783149,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[<mask>++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
2004,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,561,22338,22342,IdentifierMutator-Variable,inPos,i,1,0.1898064,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[<mask>++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
2005,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,561,22338,22342,IdentifierMutator-Variable,inPos,pos,2,0.00396269,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[<mask>++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
2006,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,561,22338,22342,IdentifierMutator-Variable,inPos,Pos,3,0.0024369045,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[<mask>++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
2007,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,561,22338,22342,IdentifierMutator-Variable,inPos,offset,4,0.0014244992,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[<mask>++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
2008,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,562,22365,22368,BinaryOperatorMutator,==,<,0,0.33759326,b <mask> org.apache.commons.codec.binary.Base64.PAD,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b<mask>PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
2009,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,562,22365,22368,BinaryOperatorMutator,==,<,2,0.059361983,b <mask> org.apache.commons.codec.binary.Base64.PAD,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b<mask>PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
2010,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,562,22365,22368,BinaryOperatorMutator,==,>=,4,0.032735188,b <mask> org.apache.commons.codec.binary.Base64.PAD,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b<mask>PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
2011,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,562,22364,22364,IdentifierMutator-Variable,b,bc,1,0.0010331722,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (<mask> == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
2012,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,562,22364,22364,IdentifierMutator-Variable,b,a,3,4.8363625E-4,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (<mask> == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
2013,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,562,22364,22364,IdentifierMutator-Variable,b,sb,4,3.881319E-4,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (<mask> == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                     "
2014,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,562,22369,22371,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,0,0,0.8472015,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b ==<mask>) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
2015,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,562,22369,22371,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,127,1,0.049700234,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b ==<mask>) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
2016,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,562,22369,22371,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,b,2,0.020087166,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b ==<mask>) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
2017,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,562,22369,22371,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,255,3,0.010305227,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b ==<mask>) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
2018,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,562,22369,22371,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,null,4,0.009432046,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b ==<mask>) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
2019,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,562,22369,22371,FieldReferenceMutator,PAD,0,0,0.8472015,org.apache.commons.codec.binary.Base64.<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b ==<mask>) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
2020,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,562,22369,22371,FieldReferenceMutator,PAD,127,1,0.049700234,org.apache.commons.codec.binary.Base64.<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b ==<mask>) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
2021,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,562,22369,22371,FieldReferenceMutator,PAD,b,2,0.020087166,org.apache.commons.codec.binary.Base64.<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b ==<mask>) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
2022,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,562,22369,22371,FieldReferenceMutator,PAD,255,3,0.010305227,org.apache.commons.codec.binary.Base64.<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b ==<mask>) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
2023,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,562,22369,22371,FieldReferenceMutator,PAD,null,4,0.009432046,org.apache.commons.codec.binary.Base64.<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b ==<mask>) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                      "
2024,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,564,22426,22426,AssignmentMutator,eof=true,|,0,0.90622437,eof <mask>= true,", int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof<mask>= true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                          "
2025,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,564,22426,22426,AssignmentMutator,eof=true,&,1,0.0685714,eof <mask>= true,", int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof<mask>= true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                          "
2026,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,564,22426,22426,AssignmentMutator,eof=true,*,2,0.010431921,eof <mask>= true,", int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof<mask>= true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                          "
2027,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,564,22426,22426,AssignmentMutator,eof=true,||,3,0.0045410474,eof <mask>= true,", int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof<mask>= true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                          "
2028,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,564,22426,22426,AssignmentMutator,eof=true,^,4,0.0031841302,eof <mask>= true,", int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof<mask>= true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                          "
2029,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,564,22423,22425,IdentifierMutator-Variable,eof,done,0,0.5822251,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.<mask> = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x"
2030,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,564,22423,22425,IdentifierMutator-Variable,eof,finished,1,0.0749867,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.<mask> = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x"
2031,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,564,22423,22425,IdentifierMutator-Variable,eof,completed,2,0.0207111,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.<mask> = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x"
2032,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,564,22423,22425,IdentifierMutator-Variable,eof,complete,3,0.019147605,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.<mask> = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x"
2033,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,564,22423,22425,IdentifierMutator-Variable,eof,ok,4,0.016916098,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.<mask> = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x"
2034,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,564,22423,22425,FieldReferenceMutator,eof,done,0,0.5822251,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.<mask> = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x"
2035,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,564,22423,22425,FieldReferenceMutator,eof,finished,1,0.0749867,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.<mask> = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x"
2036,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,564,22423,22425,FieldReferenceMutator,eof,completed,2,0.0207111,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.<mask> = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x"
2037,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,564,22423,22425,FieldReferenceMutator,eof,complete,3,0.019147605,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.<mask> = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x"
2038,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,564,22423,22425,FieldReferenceMutator,eof,ok,4,0.016916098,<mask>,"void decode(byte[] in, int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.<mask> = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x"
2039,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,564,22429,22432,IdentifierMutator-Literal,true,false,1,0.022653628,<mask>," int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof =<mask>;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer"
2040,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,564,22429,22432,IdentifierMutator-Literal,true,True,2,1.2616171E-4,<mask>," int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof =<mask>;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer"
2041,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,564,22429,22432,IdentifierMutator-Literal,true,1,4,4.7072164E-5,<mask>," int inPos, int inAvail) {
        if (eof) {
            return;
        }
        if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof =<mask>;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer"
2042,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,567,22505,22508,BinaryOperatorMutator,&&,&,2,0.019086072,(b >= 0) <mask> (b < org.apache.commons.codec.binary.Base64.DECODE_TABLE.length)," (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0<mask>b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = ("
2043,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,567,22505,22508,BinaryOperatorMutator,&&,&,3,0.0019726616,(b >= 0) <mask> (b < org.apache.commons.codec.binary.Base64.DECODE_TABLE.length)," (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0<mask>b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = ("
2044,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,567,22505,22508,BinaryOperatorMutator,&&,AND,4,0.0017750916,(b >= 0) <mask> (b < org.apache.commons.codec.binary.Base64.DECODE_TABLE.length)," (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0<mask>b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = ("
2045,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,567,22500,22503,BinaryOperatorMutator,>=,>,1,0.21913998,b <mask> 0,"  if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b<mask>0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++]"
2046,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,567,22500,22503,BinaryOperatorMutator,>=,>,2,0.1036691,b <mask> 0,"  if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b<mask>0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++]"
2047,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,567,22500,22503,BinaryOperatorMutator,>=,!=,3,0.044702142,b <mask> 0,"  if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b<mask>0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++]"
2048,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,567,22500,22503,BinaryOperatorMutator,>=,==,4,0.010695067,b <mask> 0,"  if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b<mask>0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++]"
2049,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,567,22499,22499,IdentifierMutator-Variable,b,result,1,0.021446548,<mask>,"   if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (<mask> >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++"
2050,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,567,22499,22499,IdentifierMutator-Variable,b,bc,2,0.002022709,<mask>,"   if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (<mask> >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++"
2051,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,567,22499,22499,IdentifierMutator-Variable,b,a,4,7.179882E-4,<mask>,"   if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (<mask> >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++"
2052,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,567,22504,22504,IdentifierMutator-Literal,0,1,1,0.004490776,<mask>," if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >=<mask> && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] ="
2053,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,567,22504,22504,IdentifierMutator-Literal,0,offset,2,0.0039863857,<mask>," if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >=<mask> && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] ="
2054,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,567,22504,22504,IdentifierMutator-Literal,0,pos,3,0.0029801773,<mask>," if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >=<mask> && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] ="
2055,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,567,22504,22504,IdentifierMutator-Literal,0,32,4,0.0020950756,<mask>," if (inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >=<mask> && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] ="
2056,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,567,22510,22512,BinaryOperatorMutator,<,<=,2,0.01899425,b <mask> org.apache.commons.codec.binary.Base64.DECODE_TABLE.length,"Avail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b<mask>DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte)"
2057,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,567,22510,22512,BinaryOperatorMutator,<,!=,3,0.00610453,b <mask> org.apache.commons.codec.binary.Base64.DECODE_TABLE.length,"Avail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b<mask>DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte)"
2058,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,567,22510,22512,BinaryOperatorMutator,<,>=,4,0.0019163891,b <mask> org.apache.commons.codec.binary.Base64.DECODE_TABLE.length,"Avail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b<mask>DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte)"
2059,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,567,22509,22509,IdentifierMutator-Variable,b,bi,2,7.3170377E-4,<mask>,"inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 &&<mask> < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte"
2060,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,567,22509,22509,IdentifierMutator-Variable,b,result,3,2.5595404E-4,<mask>,"inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 &&<mask> < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte"
2061,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,567,22509,22509,IdentifierMutator-Variable,b,a,4,2.4868533E-4,<mask>,"inAvail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 &&<mask> < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte"
2062,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,567,22513,22531,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE.length,256,0,0.21313636,<mask>,"ail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b <<mask>) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) &"
2063,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,567,22513,22531,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE.length,127,1,0.17466232,<mask>,"ail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b <<mask>) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) &"
2064,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,567,22513,22531,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE.length,255,2,0.05645742,<mask>,"ail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b <<mask>) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) &"
2065,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,567,22513,22531,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE.length,32,3,0.03200671,<mask>,"ail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b <<mask>) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) &"
2066,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,567,22513,22531,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE.length,128,4,0.028498704,<mask>,"ail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b <<mask>) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) &"
2067,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,567,22513,22524,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE,in,0,0.4893274,<mask>,"ail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b <<mask>.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8"
2068,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,567,22513,22524,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE,buffer,1,0.37093952,<mask>,"ail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b <<mask>.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8"
2069,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,567,22513,22524,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE,table,2,0.022430008,<mask>,"ail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b <<mask>.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8"
2070,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,567,22513,22524,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE,buf,3,0.01231022,<mask>,"ail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b <<mask>.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8"
2071,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,567,22513,22524,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE,out,4,0.010743957,<mask>,"ail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b <<mask>.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8"
2072,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,567,22513,22524,FieldReferenceMutator,DECODE_TABLE,in,0,0.4893274,org.apache.commons.codec.binary.Base64.<mask>,"ail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b <<mask>.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8"
2073,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,567,22513,22524,FieldReferenceMutator,DECODE_TABLE,buffer,1,0.37093952,org.apache.commons.codec.binary.Base64.<mask>,"ail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b <<mask>.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8"
2074,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,567,22513,22524,FieldReferenceMutator,DECODE_TABLE,table,2,0.022430008,org.apache.commons.codec.binary.Base64.<mask>,"ail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b <<mask>.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8"
2075,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,567,22513,22524,FieldReferenceMutator,DECODE_TABLE,buf,3,0.01231022,org.apache.commons.codec.binary.Base64.<mask>,"ail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b <<mask>.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8"
2076,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,567,22513,22524,FieldReferenceMutator,DECODE_TABLE,out,4,0.010743957,org.apache.commons.codec.binary.Base64.<mask>,"ail < 0) {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b <<mask>.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8"
2077,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,567,22526,22531,FieldReferenceMutator,length,size,1,0.012956805,org.apache.commons.codec.binary.Base64.DECODE_TABLE.<mask>,"
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.<mask>) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) &"
2078,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,567,22526,22531,FieldReferenceMutator,length,SIZE,3,6.2544533E-4,org.apache.commons.codec.binary.Base64.DECODE_TABLE.<mask>,"
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.<mask>) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) &"
2079,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,567,22526,22531,FieldReferenceMutator,length,len,4,3.5875774E-4,org.apache.commons.codec.binary.Base64.DECODE_TABLE.<mask>,"
            eof = true;
        }
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.<mask>) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) &"
2080,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,568,22582,22582,ArrayAccessMutator,b,sb,1,4.0137925E-4,org.apache.commons.codec.binary.Base64.DECODE_TABLE[<mask>],"    for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[<mask>];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                       "
2081,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,568,22582,22582,ArrayAccessMutator,b,bc,3,1.6075248E-4,org.apache.commons.codec.binary.Base64.DECODE_TABLE[<mask>],"    for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[<mask>];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                       "
2082,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,568,22582,22582,ArrayAccessMutator,b,bb,4,1.241853E-4,org.apache.commons.codec.binary.Base64.DECODE_TABLE[<mask>],"    for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[<mask>];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                       "
2083,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,568,22569,22580,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE,out,0,0.161933,<mask>,"
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result =<mask>[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                     "
2084,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,568,22569,22580,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE,result,1,0.16134569,<mask>,"
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result =<mask>[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                     "
2085,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,568,22569,22580,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE,table,2,0.122663885,<mask>,"
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result =<mask>[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                     "
2086,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,568,22569,22580,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE,decode,3,0.10492258,<mask>,"
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result =<mask>[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                     "
2087,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,568,22569,22580,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE,in,4,0.06700945,<mask>,"
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result =<mask>[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                     "
2088,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,568,22569,22580,FieldReferenceMutator,DECODE_TABLE,out,0,0.161933,org.apache.commons.codec.binary.Base64.<mask>,"
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result =<mask>[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                     "
2089,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,568,22569,22580,FieldReferenceMutator,DECODE_TABLE,result,1,0.16134569,org.apache.commons.codec.binary.Base64.<mask>,"
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result =<mask>[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                     "
2090,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,568,22569,22580,FieldReferenceMutator,DECODE_TABLE,table,2,0.122663885,org.apache.commons.codec.binary.Base64.<mask>,"
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result =<mask>[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                     "
2091,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,568,22569,22580,FieldReferenceMutator,DECODE_TABLE,decode,3,0.10492258,org.apache.commons.codec.binary.Base64.<mask>,"
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result =<mask>[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                     "
2092,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,568,22569,22580,FieldReferenceMutator,DECODE_TABLE,in,4,0.06700945,org.apache.commons.codec.binary.Base64.<mask>,"
        for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result =<mask>[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                     "
2093,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,568,22582,22582,IdentifierMutator-Variable,b,sb,1,4.0137925E-4,<mask>,"    for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[<mask>];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                       "
2094,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,568,22582,22582,IdentifierMutator-Variable,b,bc,3,1.6075248E-4,<mask>,"    for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[<mask>];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                       "
2095,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,568,22582,22582,IdentifierMutator-Variable,b,bb,4,1.241853E-4,<mask>,"    for (int i = 0; i < inAvail; i++) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[<mask>];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                       "
2096,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,569,22616,22619,BinaryOperatorMutator,>=,==,0,0.19789413,result <mask> 0,"       if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result<mask>0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
 "
2097,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,569,22616,22619,BinaryOperatorMutator,>=,<,1,0.18820265,result <mask> 0,"       if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result<mask>0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
 "
2098,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,569,22616,22619,BinaryOperatorMutator,>=,==,2,0.17100784,result <mask> 0,"       if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result<mask>0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
 "
2099,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,569,22616,22619,BinaryOperatorMutator,>=,>,3,0.12228257,result <mask> 0,"       if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result<mask>0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
 "
2100,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,569,22616,22619,BinaryOperatorMutator,>=,!=,4,0.083168045,result <mask> 0,"       if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result<mask>0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
 "
2101,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,569,22610,22615,IdentifierMutator-Variable,result,b,1,0.0020867772,<mask>,"        if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (<mask> >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
"
2102,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,569,22610,22615,IdentifierMutator-Variable,result,x,3,5.300513E-4,<mask>,"        if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (<mask> >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
"
2103,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,569,22610,22615,IdentifierMutator-Variable,result,Result,4,3.0898253E-4,<mask>,"        if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (<mask> >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
"
2104,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,569,22620,22620,IdentifierMutator-Literal,0,result,1,0.047678776,<mask>,"      if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >=<mask>) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
  "
2105,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,569,22620,22620,IdentifierMutator-Literal,0,1,2,0.01506779,<mask>,"      if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >=<mask>) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
  "
2106,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,569,22620,22620,IdentifierMutator-Literal,0,4,3,0.014520599,<mask>,"      if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >=<mask>) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
  "
2107,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,569,22620,22620,IdentifierMutator-Literal,0,b,4,0.010874171,<mask>,"      if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >=<mask>) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
  "
2108,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,570,22656,22656,AssignmentMutator,modulus=(++modulus)%4,|,0,0.65899664,modulus <mask>= (++modulus) % 4,"         resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus<mask>= (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
     "
2109,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,570,22656,22656,AssignmentMutator,modulus=(++modulus)%4,^,1,0.14296398,modulus <mask>= (++modulus) % 4,"         resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus<mask>= (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
     "
2110,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,570,22656,22656,AssignmentMutator,modulus=(++modulus)%4,*,2,0.12800941,modulus <mask>= (++modulus) % 4,"         resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus<mask>= (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
     "
2111,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,570,22656,22656,AssignmentMutator,modulus=(++modulus)%4,~,3,0.016311442,modulus <mask>= (++modulus) % 4,"         resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus<mask>= (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
     "
2112,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,570,22656,22656,AssignmentMutator,modulus=(++modulus)%4,&,4,0.015128292,modulus <mask>= (++modulus) % 4,"         resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus<mask>= (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
     "
2113,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,570,22649,22655,IdentifierMutator-Variable,modulus,result,0,0.9300049,<mask>,"   if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {<mask> = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
     "
2114,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,570,22649,22655,IdentifierMutator-Variable,modulus,result,1,0.02841901,<mask>,"   if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {<mask> = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
     "
2115,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,570,22649,22655,IdentifierMutator-Variable,modulus,x,2,0.010010788,<mask>,"   if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {<mask> = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
     "
2116,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,570,22649,22655,IdentifierMutator-Variable,modulus,b,3,0.0047685863,<mask>,"   if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {<mask> = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
     "
2117,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,570,22649,22655,IdentifierMutator-Variable,modulus,r,4,0.002740545,<mask>,"   if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {<mask> = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
     "
2118,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,570,22649,22655,FieldReferenceMutator,modulus,result,0,0.9300049,<mask>,"   if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {<mask> = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
     "
2119,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,570,22649,22655,FieldReferenceMutator,modulus,result,1,0.02841901,<mask>,"   if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {<mask> = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
     "
2120,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,570,22649,22655,FieldReferenceMutator,modulus,x,2,0.010010788,<mask>,"   if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {<mask> = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
     "
2121,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,570,22649,22655,FieldReferenceMutator,modulus,b,3,0.0047685863,<mask>,"   if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {<mask> = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
     "
2122,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,570,22649,22655,FieldReferenceMutator,modulus,r,4,0.002740545,<mask>,"   if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {<mask> = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
     "
2123,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,570,22670,22672,BinaryOperatorMutator,%,<<,0,0.3310226,(++modulus) <mask> 4,"   resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus)<mask>4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
            "
2124,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,570,22670,22672,BinaryOperatorMutator,%,<<,1,0.19898808,(++modulus) <mask> 4,"   resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus)<mask>4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
            "
2125,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,570,22670,22672,BinaryOperatorMutator,%,>>>,2,0.1163094,(++modulus) <mask> 4,"   resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus)<mask>4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
            "
2126,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,570,22670,22672,BinaryOperatorMutator,%,>>,3,0.10253956,(++modulus) <mask> 4,"   resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus)<mask>4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
            "
2127,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,570,22670,22672,BinaryOperatorMutator,%,*,4,0.086625755,(++modulus) <mask> 4,"   resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus)<mask>4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
            "
2128,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,570,22659,22661,UnaryOperatorMutator,++,(,0,0.89622533,<mask>modulus,"        resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus =<mask>modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
        "
2129,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,570,22659,22661,UnaryOperatorMutator,++,((,1,0.062281184,<mask>modulus,"        resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus =<mask>modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
        "
2130,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,570,22659,22661,UnaryOperatorMutator,++,(-,2,0.02788103,<mask>modulus,"        resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus =<mask>modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
        "
2131,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,570,22659,22661,UnaryOperatorMutator,++,(+,3,0.0044850786,<mask>modulus,"        resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus =<mask>modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
        "
2132,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,570,22659,22661,UnaryOperatorMutator,++,$(,4,0.003222266,<mask>modulus,"        resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus =<mask>modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
        "
2133,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,570,22662,22668,IdentifierMutator-Variable,modulus,result,0,0.90665376,<mask>,"      resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++<mask>) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
          "
2134,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,570,22662,22668,IdentifierMutator-Variable,modulus,result,1,0.044579715,<mask>,"      resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++<mask>) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
          "
2135,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,570,22662,22668,IdentifierMutator-Variable,modulus,x,2,0.006188522,<mask>,"      resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++<mask>) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
          "
2136,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,570,22662,22668,IdentifierMutator-Variable,modulus,b,3,0.0058603315,<mask>,"      resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++<mask>) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
          "
2137,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,570,22662,22668,IdentifierMutator-Variable,modulus,Result,4,0.0017172208,<mask>,"      resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++<mask>) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
          "
2138,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,570,22662,22668,FieldReferenceMutator,modulus,result,0,0.90665376,<mask>,"      resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++<mask>) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
          "
2139,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,570,22662,22668,FieldReferenceMutator,modulus,result,1,0.044579715,<mask>,"      resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++<mask>) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
          "
2140,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,570,22662,22668,FieldReferenceMutator,modulus,x,2,0.006188522,<mask>,"      resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++<mask>) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
          "
2141,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,570,22662,22668,FieldReferenceMutator,modulus,b,3,0.0058603315,<mask>,"      resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++<mask>) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
          "
2142,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,570,22662,22668,FieldReferenceMutator,modulus,Result,4,0.0017172208,<mask>,"      resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++<mask>) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
          "
2143,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,570,22673,22673,IdentifierMutator-Literal,4,6,0,0.23011923,<mask>,"  resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) %<mask>;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
             "
2144,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,570,22673,22673,IdentifierMutator-Literal,4,7,1,0.17289494,<mask>,"  resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) %<mask>;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
             "
2145,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,570,22673,22673,IdentifierMutator-Literal,4,8,2,0.11898011,<mask>,"  resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) %<mask>;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
             "
2146,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,570,22673,22673,IdentifierMutator-Literal,4,16,3,0.06912174,<mask>,"  resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) %<mask>;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
             "
2147,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,570,22673,22673,IdentifierMutator-Literal,4,2,4,0.060726397,<mask>,"  resizeBuffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) %<mask>;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
             "
2148,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,571,22701,22701,AssignmentMutator,x=(x<<6)+result,^,0,0.4999693,x <mask>= (x << 6) + result,"   byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x<mask>= (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
 "
2149,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,571,22701,22701,AssignmentMutator,x=(x<<6)+result,|,1,0.322209,x <mask>= (x << 6) + result,"   byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x<mask>= (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
 "
2150,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,571,22701,22701,AssignmentMutator,x=(x<<6)+result,*,2,0.08955514,x <mask>= (x << 6) + result,"   byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x<mask>= (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
 "
2151,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,571,22701,22701,AssignmentMutator,x=(x<<6)+result,&,3,0.016634347,x <mask>= (x << 6) + result,"   byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x<mask>= (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
 "
2152,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,571,22701,22701,AssignmentMutator,x=(x<<6)+result,>>,4,0.016120763,x <mask>= (x << 6) + result,"   byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x<mask>= (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
 "
2153,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,571,22700,22700,IdentifierMutator-Variable,x,result,1,0.0640868,<mask>,"Buffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;<mask> = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
 "
2154,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,571,22700,22700,IdentifierMutator-Variable,x,b,3,0.012007701,<mask>,"Buffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;<mask> = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
 "
2155,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,571,22700,22700,IdentifierMutator-Variable,x,byte,4,0.0016528858,<mask>,"Buffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;<mask> = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
 "
2156,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,571,22700,22700,FieldReferenceMutator,x,result,1,0.0640868,<mask>,"Buffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;<mask> = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
 "
2157,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,571,22700,22700,FieldReferenceMutator,x,b,3,0.012007701,<mask>,"Buffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;<mask> = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
 "
2158,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,571,22700,22700,FieldReferenceMutator,x,byte,4,0.0016528858,<mask>,"Buffer();
            }
            byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;<mask> = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
 "
2159,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,571,22712,22714,BinaryOperatorMutator,+,|,0,0.6570313,(x << 6) <mask> result,"[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6)<mask>result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
        "
2160,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,571,22712,22714,BinaryOperatorMutator,+,^,1,0.12923063,(x << 6) <mask> result,"[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6)<mask>result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
        "
2161,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,571,22712,22714,BinaryOperatorMutator,+,^,3,0.025890976,(x << 6) <mask> result,"[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6)<mask>result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
        "
2162,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,571,22712,22714,BinaryOperatorMutator,+,|,4,0.023562854,(x << 6) <mask> result,"[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6)<mask>result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
        "
2163,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,571,22706,22709,BinaryOperatorMutator,<<,>>,2,0.084258474,x <mask> 6," b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x<mask>6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
     "
2164,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,571,22706,22709,BinaryOperatorMutator,<<,>>>,3,0.051838107,x <mask> 6," b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x<mask>6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
     "
2165,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,571,22706,22709,BinaryOperatorMutator,<<,*,4,0.031752646,x <mask> 6," b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x<mask>6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
     "
2166,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,571,22705,22705,IdentifierMutator-Variable,x,result,1,0.015783014,<mask>," byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (<mask> << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
    "
2167,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,571,22705,22705,IdentifierMutator-Variable,x,1,2,0.0072304574,<mask>," byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (<mask> << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
    "
2168,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,571,22705,22705,IdentifierMutator-Variable,x,b,3,0.006456256,<mask>," byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (<mask> << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
    "
2169,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,571,22705,22705,IdentifierMutator-Variable,x,0,4,0.005090533,<mask>," byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (<mask> << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
    "
2170,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,571,22705,22705,FieldReferenceMutator,x,result,1,0.015783014,<mask>," byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (<mask> << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
    "
2171,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,571,22705,22705,FieldReferenceMutator,x,1,2,0.0072304574,<mask>," byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (<mask> << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
    "
2172,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,571,22705,22705,FieldReferenceMutator,x,b,3,0.006456256,<mask>," byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (<mask> << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
    "
2173,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,571,22705,22705,FieldReferenceMutator,x,0,4,0.005090533,<mask>," byte b = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (<mask> << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
    "
2174,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,571,22710,22710,IdentifierMutator-Literal,6,4,0,0.44843903,<mask>," = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x <<<mask>) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
      "
2175,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,571,22710,22710,IdentifierMutator-Literal,6,1,1,0.09024653,<mask>," = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x <<<mask>) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
      "
2176,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,571,22710,22710,IdentifierMutator-Literal,6,3,2,0.08693968,<mask>," = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x <<<mask>) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
      "
2177,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,571,22710,22710,IdentifierMutator-Literal,6,8,3,0.07948491,<mask>," = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x <<<mask>) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
      "
2178,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,571,22710,22710,IdentifierMutator-Literal,6,2,4,0.069562554,<mask>," = in[inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x <<<mask>) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
      "
2179,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,571,22715,22720,IdentifierMutator-Variable,result,1,1,0.05820676,<mask>,"inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) +<mask>;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
         "
2180,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,571,22715,22720,IdentifierMutator-Variable,result,b,2,0.015669588,<mask>,"inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) +<mask>;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
         "
2181,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,571,22715,22720,IdentifierMutator-Variable,result,x,3,0.0086542955,<mask>,"inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) +<mask>;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
         "
2182,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,571,22715,22720,IdentifierMutator-Variable,result,y,4,0.004624361,<mask>,"inPos++];
            if (b == PAD) {
                // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) +<mask>;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
         "
2183,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,572,22758,22761,BinaryOperatorMutator,==,>,1,0.29054463,modulus <mask> 0,"           // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus<mask>0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base"
2184,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,572,22758,22761,BinaryOperatorMutator,==,>,2,0.08662433,modulus <mask> 0,"           // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus<mask>0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base"
2185,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,572,22758,22761,BinaryOperatorMutator,==,=,3,0.034526546,modulus <mask> 0,"           // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus<mask>0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base"
2186,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,572,22751,22757,IdentifierMutator-Variable,modulus,result,0,0.88740814,<mask>,"             // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (<mask> == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as"
2187,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,572,22751,22757,IdentifierMutator-Variable,modulus,x,1,0.05656922,<mask>,"             // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (<mask> == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as"
2188,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,572,22751,22757,IdentifierMutator-Variable,modulus,b,2,0.011772414,<mask>,"             // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (<mask> == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as"
2189,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,572,22751,22757,IdentifierMutator-Variable,modulus,i,3,0.0038203106,<mask>,"             // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (<mask> == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as"
2190,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,572,22751,22757,IdentifierMutator-Variable,modulus,bit,4,0.0012361062,<mask>,"             // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (<mask> == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as"
2191,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,572,22751,22757,FieldReferenceMutator,modulus,result,0,0.88740814,<mask>,"             // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (<mask> == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as"
2192,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,572,22751,22757,FieldReferenceMutator,modulus,x,1,0.05656922,<mask>,"             // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (<mask> == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as"
2193,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,572,22751,22757,FieldReferenceMutator,modulus,b,2,0.011772414,<mask>,"             // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (<mask> == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as"
2194,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,572,22751,22757,FieldReferenceMutator,modulus,i,3,0.0038203106,<mask>,"             // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (<mask> == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as"
2195,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,572,22751,22757,FieldReferenceMutator,modulus,bit,4,0.0012361062,<mask>,"             // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (<mask> == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as"
2196,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,572,22762,22762,IdentifierMutator-Literal,0,4,1,0.10988745,<mask>,"          // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus ==<mask>) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64"
2197,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,572,22762,22762,IdentifierMutator-Literal,0,1,2,0.08169701,<mask>,"          // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus ==<mask>) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64"
2198,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,572,22762,22762,IdentifierMutator-Literal,0,2,3,0.02699835,<mask>,"          // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus ==<mask>) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64"
2199,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,572,22762,22762,IdentifierMutator-Literal,0,7,4,0.024858033,<mask>,"          // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus ==<mask>) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64"
2200,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,573,22808,22808,AssignmentMutator,buffer[pos++]=((byte)((x>>16)&org.apache.commons.codec.binary.Base64.MASK_8BITS)),|,0,0.7883253,buffer[pos++] <mask>= ((byte) ((x >> 16) & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++]<mask>= (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
   "
2201,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,573,22808,22808,AssignmentMutator,buffer[pos++]=((byte)((x>>16)&org.apache.commons.codec.binary.Base64.MASK_8BITS)),^,1,0.15358827,buffer[pos++] <mask>= ((byte) ((x >> 16) & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++]<mask>= (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
   "
2202,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,573,22808,22808,AssignmentMutator,buffer[pos++]=((byte)((x>>16)&org.apache.commons.codec.binary.Base64.MASK_8BITS)),*,2,0.016799748,buffer[pos++] <mask>= ((byte) ((x >> 16) & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++]<mask>= (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
   "
2203,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,573,22808,22808,AssignmentMutator,buffer[pos++]=((byte)((x>>16)&org.apache.commons.codec.binary.Base64.MASK_8BITS)),&,3,0.011472154,buffer[pos++] <mask>= ((byte) ((x >> 16) & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++]<mask>= (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
   "
2204,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,573,22808,22808,AssignmentMutator,buffer[pos++]=((byte)((x>>16)&org.apache.commons.codec.binary.Base64.MASK_8BITS)),<<,4,0.0063417032,buffer[pos++] <mask>= ((byte) ((x >> 16) & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++]<mask>= (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
   "
2205,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,573,22802,22806,ArrayAccessMutator,pos++,pos,0,0.9990188,buffer[<mask>]," true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[<mask>] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
  "
2206,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,573,22802,22806,ArrayAccessMutator,pos++,++,1,1.1636751E-4,buffer[<mask>]," true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[<mask>] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
  "
2207,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,573,22802,22806,ArrayAccessMutator,pos++,push,2,8.2507315E-5,buffer[<mask>]," true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[<mask>] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
  "
2208,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,573,22802,22806,ArrayAccessMutator,pos++,offset,3,6.0640832E-5,buffer[<mask>]," true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[<mask>] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
  "
2209,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,573,22802,22806,ArrayAccessMutator,pos++,neg,4,4.973425E-5,buffer[<mask>]," true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[<mask>] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
  "
2210,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,573,22795,22800,IdentifierMutator-Variable,buffer,byte,2,1.990669E-4,<mask>,"       // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {<mask>[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream."
2211,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,573,22795,22800,IdentifierMutator-Variable,buffer,buf,3,9.610359E-5,<mask>,"       // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {<mask>[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream."
2212,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,573,22795,22800,IdentifierMutator-Variable,buffer,Buffer,4,8.506287E-5,<mask>,"       // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {<mask>[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream."
2213,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,573,22795,22800,FieldReferenceMutator,buffer,byte,2,1.990669E-4,<mask>,"       // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {<mask>[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream."
2214,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,573,22795,22800,FieldReferenceMutator,buffer,buf,3,9.610359E-5,<mask>,"       // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {<mask>[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream."
2215,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,573,22795,22800,FieldReferenceMutator,buffer,Buffer,4,8.506287E-5,<mask>,"       // We're done.
                eof = true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {<mask>[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream."
2216,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,573,22805,22806,UnaryOperatorMutator,++,+,1,1.15085466E-4,pos<mask>,";
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos<mask>] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
  "
2217,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,573,22805,22806,UnaryOperatorMutator,++,++;,3,3.9837236E-5,pos<mask>,";
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos<mask>] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
  "
2218,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,573,22805,22806,UnaryOperatorMutator,++,--,4,3.7068556E-5,pos<mask>,";
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos<mask>] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
  "
2219,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,573,22802,22804,IdentifierMutator-Variable,pos,size,1,2.9646139E-5,<mask>," true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[<mask>++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
 "
2220,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,573,22802,22804,IdentifierMutator-Variable,pos,len,2,1.6531529E-5,<mask>," true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[<mask>++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
 "
2221,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,573,22802,22804,IdentifierMutator-Variable,pos,offset,3,1.652951E-5,<mask>," true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[<mask>++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
 "
2222,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,573,22802,22804,FieldReferenceMutator,pos,size,1,2.9646139E-5,<mask>," true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[<mask>++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
 "
2223,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,573,22802,22804,FieldReferenceMutator,pos,len,2,1.6531529E-5,<mask>," true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[<mask>++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
 "
2224,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,573,22802,22804,FieldReferenceMutator,pos,offset,3,1.652951E-5,<mask>," true;
                break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[<mask>++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
 "
2225,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,573,22828,22830,BinaryOperatorMutator,&,|,1,0.0027280087,(x >> 16) <mask> org.apache.commons.codec.binary.Base64.MASK_8BITS,"       break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16)<mask>MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '"
2226,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,573,22828,22830,BinaryOperatorMutator,&,^,3,2.0136025E-4,(x >> 16) <mask> org.apache.commons.codec.binary.Base64.MASK_8BITS,"       break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16)<mask>MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '"
2227,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,573,22828,22830,BinaryOperatorMutator,&,+,4,8.5965905E-5,(x >> 16) <mask> org.apache.commons.codec.binary.Base64.MASK_8BITS,"       break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16)<mask>MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '"
2228,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,573,22821,22824,BinaryOperatorMutator,>>,<<,2,0.033759512,x <mask> 16,"          break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x<mask>16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach"
2229,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,573,22821,22824,BinaryOperatorMutator,>>,<<,3,0.025514338,x <mask> 16,"          break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x<mask>16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach"
2230,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,573,22821,22824,BinaryOperatorMutator,>>,>>>,4,0.015062867,x <mask> 16,"          break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x<mask>16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach"
2231,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,573,22820,22820,IdentifierMutator-Variable,x,X,2,4.5287445E-5,<mask>,"           break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((<mask> >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This"
2232,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,573,22820,22820,IdentifierMutator-Variable,x,xx,3,4.1739215E-5,<mask>,"           break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((<mask> >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This"
2233,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,573,22820,22820,IdentifierMutator-Variable,x,y,4,3.968694E-5,<mask>,"           break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((<mask> >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This"
2234,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,573,22820,22820,FieldReferenceMutator,x,X,2,4.5287445E-5,<mask>,"           break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((<mask> >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This"
2235,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,573,22820,22820,FieldReferenceMutator,x,xx,3,4.1739215E-5,<mask>,"           break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((<mask> >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This"
2236,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,573,22820,22820,FieldReferenceMutator,x,y,4,3.968694E-5,<mask>,"           break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((<mask> >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This"
2237,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,573,22825,22826,IdentifierMutator-Literal,16,8,0,0.75472903,<mask>,"         break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >><mask>) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes"
2238,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,573,22825,22826,IdentifierMutator-Literal,16,6,2,0.036264252,<mask>,"         break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >><mask>) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes"
2239,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,573,22825,22826,IdentifierMutator-Literal,16,4,3,0.03212222,<mask>,"         break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >><mask>) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes"
2240,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,573,22825,22826,IdentifierMutator-Literal,16,7,4,0.028541556,<mask>,"         break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >><mask>) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes"
2241,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,573,22831,22840,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,255,0,0.14948566,<mask>,"      break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) &<mask>);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional."
2242,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,573,22831,22840,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,mask,1,0.08499066,<mask>,"      break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) &<mask>);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional."
2243,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,573,22831,22840,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,7,2,0.08133535,<mask>,"      break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) &<mask>);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional."
2244,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,573,22831,22840,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,1,3,0.066104494,<mask>,"      break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) &<mask>);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional."
2245,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,573,22831,22840,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,bits,4,0.0607781,<mask>,"      break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) &<mask>);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional."
2246,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,573,22831,22840,FieldReferenceMutator,MASK_8BITS,255,0,0.14948566,org.apache.commons.codec.binary.Base64.<mask>,"      break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) &<mask>);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional."
2247,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,573,22831,22840,FieldReferenceMutator,MASK_8BITS,mask,1,0.08499066,org.apache.commons.codec.binary.Base64.<mask>,"      break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) &<mask>);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional."
2248,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,573,22831,22840,FieldReferenceMutator,MASK_8BITS,7,2,0.08133535,org.apache.commons.codec.binary.Base64.<mask>,"      break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) &<mask>);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional."
2249,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,573,22831,22840,FieldReferenceMutator,MASK_8BITS,1,3,0.066104494,org.apache.commons.codec.binary.Base64.<mask>,"      break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) &<mask>);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional."
2250,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,573,22831,22840,FieldReferenceMutator,MASK_8BITS,bits,4,0.0607781,org.apache.commons.codec.binary.Base64.<mask>,"      break;
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) &<mask>);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional."
2251,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,574,22885,22885,AssignmentMutator,buffer[pos++]=((byte)((x>>8)&org.apache.commons.codec.binary.Base64.MASK_8BITS)),|,0,0.84377605,buffer[pos++] <mask>= ((byte) ((x >> 8) & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++]<mask>= (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer"
2252,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,574,22885,22885,AssignmentMutator,buffer[pos++]=((byte)((x>>8)&org.apache.commons.codec.binary.Base64.MASK_8BITS)),^,1,0.11779102,buffer[pos++] <mask>= ((byte) ((x >> 8) & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++]<mask>= (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer"
2253,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,574,22885,22885,AssignmentMutator,buffer[pos++]=((byte)((x>>8)&org.apache.commons.codec.binary.Base64.MASK_8BITS)),&,2,0.013100316,buffer[pos++] <mask>= ((byte) ((x >> 8) & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++]<mask>= (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer"
2254,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,574,22885,22885,AssignmentMutator,buffer[pos++]=((byte)((x>>8)&org.apache.commons.codec.binary.Base64.MASK_8BITS)),*,3,0.009379746,buffer[pos++] <mask>= ((byte) ((x >> 8) & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++]<mask>= (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer"
2255,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,574,22885,22885,AssignmentMutator,buffer[pos++]=((byte)((x>>8)&org.apache.commons.codec.binary.Base64.MASK_8BITS)),>>>,4,0.0031888855,buffer[pos++] <mask>= ((byte) ((x >> 8) & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++]<mask>= (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer"
2256,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,574,22879,22883,ArrayAccessMutator,pos++,pos,0,0.9834669,buffer[<mask>],"  if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[<mask>] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if ("
2257,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,574,22879,22883,ArrayAccessMutator,pos++,++,1,0.006718165,buffer[<mask>],"  if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[<mask>] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if ("
2258,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,574,22879,22883,ArrayAccessMutator,pos++,push,2,0.0011382556,buffer[<mask>],"  if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[<mask>] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if ("
2259,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,574,22879,22883,ArrayAccessMutator,pos++,neg,3,7.127295E-4,buffer[<mask>],"  if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[<mask>] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if ("
2260,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,574,22879,22883,ArrayAccessMutator,pos++,next,4,6.296928E-4,buffer[<mask>],"  if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[<mask>] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if ("
2261,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,574,22872,22877,IdentifierMutator-Variable,buffer,Buffer,2,8.9295744E-4,<mask>,"
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);<mask>[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
          "
2262,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,574,22872,22877,IdentifierMutator-Variable,buffer,byte,3,3.595063E-4,<mask>,"
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);<mask>[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
          "
2263,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,574,22872,22877,IdentifierMutator-Variable,buffer,Buffer,4,3.2872977E-4,<mask>,"
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);<mask>[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
          "
2264,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,574,22872,22877,FieldReferenceMutator,buffer,Buffer,2,8.9295744E-4,<mask>,"
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);<mask>[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
          "
2265,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,574,22872,22877,FieldReferenceMutator,buffer,byte,3,3.595063E-4,<mask>,"
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);<mask>[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
          "
2266,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,574,22872,22877,FieldReferenceMutator,buffer,Buffer,4,3.2872977E-4,<mask>,"
            } else {
                if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);<mask>[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
          "
2267,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,574,22882,22883,UnaryOperatorMutator,++,--,2,1.0629602E-4,pos<mask>," if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos<mask>] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if ("
2268,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,574,22882,22883,UnaryOperatorMutator,++,+,3,9.762443E-5,pos<mask>," if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos<mask>] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if ("
2269,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,574,22882,22883,UnaryOperatorMutator,++,++;,4,5.836285E-5,pos<mask>," if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos<mask>] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if ("
2270,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,574,22879,22881,IdentifierMutator-Variable,pos,size,1,6.545053E-5,<mask>,"  if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[<mask>++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if"
2271,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,574,22879,22881,IdentifierMutator-Variable,pos,len,2,6.0663024E-5,<mask>,"  if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[<mask>++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if"
2272,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,574,22879,22881,IdentifierMutator-Variable,pos,neg,3,3.9211613E-5,<mask>,"  if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[<mask>++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if"
2273,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,574,22879,22881,FieldReferenceMutator,pos,size,1,6.545053E-5,<mask>,"  if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[<mask>++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if"
2274,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,574,22879,22881,FieldReferenceMutator,pos,len,2,6.0663024E-5,<mask>,"  if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[<mask>++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if"
2275,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,574,22879,22881,FieldReferenceMutator,pos,neg,3,3.9211613E-5,<mask>,"  if (b >= 0 && b < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[<mask>++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if"
2276,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,574,22904,22906,BinaryOperatorMutator,&,|,1,0.0030781173,(x >> 8) <mask> org.apache.commons.codec.binary.Base64.MASK_8BITS,"TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8)<mask>MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decode"
2277,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,574,22904,22906,BinaryOperatorMutator,&,^,3,1.7818132E-4,(x >> 8) <mask> org.apache.commons.codec.binary.Base64.MASK_8BITS,"TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8)<mask>MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decode"
2278,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,574,22904,22906,BinaryOperatorMutator,&,~,4,5.2539155E-5,(x >> 8) <mask> org.apache.commons.codec.binary.Base64.MASK_8BITS,"TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8)<mask>MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decode"
2279,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,574,22898,22901,BinaryOperatorMutator,>>,>>>,1,0.0057276003,x <mask> 8," DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x<mask>8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length -"
2280,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,574,22898,22901,BinaryOperatorMutator,>>,<<,2,0.0034407824,x <mask> 8," DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x<mask>8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length -"
2281,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,574,22898,22901,BinaryOperatorMutator,>>,<<,4,3.2703442E-4,x <mask> 8," DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x<mask>8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length -"
2282,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,574,22897,22897,IdentifierMutator-Variable,x,y,1,4.8968854E-5,<mask>," < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((<mask> >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length"
2283,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,574,22897,22897,IdentifierMutator-Variable,x,xx,3,1.2466716E-5,<mask>," < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((<mask> >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length"
2284,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,574,22897,22897,IdentifierMutator-Variable,x,X,4,1.2094731E-5,<mask>," < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((<mask> >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length"
2285,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,574,22897,22897,FieldReferenceMutator,x,y,1,4.8968854E-5,<mask>," < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((<mask> >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length"
2286,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,574,22897,22897,FieldReferenceMutator,x,xx,3,1.2466716E-5,<mask>," < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((<mask> >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length"
2287,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,574,22897,22897,FieldReferenceMutator,x,X,4,1.2094731E-5,<mask>," < DECODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((<mask> >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length"
2288,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,574,22902,22902,IdentifierMutator-Literal,8,16,1,0.0700611,<mask>,"ODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >><mask>) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos"
2289,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,574,22902,22902,IdentifierMutator-Literal,8,6,2,0.038927842,<mask>,"ODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >><mask>) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos"
2290,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,574,22902,22902,IdentifierMutator-Literal,8,24,3,0.02497605,<mask>,"ODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >><mask>) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos"
2291,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,574,22902,22902,IdentifierMutator-Literal,8,12,4,0.017248644,<mask>,"ODE_TABLE.length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >><mask>) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos"
2292,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,574,22907,22916,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,mask,0,0.2678655,<mask>,".length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) &<mask>);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
  "
2293,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,574,22907,22916,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,7,1,0.106067866,<mask>,".length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) &<mask>);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
  "
2294,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,574,22907,22916,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,255,2,0.09560945,<mask>,".length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) &<mask>);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
  "
2295,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,574,22907,22916,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,1,3,0.07435307,<mask>,".length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) &<mask>);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
  "
2296,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,574,22907,22916,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,bits,4,0.065667495,<mask>,".length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) &<mask>);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
  "
2297,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,574,22907,22916,FieldReferenceMutator,MASK_8BITS,mask,0,0.2678655,org.apache.commons.codec.binary.Base64.<mask>,".length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) &<mask>);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
  "
2298,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,574,22907,22916,FieldReferenceMutator,MASK_8BITS,7,1,0.106067866,org.apache.commons.codec.binary.Base64.<mask>,".length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) &<mask>);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
  "
2299,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,574,22907,22916,FieldReferenceMutator,MASK_8BITS,255,2,0.09560945,org.apache.commons.codec.binary.Base64.<mask>,".length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) &<mask>);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
  "
2300,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,574,22907,22916,FieldReferenceMutator,MASK_8BITS,1,3,0.07435307,org.apache.commons.codec.binary.Base64.<mask>,".length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) &<mask>);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
  "
2301,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,574,22907,22916,FieldReferenceMutator,MASK_8BITS,bits,4,0.065667495,org.apache.commons.codec.binary.Base64.<mask>,".length) {
                    int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) &<mask>);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
  "
2302,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,575,22961,22961,AssignmentMutator,buffer[pos++]=((byte)(x&org.apache.commons.codec.binary.Base64.MASK_8BITS)),|,0,0.75222784,buffer[pos++] <mask>= ((byte) (x & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"               if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++]<mask>= (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
    "
2303,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,575,22961,22961,AssignmentMutator,buffer[pos++]=((byte)(x&org.apache.commons.codec.binary.Base64.MASK_8BITS)),^,1,0.22104852,buffer[pos++] <mask>= ((byte) (x & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"               if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++]<mask>= (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
    "
2304,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,575,22961,22961,AssignmentMutator,buffer[pos++]=((byte)(x&org.apache.commons.codec.binary.Base64.MASK_8BITS)),&,2,0.009466009,buffer[pos++] <mask>= ((byte) (x & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"               if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++]<mask>= (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
    "
2305,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,575,22961,22961,AssignmentMutator,buffer[pos++]=((byte)(x&org.apache.commons.codec.binary.Base64.MASK_8BITS)),*,3,0.0067352336,buffer[pos++] <mask>= ((byte) (x & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"               if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++]<mask>= (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
    "
2306,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,575,22961,22961,AssignmentMutator,buffer[pos++]=((byte)(x&org.apache.commons.codec.binary.Base64.MASK_8BITS)),<<,4,0.0019554717,buffer[pos++] <mask>= ((byte) (x & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"               if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++]<mask>= (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
    "
2307,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,575,22955,22959,ArrayAccessMutator,pos++,pos,0,0.98453265,buffer[<mask>],"                  if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[<mask>] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
   "
2308,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,575,22955,22959,ArrayAccessMutator,pos++,++,1,0.005643638,buffer[<mask>],"                  if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[<mask>] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
   "
2309,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,575,22955,22959,ArrayAccessMutator,pos++,len,2,8.365135E-4,buffer[<mask>],"                  if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[<mask>] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
   "
2310,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,575,22955,22959,ArrayAccessMutator,pos++,neg,3,7.98241E-4,buffer[<mask>],"                  if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[<mask>] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
   "
2311,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,575,22955,22959,ArrayAccessMutator,pos++,next,4,4.2224152E-4,buffer[<mask>],"                  if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[<mask>] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
   "
2312,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,575,22948,22953,IdentifierMutator-Variable,buffer,byte,2,5.705932E-4,<mask>,"                  int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);<mask>[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
"
2313,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,575,22948,22953,IdentifierMutator-Variable,buffer,Buffer,3,4.703385E-4,<mask>,"                  int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);<mask>[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
"
2314,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,575,22948,22953,IdentifierMutator-Variable,buffer,buf,4,3.2684923E-4,<mask>,"                  int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);<mask>[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
"
2315,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,575,22948,22953,FieldReferenceMutator,buffer,byte,2,5.705932E-4,<mask>,"                  int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);<mask>[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
"
2316,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,575,22948,22953,FieldReferenceMutator,buffer,Buffer,3,4.703385E-4,<mask>,"                  int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);<mask>[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
"
2317,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,575,22948,22953,FieldReferenceMutator,buffer,buf,4,3.2684923E-4,<mask>,"                  int result = DECODE_TABLE[b];
                    if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);<mask>[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
"
2318,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,575,22958,22959,UnaryOperatorMutator,++,--,2,9.577099E-5,pos<mask>,"                 if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos<mask>] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
   "
2319,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,575,22958,22959,UnaryOperatorMutator,++,++;,3,9.177502E-5,pos<mask>,"                 if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos<mask>] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
   "
2320,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,575,22958,22959,UnaryOperatorMutator,++,+,4,6.779041E-5,pos<mask>,"                 if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos<mask>] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
   "
2321,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,575,22955,22957,IdentifierMutator-Variable,pos,len,1,2.4209244E-4,<mask>,"                  if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[<mask>++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
  "
2322,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,575,22955,22957,IdentifierMutator-Variable,pos,size,2,1.16159885E-4,<mask>,"                  if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[<mask>++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
  "
2323,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,575,22955,22957,IdentifierMutator-Variable,pos,neg,3,9.629809E-5,<mask>,"                  if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[<mask>++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
  "
2324,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,575,22955,22957,FieldReferenceMutator,pos,len,1,2.4209244E-4,<mask>,"                  if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[<mask>++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
  "
2325,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,575,22955,22957,FieldReferenceMutator,pos,size,2,1.16159885E-4,<mask>,"                  if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[<mask>++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
  "
2326,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,575,22955,22957,FieldReferenceMutator,pos,neg,3,9.629809E-5,<mask>,"                  if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[<mask>++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
  "
2327,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,575,22973,22975,BinaryOperatorMutator,&,<<,2,0.02608974,x <mask> org.apache.commons.codec.binary.Base64.MASK_8BITS,"         if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x<mask>MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
           "
2328,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,575,22973,22975,BinaryOperatorMutator,&,|,3,0.015976517,x <mask> org.apache.commons.codec.binary.Base64.MASK_8BITS,"         if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x<mask>MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
           "
2329,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,575,22973,22975,BinaryOperatorMutator,&,>>,4,0.011088139,x <mask> org.apache.commons.codec.binary.Base64.MASK_8BITS,"         if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x<mask>MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
           "
2330,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,575,22972,22972,IdentifierMutator-Variable,x,result,1,8.005851E-4,<mask>,"          if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (<mask> & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
          "
2331,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,575,22972,22972,IdentifierMutator-Variable,x,y,2,6.595817E-4,<mask>,"          if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (<mask> & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
          "
2332,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,575,22972,22972,IdentifierMutator-Variable,x,xx,3,5.451774E-4,<mask>,"          if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (<mask> & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
          "
2333,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,575,22972,22972,IdentifierMutator-Variable,x,rx,4,2.9773425E-4,<mask>,"          if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (<mask> & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
          "
2334,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,575,22972,22972,FieldReferenceMutator,x,result,1,8.005851E-4,<mask>,"          if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (<mask> & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
          "
2335,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,575,22972,22972,FieldReferenceMutator,x,y,2,6.595817E-4,<mask>,"          if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (<mask> & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
          "
2336,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,575,22972,22972,FieldReferenceMutator,x,xx,3,5.451774E-4,<mask>,"          if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (<mask> & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
          "
2337,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,575,22972,22972,FieldReferenceMutator,x,rx,4,2.9773425E-4,<mask>,"          if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (<mask> & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
          "
2338,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,575,22976,22985,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,7,0,0.2014504,<mask>,"        if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x &<mask>);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
    "
2339,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,575,22976,22985,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,255,1,0.14482085,<mask>,"        if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x &<mask>);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
    "
2340,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,575,22976,22985,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,1,2,0.13607307,<mask>,"        if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x &<mask>);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
    "
2341,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,575,22976,22985,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,mask,3,0.11543218,<mask>,"        if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x &<mask>);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
    "
2342,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,575,22976,22985,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,63,4,0.11482765,<mask>,"        if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x &<mask>);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
    "
2343,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,575,22976,22985,FieldReferenceMutator,MASK_8BITS,7,0,0.2014504,org.apache.commons.codec.binary.Base64.<mask>,"        if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x &<mask>);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
    "
2344,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,575,22976,22985,FieldReferenceMutator,MASK_8BITS,255,1,0.14482085,org.apache.commons.codec.binary.Base64.<mask>,"        if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x &<mask>);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
    "
2345,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,575,22976,22985,FieldReferenceMutator,MASK_8BITS,1,2,0.13607307,org.apache.commons.codec.binary.Base64.<mask>,"        if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x &<mask>);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
    "
2346,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,575,22976,22985,FieldReferenceMutator,MASK_8BITS,mask,3,0.11543218,org.apache.commons.codec.binary.Base64.<mask>,"        if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x &<mask>);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
    "
2347,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,575,22976,22985,FieldReferenceMutator,MASK_8BITS,63,4,0.11482765,org.apache.commons.codec.binary.Base64.<mask>,"        if (result >= 0) {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0) {
                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x &<mask>);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
    "
2348,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,585,23323,23326,BinaryOperatorMutator,&&,_,1,0.19427349,eof <mask> (modulus != 0),"                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof<mask>modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
         "
2349,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,585,23323,23326,BinaryOperatorMutator,&&,/,2,0.117496856,eof <mask> (modulus != 0),"                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof<mask>modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
         "
2350,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,585,23323,23326,BinaryOperatorMutator,&&,+,3,0.11119797,eof <mask> (modulus != 0),"                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof<mask>modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
         "
2351,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,585,23323,23326,BinaryOperatorMutator,&&,.,4,0.08980558,eof <mask> (modulus != 0),"                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof<mask>modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
         "
2352,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,585,23320,23322,IdentifierMutator-Variable,eof,enabled,0,0.033832595,<mask>,"                      buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (<mask> && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
        "
2353,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,585,23320,23322,IdentifierMutator-Variable,eof,complete,1,0.032691006,<mask>,"                      buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (<mask> && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
        "
2354,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,585,23320,23322,IdentifierMutator-Variable,eof,raw,2,0.030793503,<mask>,"                      buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (<mask> && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
        "
2355,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,585,23320,23322,IdentifierMutator-Variable,eof,true,3,0.026702624,<mask>,"                      buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (<mask> && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
        "
2356,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,585,23320,23322,IdentifierMutator-Variable,eof,stream,4,0.022248877,<mask>,"                      buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (<mask> && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
        "
2357,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,585,23320,23322,FieldReferenceMutator,eof,enabled,0,0.033832595,<mask>,"                      buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (<mask> && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
        "
2358,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,585,23320,23322,FieldReferenceMutator,eof,complete,1,0.032691006,<mask>,"                      buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (<mask> && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
        "
2359,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,585,23320,23322,FieldReferenceMutator,eof,raw,2,0.030793503,<mask>,"                      buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (<mask> && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
        "
2360,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,585,23320,23322,FieldReferenceMutator,eof,true,3,0.026702624,<mask>,"                      buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (<mask> && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
        "
2361,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,585,23320,23322,FieldReferenceMutator,eof,stream,4,0.022248877,<mask>,"                      buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (<mask> && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
        "
2362,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,585,23334,23337,BinaryOperatorMutator,!=,==,0,0.76668864,modulus <mask> 0,"                 buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus<mask>0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
            "
2363,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,585,23334,23337,BinaryOperatorMutator,!=,>,1,0.07246464,modulus <mask> 0,"                 buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus<mask>0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
            "
2364,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,585,23334,23337,BinaryOperatorMutator,!=,==,2,0.060438473,modulus <mask> 0,"                 buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus<mask>0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
            "
2365,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,585,23334,23337,BinaryOperatorMutator,!=,>,3,0.037059776,modulus <mask> 0,"                 buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus<mask>0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
            "
2366,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,585,23334,23337,BinaryOperatorMutator,!=,=,4,0.0130956285,modulus <mask> 0,"                 buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus<mask>0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
            "
2367,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,585,23327,23333,IdentifierMutator-Variable,modulus,pos,0,0.8177528,<mask>,"                   buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof &&<mask> != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
           "
2368,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,585,23327,23333,IdentifierMutator-Variable,modulus,x,1,0.04335659,<mask>,"                   buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof &&<mask> != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
           "
2369,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,585,23327,23333,IdentifierMutator-Variable,modulus,offset,2,0.008826892,<mask>,"                   buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof &&<mask> != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
           "
2370,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,585,23327,23333,IdentifierMutator-Variable,modulus,bytes,3,0.007404617,<mask>,"                   buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof &&<mask> != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
           "
2371,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,585,23327,23333,IdentifierMutator-Variable,modulus,index,4,0.0067452798,<mask>,"                   buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof &&<mask> != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
           "
2372,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,585,23327,23333,FieldReferenceMutator,modulus,pos,0,0.8177528,<mask>,"                   buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof &&<mask> != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
           "
2373,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,585,23327,23333,FieldReferenceMutator,modulus,x,1,0.04335659,<mask>,"                   buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof &&<mask> != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
           "
2374,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,585,23327,23333,FieldReferenceMutator,modulus,offset,2,0.008826892,<mask>,"                   buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof &&<mask> != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
           "
2375,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,585,23327,23333,FieldReferenceMutator,modulus,bytes,3,0.007404617,<mask>,"                   buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof &&<mask> != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
           "
2376,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,585,23327,23333,FieldReferenceMutator,modulus,index,4,0.0067452798,<mask>,"                   buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof &&<mask> != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
           "
2377,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,585,23338,23338,IdentifierMutator-Literal,0,2,1,0.32603207,<mask>,"                buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus !=<mask>) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
             "
2378,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,585,23338,23338,IdentifierMutator-Literal,0,1,2,0.18740526,<mask>,"                buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus !=<mask>) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
             "
2379,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,585,23338,23338,IdentifierMutator-Literal,0,3,3,0.060841404,<mask>,"                buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus !=<mask>) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
             "
2380,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,585,23338,23338,IdentifierMutator-Literal,0,8,4,0.013089752,<mask>,"                buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus !=<mask>) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
             "
2381,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,586,23373,23376,BinaryOperatorMutator,||,|,1,0.02023425,(buffer == null) <mask> ((buffer.length - pos) < decodeSize)," = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null<mask>buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16)"
2382,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,586,23373,23376,BinaryOperatorMutator,||,.,3,0.003938196,(buffer == null) <mask> ((buffer.length - pos) < decodeSize)," = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null<mask>buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16)"
2383,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,586,23373,23376,BinaryOperatorMutator,||,?,4,0.0021474322,(buffer == null) <mask> ((buffer.length - pos) < decodeSize)," = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null<mask>buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16)"
2384,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,586,23365,23368,BinaryOperatorMutator,==,===,2,0.023412053,buffer <mask> null,"++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer<mask>null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >>"
2385,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,586,23365,23368,BinaryOperatorMutator,==,=,3,0.011309804,buffer <mask> null,"++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer<mask>null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >>"
2386,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,586,23365,23368,BinaryOperatorMutator,==,===,4,0.001966913,buffer <mask> null,"++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer<mask>null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >>"
2387,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,586,23359,23364,IdentifierMutator-Variable,buffer,buf,1,0.0037613593,<mask>,"pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (<mask> == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x"
2388,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,586,23359,23364,IdentifierMutator-Variable,buffer,queue,3,0.00199454,<mask>,"pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (<mask> == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x"
2389,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,586,23359,23364,IdentifierMutator-Variable,buffer,Buffer,4,0.0017658952,<mask>,"pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (<mask> == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x"
2390,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,586,23359,23364,FieldReferenceMutator,buffer,buf,1,0.0037613593,<mask>,"pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (<mask> == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x"
2391,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,586,23359,23364,FieldReferenceMutator,buffer,queue,3,0.00199454,<mask>,"pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (<mask> == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x"
2392,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,586,23359,23364,FieldReferenceMutator,buffer,Buffer,4,0.0017658952,<mask>,"pos++] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (<mask> == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x"
2393,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,586,23369,23372,IdentifierMutator-Literal,null,nil,1,0.003151027,<mask>,"] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer ==<mask> || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16"
2394,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,586,23369,23372,IdentifierMutator-Literal,null,NULL,2,0.0010831365,<mask>,"] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer ==<mask> || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16"
2395,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,586,23369,23372,IdentifierMutator-Literal,null,undefined,3,6.861559E-4,<mask>,"] = (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer ==<mask> || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16"
2396,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,586,23396,23398,BinaryOperatorMutator,<,>,1,0.15181991,(buffer.length - pos) <mask> decodeSize," >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos<mask>decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8"
2397,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,586,23396,23398,BinaryOperatorMutator,<,==,3,0.09581702,(buffer.length - pos) <mask> decodeSize," >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos<mask>decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8"
2398,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,586,23396,23398,BinaryOperatorMutator,<,>,4,0.08075408,(buffer.length - pos) <mask> decodeSize," >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos<mask>decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8"
2399,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,586,23390,23392,BinaryOperatorMutator,-,+,1,0.08510117,buffer.length <mask> pos," ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length<mask>pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_"
2400,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,586,23390,23392,BinaryOperatorMutator,-,*,2,0.0786802,buffer.length <mask> pos," ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length<mask>pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_"
2401,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,586,23390,23392,BinaryOperatorMutator,-,_,3,0.022306504,buffer.length <mask> pos," ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length<mask>pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_"
2402,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,586,23390,23392,BinaryOperatorMutator,-,/,4,0.018254474,buffer.length <mask> pos," ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length<mask>pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_"
2403,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,586,23377,23389,IdentifierMutator-Variable,buffer.length,limit,0,0.21975614,<mask>," (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null ||<mask> - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK"
2404,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,586,23377,23389,IdentifierMutator-Variable,buffer.length,size,1,0.18641996,<mask>," (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null ||<mask> - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK"
2405,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,586,23377,23389,IdentifierMutator-Variable,buffer.length,end,2,0.14514776,<mask>," (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null ||<mask> - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK"
2406,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,586,23377,23389,IdentifierMutator-Variable,buffer.length,length,3,0.11219305,<mask>," (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null ||<mask> - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK"
2407,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,586,23377,23389,IdentifierMutator-Variable,buffer.length,bytes,4,0.028051982,<mask>," (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null ||<mask> - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK"
2408,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,586,23377,23382,IdentifierMutator-Variable,buffer,buf,1,6.705756E-4,<mask>," (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null ||<mask>.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) &"
2409,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,586,23377,23382,IdentifierMutator-Variable,buffer,stream,2,3.8292E-4,<mask>," (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null ||<mask>.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) &"
2410,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,586,23377,23382,IdentifierMutator-Variable,buffer,buffers,3,3.69634E-4,<mask>," (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null ||<mask>.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) &"
2411,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,586,23377,23382,IdentifierMutator-Variable,buffer,input,4,2.8552374E-4,<mask>," (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null ||<mask>.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) &"
2412,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,586,23377,23382,FieldReferenceMutator,buffer,buf,1,6.705756E-4,<mask>," (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null ||<mask>.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) &"
2413,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,586,23377,23382,FieldReferenceMutator,buffer,stream,2,3.8292E-4,<mask>," (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null ||<mask>.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) &"
2414,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,586,23377,23382,FieldReferenceMutator,buffer,buffers,3,3.69634E-4,<mask>," (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null ||<mask>.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) &"
2415,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,586,23377,23382,FieldReferenceMutator,buffer,input,4,2.8552374E-4,<mask>," (byte) ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null ||<mask>.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) &"
2416,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,586,23384,23389,FieldReferenceMutator,length,position,1,0.0044532483,buffer.<mask>,") ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.<mask> - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK"
2417,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,586,23384,23389,FieldReferenceMutator,length,size,2,0.0026411864,buffer.<mask>,") ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.<mask> - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK"
2418,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,586,23384,23389,FieldReferenceMutator,length,len,3,0.0019081968,buffer.<mask>,") ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.<mask> - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK"
2419,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,586,23384,23389,FieldReferenceMutator,length,limit,4,9.064388E-4,buffer.<mask>,") ((x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.<mask> - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK"
2420,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,586,23393,23395,IdentifierMutator-Variable,pos,1,1,0.07432478,<mask>,"x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length -<mask> < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8"
2421,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,586,23393,23395,IdentifierMutator-Variable,pos,offset,2,0.012212382,<mask>,"x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length -<mask> < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8"
2422,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,586,23393,23395,IdentifierMutator-Variable,pos,size,3,0.01179222,<mask>,"x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length -<mask> < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8"
2423,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,586,23393,23395,IdentifierMutator-Variable,pos,2,4,0.010370783,<mask>,"x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length -<mask> < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8"
2424,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,586,23393,23395,FieldReferenceMutator,pos,1,1,0.07432478,<mask>,"x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length -<mask> < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8"
2425,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,586,23393,23395,FieldReferenceMutator,pos,offset,2,0.012212382,<mask>,"x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length -<mask> < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8"
2426,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,586,23393,23395,FieldReferenceMutator,pos,size,3,0.01179222,<mask>,"x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length -<mask> < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8"
2427,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,586,23393,23395,FieldReferenceMutator,pos,2,4,0.010370783,<mask>,"x >> 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length -<mask> < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8"
2428,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,586,23399,23408,IdentifierMutator-Variable,decodeSize,2,0,0.14342831,<mask>," 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);"
2429,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,586,23399,23408,IdentifierMutator-Variable,decodeSize,1,1,0.10549228,<mask>," 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);"
2430,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,586,23399,23408,IdentifierMutator-Variable,decodeSize,3,2,0.07873409,<mask>," 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);"
2431,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,586,23399,23408,IdentifierMutator-Variable,decodeSize,4,3,0.07788089,<mask>," 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);"
2432,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,586,23399,23408,IdentifierMutator-Variable,decodeSize,0,4,0.07454842,<mask>," 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);"
2433,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,586,23399,23408,FieldReferenceMutator,decodeSize,2,0,0.14342831,<mask>," 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);"
2434,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,586,23399,23408,FieldReferenceMutator,decodeSize,1,1,0.10549228,<mask>," 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);"
2435,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,586,23399,23408,FieldReferenceMutator,decodeSize,3,2,0.07873409,<mask>," 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);"
2436,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,586,23399,23408,FieldReferenceMutator,decodeSize,4,3,0.07788089,<mask>," 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);"
2437,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,586,23399,23408,FieldReferenceMutator,decodeSize,0,4,0.07454842,<mask>," 8) & MASK_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos <<mask>) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);"
2438,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,587,23429,23440,MethodCallMutator,resizeBuffer,close,0,0.3156145,<mask>(),"K_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {<mask>();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                   "
2439,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,587,23429,23440,MethodCallMutator,resizeBuffer,flush,1,0.1111821,<mask>(),"K_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {<mask>();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                   "
2440,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,587,23429,23440,MethodCallMutator,resizeBuffer,break,2,0.0923622,<mask>(),"K_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {<mask>();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                   "
2441,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,587,23429,23440,MethodCallMutator,resizeBuffer,end,3,0.0686969,<mask>(),"K_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {<mask>();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                   "
2442,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,587,23429,23440,MethodCallMutator,resizeBuffer,reset,4,0.036376424,<mask>(),"K_8BITS);
                            buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {<mask>();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                   "
2443,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,590,23485,23485,AssignmentMutator,x=x<<6,|,0,0.5181725,x <mask>= x << 6,"                    }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x<mask>= x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                 "
2444,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,590,23485,23485,AssignmentMutator,x=x<<6,^,1,0.4160593,x <mask>= x << 6,"                    }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x<mask>= x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                 "
2445,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,590,23485,23485,AssignmentMutator,x=x<<6,*,2,0.024156794,x <mask>= x << 6,"                    }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x<mask>= x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                 "
2446,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,590,23485,23485,AssignmentMutator,x=x<<6,&,3,0.008777024,x <mask>= x << 6,"                    }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x<mask>= x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                 "
2447,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,590,23485,23485,AssignmentMutator,x=x<<6,>>,4,0.0070647146,x <mask>= x << 6,"                    }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x<mask>= x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                 "
2448,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,590,23484,23484,IdentifierMutator-Variable,x,y,2,2.07597E-4,<mask>,"   buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }<mask> = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                 "
2449,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,590,23484,23484,IdentifierMutator-Variable,x,xx,3,9.860353E-5,<mask>,"   buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }<mask> = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                 "
2450,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,590,23484,23484,IdentifierMutator-Variable,x,z,4,4.746532E-5,<mask>,"   buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }<mask> = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                 "
2451,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,590,23484,23484,FieldReferenceMutator,x,y,2,2.07597E-4,<mask>,"   buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }<mask> = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                 "
2452,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,590,23484,23484,FieldReferenceMutator,x,xx,3,9.860353E-5,<mask>,"   buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }<mask> = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                 "
2453,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,590,23484,23484,FieldReferenceMutator,x,z,4,4.746532E-5,<mask>,"   buffer[pos++] = (byte) (x & MASK_8BITS);
                        }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }<mask> = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                 "
2454,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,590,23489,23492,BinaryOperatorMutator,<<,>>,2,0.06844328,x <mask> 6,"                  }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x<mask>6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break"
2455,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,590,23489,23492,BinaryOperatorMutator,<<,>>>,3,0.052124348,x <mask> 6,"                  }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x<mask>6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break"
2456,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,590,23489,23492,BinaryOperatorMutator,<<,>>,4,0.028745087,x <mask> 6,"                  }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x<mask>6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break"
2457,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,590,23488,23488,IdentifierMutator-Variable,x,0,1,5.983749E-4,<mask>,"                   }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x =<mask> << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                   "
2458,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,590,23488,23488,IdentifierMutator-Variable,x,y,2,5.2144076E-4,<mask>,"                   }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x =<mask> << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                   "
2459,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,590,23488,23488,IdentifierMutator-Variable,x,1,4,2.0536307E-4,<mask>,"                   }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x =<mask> << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                   "
2460,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,590,23488,23488,FieldReferenceMutator,x,0,1,5.983749E-4,<mask>,"                   }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x =<mask> << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                   "
2461,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,590,23488,23488,FieldReferenceMutator,x,y,2,5.2144076E-4,<mask>,"                   }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x =<mask> << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                   "
2462,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,590,23488,23488,FieldReferenceMutator,x,1,4,2.0536307E-4,<mask>,"                   }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x =<mask> << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                   "
2463,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,590,23493,23493,IdentifierMutator-Literal,6,8,1,0.1464784,<mask>,"                 }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x <<<mask>;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;"
2464,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,590,23493,23493,IdentifierMutator-Literal,6,4,2,0.13556318,<mask>,"                 }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x <<<mask>;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;"
2465,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,590,23493,23493,IdentifierMutator-Literal,6,2,3,0.10478029,<mask>,"                 }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x <<<mask>;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;"
2466,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,590,23493,23493,IdentifierMutator-Literal,6,7,4,0.10056998,<mask>,"                 }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x <<<mask>;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;"
2467,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,591,23516,23522,IdentifierMutator-Variable,modulus,type,0,0.2033261,<mask>," }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (<mask>) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
   "
2468,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,591,23516,23522,IdentifierMutator-Variable,modulus,x,1,0.07539644,<mask>," }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (<mask>) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
   "
2469,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,591,23516,23522,IdentifierMutator-Variable,modulus,mode,2,0.06885229,<mask>," }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (<mask>) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
   "
2470,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,591,23516,23522,IdentifierMutator-Variable,modulus,bit,3,0.041046277,<mask>," }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (<mask>) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
   "
2471,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,591,23516,23522,IdentifierMutator-Variable,modulus,version,4,0.0348058,<mask>," }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (<mask>) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
   "
2472,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,591,23516,23522,FieldReferenceMutator,modulus,type,0,0.2033261,<mask>," }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (<mask>) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
   "
2473,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,591,23516,23522,FieldReferenceMutator,modulus,x,1,0.07539644,<mask>," }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (<mask>) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
   "
2474,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,591,23516,23522,FieldReferenceMutator,modulus,mode,2,0.06885229,<mask>," }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (<mask>) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
   "
2475,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,591,23516,23522,FieldReferenceMutator,modulus,bit,3,0.041046277,<mask>," }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (<mask>) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
   "
2476,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,591,23516,23522,FieldReferenceMutator,modulus,version,4,0.0348058,<mask>," }
                    }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (<mask>) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
   "
2477,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,592,23548,23548,IdentifierMutator-Literal,2,1,1,0.32980114,<mask>," }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case<mask> :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2478,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,592,23548,23548,IdentifierMutator-Literal,2,0,2,0.050545204,<mask>," }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case<mask> :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2479,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,592,23548,23548,IdentifierMutator-Literal,2,4,3,0.015352067,<mask>," }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case<mask> :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2480,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,592,23548,23548,IdentifierMutator-Literal,2,3,4,0.012019825,<mask>," }
                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case<mask> :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2481,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,593,23573,23573,AssignmentMutator,x=x<<6,|,0,0.4796542,x <mask>= x << 6,"        }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x<mask>= x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2482,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,593,23573,23573,AssignmentMutator,x=x<<6,^,1,0.46456793,x <mask>= x << 6,"        }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x<mask>= x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2483,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,593,23573,23573,AssignmentMutator,x=x<<6,*,2,0.023589397,x <mask>= x << 6,"        }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x<mask>= x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2484,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,593,23573,23573,AssignmentMutator,x=x<<6,&,3,0.0064461045,x <mask>= x << 6,"        }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x<mask>= x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2485,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,593,23573,23573,AssignmentMutator,x=x<<6,>>,4,0.003513156,x <mask>= x << 6,"        }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x<mask>= x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2486,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,593,23572,23572,IdentifierMutator-Variable,x,xx,2,0.001525475,<mask>,"                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :<mask> = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2487,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,593,23572,23572,IdentifierMutator-Variable,x,y,3,0.0014450594,<mask>,"                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :<mask> = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2488,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,593,23572,23572,IdentifierMutator-Variable,x,z,4,4.2912888E-4,<mask>,"                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :<mask> = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2489,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,593,23572,23572,FieldReferenceMutator,x,xx,2,0.001525475,<mask>,"                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :<mask> = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2490,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,593,23572,23572,FieldReferenceMutator,x,y,3,0.0014450594,<mask>,"                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :<mask> = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2491,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,593,23572,23572,FieldReferenceMutator,x,z,4,4.2912888E-4,<mask>,"                }
            }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :<mask> = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2492,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,593,23577,23580,BinaryOperatorMutator,<<,>>,2,0.100474015,x <mask> 6,"      }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x<mask>6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2493,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,593,23577,23580,BinaryOperatorMutator,<<,>>,3,0.06889434,x <mask> 6,"      }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x<mask>6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2494,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,593,23577,23580,BinaryOperatorMutator,<<,>>>,4,0.06130512,x <mask> 6,"      }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x<mask>6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2495,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,593,23576,23576,IdentifierMutator-Variable,x,y,1,4.56162E-4,<mask>,"       }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x =<mask> << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2496,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,593,23576,23576,IdentifierMutator-Variable,x,0,2,3.200194E-4,<mask>,"       }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x =<mask> << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2497,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,593,23576,23576,IdentifierMutator-Variable,x,1,4,2.3334697E-4,<mask>,"       }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x =<mask> << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2498,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,593,23576,23576,FieldReferenceMutator,x,y,1,4.56162E-4,<mask>,"       }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x =<mask> << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2499,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,593,23576,23576,FieldReferenceMutator,x,0,2,3.200194E-4,<mask>,"       }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x =<mask> << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2500,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,593,23576,23576,FieldReferenceMutator,x,1,4,2.3334697E-4,<mask>,"       }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x =<mask> << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2501,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,593,23581,23581,IdentifierMutator-Literal,6,8,1,0.15928441,<mask>,"     }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x <<<mask>;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2502,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,593,23581,23581,IdentifierMutator-Literal,6,7,2,0.1068168,<mask>,"     }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x <<<mask>;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2503,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,593,23581,23581,IdentifierMutator-Literal,6,4,3,0.06270376,<mask>,"     }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x <<<mask>;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2504,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,593,23581,23581,IdentifierMutator-Literal,6,12,4,0.05580451,<mask>,"     }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x <<<mask>;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2505,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,594,23617,23617,AssignmentMutator,buffer[pos++]=((byte)((x>>16)&org.apache.commons.codec.binary.Base64.MASK_8BITS)),|,0,0.7735708,buffer[pos++] <mask>= ((byte) ((x >> 16) & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"OF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++]<mask>= (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2506,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,594,23617,23617,AssignmentMutator,buffer[pos++]=((byte)((x>>16)&org.apache.commons.codec.binary.Base64.MASK_8BITS)),^,1,0.195467,buffer[pos++] <mask>= ((byte) ((x >> 16) & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"OF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++]<mask>= (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2507,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,594,23617,23617,AssignmentMutator,buffer[pos++]=((byte)((x>>16)&org.apache.commons.codec.binary.Base64.MASK_8BITS)),&,2,0.012697967,buffer[pos++] <mask>= ((byte) ((x >> 16) & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"OF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++]<mask>= (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2508,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,594,23617,23617,AssignmentMutator,buffer[pos++]=((byte)((x>>16)&org.apache.commons.codec.binary.Base64.MASK_8BITS)),*,3,0.006158751,buffer[pos++] <mask>= ((byte) ((x >> 16) & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"OF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++]<mask>= (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2509,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,594,23617,23617,AssignmentMutator,buffer[pos++]=((byte)((x>>16)&org.apache.commons.codec.binary.Base64.MASK_8BITS)),~,4,0.0016488344,buffer[pos++] <mask>= ((byte) ((x >> 16) & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"OF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++]<mask>= (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2510,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,594,23611,23615,ArrayAccessMutator,pos++,pos,0,0.99585944,buffer[<mask>]," forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[<mask>] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2511,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,594,23611,23615,ArrayAccessMutator,pos++,++,1,7.4877805E-4,buffer[<mask>]," forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[<mask>] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2512,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,594,23611,23615,ArrayAccessMutator,pos++,push,2,2.9022826E-4,buffer[<mask>]," forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[<mask>] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2513,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,594,23611,23615,ArrayAccessMutator,pos++,0,3,2.8300105E-4,buffer[<mask>]," forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[<mask>] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2514,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,594,23611,23615,ArrayAccessMutator,pos++,position,4,2.3912809E-4,buffer[<mask>]," forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[<mask>] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2515,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,594,23604,23609,IdentifierMutator-Variable,buffer,buf,2,1.4720186E-4,<mask>,"   }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;<mask>[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2516,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,594,23604,23609,IdentifierMutator-Variable,buffer,byte,3,1.4608642E-4,<mask>,"   }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;<mask>[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2517,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,594,23604,23609,IdentifierMutator-Variable,buffer,Buffer,4,7.327788E-5,<mask>,"   }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;<mask>[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2518,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,594,23604,23609,FieldReferenceMutator,buffer,buf,2,1.4720186E-4,<mask>,"   }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;<mask>[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2519,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,594,23604,23609,FieldReferenceMutator,buffer,byte,3,1.4608642E-4,<mask>,"   }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;<mask>[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2520,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,594,23604,23609,FieldReferenceMutator,buffer,Buffer,4,7.327788E-5,<mask>,"   }
        }

        // Two forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;<mask>[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2521,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,594,23614,23615,UnaryOperatorMutator,++,+,2,8.98754E-5,pos<mask>," of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos<mask>] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2522,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,594,23614,23615,UnaryOperatorMutator,++,++;,3,5.6084795E-5,pos<mask>," of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos<mask>] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2523,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,594,23614,23615,UnaryOperatorMutator,++,--,4,3.842111E-5,pos<mask>," of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos<mask>] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2524,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,594,23611,23613,IdentifierMutator-Variable,pos,size,1,4.5432047E-5,<mask>," forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[<mask>++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2525,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,594,23611,23613,IdentifierMutator-Variable,pos,len,2,3.0261783E-5,<mask>," forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[<mask>++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2526,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,594,23611,23613,IdentifierMutator-Variable,pos,offset,3,2.3697221E-5,<mask>," forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[<mask>++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2527,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,594,23611,23613,FieldReferenceMutator,pos,size,1,4.5432047E-5,<mask>," forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[<mask>++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2528,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,594,23611,23613,FieldReferenceMutator,pos,len,2,3.0261783E-5,<mask>," forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[<mask>++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2529,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,594,23611,23613,FieldReferenceMutator,pos,offset,3,2.3697221E-5,<mask>," forms of EOF as far as base64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[<mask>++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2530,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,594,23637,23639,BinaryOperatorMutator,&,|,2,0.0011679889,(x >> 16) <mask> org.apache.commons.codec.binary.Base64.MASK_8BITS," concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16)<mask>MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2531,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,594,23637,23639,BinaryOperatorMutator,&,^,3,1.5128766E-4,(x >> 16) <mask> org.apache.commons.codec.binary.Base64.MASK_8BITS," concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16)<mask>MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2532,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,594,23637,23639,BinaryOperatorMutator,&,~,4,4.6823126E-5,(x >> 16) <mask> org.apache.commons.codec.binary.Base64.MASK_8BITS," concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16)<mask>MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2533,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,594,23630,23633,BinaryOperatorMutator,>>,<<,1,0.25771496,x <mask> 16," decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x<mask>16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2534,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,594,23630,23633,BinaryOperatorMutator,>>,<<,3,0.03899748,x <mask> 16," decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x<mask>16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2535,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,594,23630,23633,BinaryOperatorMutator,>>,>>>,4,0.010948587,x <mask> 16," decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x<mask>16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2536,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,594,23629,23629,IdentifierMutator-Variable,x,X,2,1.1562117E-5,<mask>,"64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((<mask> >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2537,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,594,23629,23629,IdentifierMutator-Variable,x,xx,3,8.255228E-6,<mask>,"64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((<mask> >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2538,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,594,23629,23629,IdentifierMutator-Variable,x,y,4,5.365891E-6,<mask>,"64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((<mask> >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2539,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,594,23629,23629,FieldReferenceMutator,x,X,2,1.1562117E-5,<mask>,"64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((<mask> >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2540,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,594,23629,23629,FieldReferenceMutator,x,xx,3,8.255228E-6,<mask>,"64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((<mask> >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2541,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,594,23629,23629,FieldReferenceMutator,x,y,4,5.365891E-6,<mask>,"64 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((<mask> >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2542,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,594,23634,23635,IdentifierMutator-Literal,16,24,1,0.31811813,<mask>,"oder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >><mask>) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2543,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,594,23634,23635,IdentifierMutator-Literal,16,8,2,0.13463777,<mask>,"oder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >><mask>) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2544,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,594,23634,23635,IdentifierMutator-Literal,16,4,3,0.048664458,<mask>,"oder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >><mask>) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2545,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,594,23634,23635,IdentifierMutator-Literal,16,12,4,0.015705626,<mask>,"oder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >><mask>) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2546,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,594,23640,23649,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,mask,0,0.26405695,<mask>,": actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) &<mask>);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2547,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,594,23640,23649,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,255,1,0.1301523,<mask>,": actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) &<mask>);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2548,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,594,23640,23649,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,7,2,0.10426443,<mask>,": actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) &<mask>);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2549,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,594,23640,23649,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,1,3,0.07759937,<mask>,": actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) &<mask>);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2550,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,594,23640,23649,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,bits,4,0.044819035,<mask>,": actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) &<mask>);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2551,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,594,23640,23649,FieldReferenceMutator,MASK_8BITS,mask,0,0.26405695,org.apache.commons.codec.binary.Base64.<mask>,": actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) &<mask>);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2552,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,594,23640,23649,FieldReferenceMutator,MASK_8BITS,255,1,0.1301523,org.apache.commons.codec.binary.Base64.<mask>,": actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) &<mask>);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2553,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,594,23640,23649,FieldReferenceMutator,MASK_8BITS,7,2,0.10426443,org.apache.commons.codec.binary.Base64.<mask>,": actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) &<mask>);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2554,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,594,23640,23649,FieldReferenceMutator,MASK_8BITS,1,3,0.07759937,org.apache.commons.codec.binary.Base64.<mask>,": actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) &<mask>);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2555,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,594,23640,23649,FieldReferenceMutator,MASK_8BITS,bits,4,0.044819035,org.apache.commons.codec.binary.Base64.<mask>,": actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) &<mask>);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2556,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,596,23701,23701,IdentifierMutator-Literal,3,4,1,0.104881994,<mask>,".
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case<mask> :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2557,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,596,23701,23701,IdentifierMutator-Literal,3,1,2,0.098147705,<mask>,".
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case<mask> :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2558,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,596,23701,23701,IdentifierMutator-Literal,3,5,3,0.027398173,<mask>,".
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case<mask> :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2559,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,596,23701,23701,IdentifierMutator-Literal,3,6,4,0.022702621,<mask>,".
        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case<mask> :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2560,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,597,23738,23738,AssignmentMutator,buffer[pos++]=((byte)((x>>16)&org.apache.commons.codec.binary.Base64.MASK_8BITS)),|,0,0.829833,buffer[pos++] <mask>= ((byte) ((x >> 16) & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"      if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++]<mask>= (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2561,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,597,23738,23738,AssignmentMutator,buffer[pos++]=((byte)((x>>16)&org.apache.commons.codec.binary.Base64.MASK_8BITS)),^,1,0.091762155,buffer[pos++] <mask>= ((byte) ((x >> 16) & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"      if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++]<mask>= (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2562,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,597,23738,23738,AssignmentMutator,buffer[pos++]=((byte)((x>>16)&org.apache.commons.codec.binary.Base64.MASK_8BITS)),*,2,0.0275071,buffer[pos++] <mask>= ((byte) ((x >> 16) & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"      if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++]<mask>= (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2563,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,597,23738,23738,AssignmentMutator,buffer[pos++]=((byte)((x>>16)&org.apache.commons.codec.binary.Base64.MASK_8BITS)),<<,3,0.012263914,buffer[pos++] <mask>= ((byte) ((x >> 16) & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"      if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++]<mask>= (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2564,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,597,23738,23738,AssignmentMutator,buffer[pos++]=((byte)((x>>16)&org.apache.commons.codec.binary.Base64.MASK_8BITS)),&,4,0.009726734,buffer[pos++] <mask>= ((byte) ((x >> 16) & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"      if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++]<mask>= (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2565,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,597,23732,23736,ArrayAccessMutator,pos++,pos,0,0.99557555,buffer[<mask>],"         if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[<mask>] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2566,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,597,23732,23736,ArrayAccessMutator,pos++,++,1,5.173479E-4,buffer[<mask>],"         if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[<mask>] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2567,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,597,23732,23736,ArrayAccessMutator,pos++,push,2,4.1859766E-4,buffer[<mask>],"         if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[<mask>] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2568,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,597,23732,23736,ArrayAccessMutator,pos++,position,3,3.720224E-4,buffer[<mask>],"         if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[<mask>] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2569,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,597,23732,23736,ArrayAccessMutator,pos++,offset,4,1.4437486E-4,buffer[<mask>],"         if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[<mask>] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2570,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,597,23725,23730,IdentifierMutator-Variable,buffer,byte,2,0.0016977141,<mask>,"        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :<mask>[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2571,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,597,23725,23730,IdentifierMutator-Variable,buffer,Buffer,3,7.715877E-4,<mask>,"        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :<mask>[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2572,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,597,23725,23730,IdentifierMutator-Variable,buffer,Buffer,4,5.0543936E-4,<mask>,"        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :<mask>[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2573,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,597,23725,23730,FieldReferenceMutator,buffer,byte,2,0.0016977141,<mask>,"        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :<mask>[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2574,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,597,23725,23730,FieldReferenceMutator,buffer,Buffer,3,7.715877E-4,<mask>,"        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :<mask>[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2575,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,597,23725,23730,FieldReferenceMutator,buffer,Buffer,4,5.0543936E-4,<mask>,"        if (eof && modulus != 0) {
            if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :<mask>[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2576,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,597,23735,23736,UnaryOperatorMutator,++,+,1,2.0634422E-4,pos<mask>,"        if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos<mask>] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2577,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,597,23735,23736,UnaryOperatorMutator,++,--,3,1.6948408E-4,pos<mask>,"        if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos<mask>] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2578,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,597,23735,23736,UnaryOperatorMutator,++,++;,4,7.6345845E-5,pos<mask>,"        if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos<mask>] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2579,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,597,23732,23734,IdentifierMutator-Variable,pos,size,1,4.6230365E-5,<mask>,"         if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[<mask>++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2580,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,597,23732,23734,IdentifierMutator-Variable,pos,position,2,3.8649538E-5,<mask>,"         if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[<mask>++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2581,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,597,23732,23734,IdentifierMutator-Variable,pos,len,3,3.601235E-5,<mask>,"         if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[<mask>++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2582,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,597,23732,23734,FieldReferenceMutator,pos,size,1,4.6230365E-5,<mask>,"         if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[<mask>++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2583,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,597,23732,23734,FieldReferenceMutator,pos,position,2,3.8649538E-5,<mask>,"         if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[<mask>++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2584,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,597,23732,23734,FieldReferenceMutator,pos,len,3,3.601235E-5,<mask>,"         if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[<mask>++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2585,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,597,23758,23760,BinaryOperatorMutator,&,|,1,0.014282747,(x >> 16) <mask> org.apache.commons.codec.binary.Base64.MASK_8BITS," null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16)<mask>MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2586,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,597,23758,23760,BinaryOperatorMutator,&,^,3,0.001457236,(x >> 16) <mask> org.apache.commons.codec.binary.Base64.MASK_8BITS," null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16)<mask>MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2587,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,597,23758,23760,BinaryOperatorMutator,&,~,4,6.501879E-4,(x >> 16) <mask> org.apache.commons.codec.binary.Base64.MASK_8BITS," null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16)<mask>MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2588,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,597,23751,23754,BinaryOperatorMutator,>>,<<,2,0.019498052,x <mask> 16," (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x<mask>16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2589,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,597,23751,23754,BinaryOperatorMutator,>>,<<,3,0.0049139205,x <mask> 16," (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x<mask>16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2590,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,597,23751,23754,BinaryOperatorMutator,>>,>>>,4,0.003392858,x <mask> 16," (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x<mask>16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2591,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,597,23750,23750,IdentifierMutator-Variable,x,y,2,8.077759E-6,<mask>," if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((<mask> >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2592,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,597,23750,23750,IdentifierMutator-Variable,x,X,3,7.811631E-6,<mask>," if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((<mask> >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2593,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,597,23750,23750,IdentifierMutator-Variable,x,rx,4,3.0023893E-6,<mask>," if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((<mask> >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2594,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,597,23750,23750,FieldReferenceMutator,x,y,2,8.077759E-6,<mask>," if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((<mask> >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2595,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,597,23750,23750,FieldReferenceMutator,x,X,3,7.811631E-6,<mask>," if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((<mask> >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2596,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,597,23750,23750,FieldReferenceMutator,x,rx,4,3.0023893E-6,<mask>," if (buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((<mask> >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2597,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,597,23755,23756,IdentifierMutator-Literal,16,24,1,0.023323245,<mask>,"buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >><mask>) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2598,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,597,23755,23756,IdentifierMutator-Literal,16,8,2,0.0049974173,<mask>,"buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >><mask>) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2599,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,597,23755,23756,IdentifierMutator-Literal,16,4,3,0.0027953363,<mask>,"buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >><mask>) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2600,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,597,23755,23756,IdentifierMutator-Literal,16,6,4,0.0022078287,<mask>,"buffer == null || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >><mask>) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2601,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,597,23761,23770,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,bits,0,0.12271084,<mask>," || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) &<mask>);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2602,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,597,23761,23770,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,16,1,0.10645362,<mask>," || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) &<mask>);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2603,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,597,23761,23770,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,mask,2,0.06049952,<mask>," || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) &<mask>);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2604,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,597,23761,23770,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,7,3,0.055251904,<mask>," || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) &<mask>);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2605,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,597,23761,23770,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,CRC,4,0.044811912,<mask>," || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) &<mask>);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2606,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,597,23761,23770,FieldReferenceMutator,MASK_8BITS,bits,0,0.12271084,org.apache.commons.codec.binary.Base64.<mask>," || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) &<mask>);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2607,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,597,23761,23770,FieldReferenceMutator,MASK_8BITS,16,1,0.10645362,org.apache.commons.codec.binary.Base64.<mask>," || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) &<mask>);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2608,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,597,23761,23770,FieldReferenceMutator,MASK_8BITS,mask,2,0.06049952,org.apache.commons.codec.binary.Base64.<mask>," || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) &<mask>);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2609,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,597,23761,23770,FieldReferenceMutator,MASK_8BITS,7,3,0.055251904,org.apache.commons.codec.binary.Base64.<mask>," || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) &<mask>);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2610,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,597,23761,23770,FieldReferenceMutator,MASK_8BITS,CRC,4,0.044811912,org.apache.commons.codec.binary.Base64.<mask>," || buffer.length - pos < decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) &<mask>);
                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2611,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,598,23807,23807,AssignmentMutator,buffer[pos++]=((byte)((x>>8)&org.apache.commons.codec.binary.Base64.MASK_8BITS)),|,0,0.75336576,buffer[pos++] <mask>= ((byte) ((x >> 8) & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"           }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++]<mask>= (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2612,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,598,23807,23807,AssignmentMutator,buffer[pos++]=((byte)((x>>8)&org.apache.commons.codec.binary.Base64.MASK_8BITS)),^,1,0.20329462,buffer[pos++] <mask>= ((byte) ((x >> 8) & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"           }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++]<mask>= (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2613,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,598,23807,23807,AssignmentMutator,buffer[pos++]=((byte)((x>>8)&org.apache.commons.codec.binary.Base64.MASK_8BITS)),&,2,0.010760912,buffer[pos++] <mask>= ((byte) ((x >> 8) & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"           }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++]<mask>= (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2614,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,598,23807,23807,AssignmentMutator,buffer[pos++]=((byte)((x>>8)&org.apache.commons.codec.binary.Base64.MASK_8BITS)),*,3,0.010542055,buffer[pos++] <mask>= ((byte) ((x >> 8) & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"           }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++]<mask>= (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2615,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,598,23807,23807,AssignmentMutator,buffer[pos++]=((byte)((x>>8)&org.apache.commons.codec.binary.Base64.MASK_8BITS)),<<,4,0.0060401484,buffer[pos++] <mask>= ((byte) ((x >> 8) & org.apache.commons.codec.binary.Base64.MASK_8BITS)),"           }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++]<mask>= (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2616,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,598,23801,23805,ArrayAccessMutator,pos++,pos,0,0.9832218,buffer[<mask>],"();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[<mask>] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2617,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,598,23801,23805,ArrayAccessMutator,pos++,++,1,0.0034510808,buffer[<mask>],"();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[<mask>] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2618,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,598,23801,23805,ArrayAccessMutator,pos++,len,2,0.001295909,buffer[<mask>],"();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[<mask>] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2619,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,598,23801,23805,ArrayAccessMutator,pos++,neg,3,0.0012627929,buffer[<mask>],"();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[<mask>] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2620,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,598,23801,23805,ArrayAccessMutator,pos++,push,4,6.0124556E-4,buffer[<mask>],"();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[<mask>] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2621,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,598,23794,23799,IdentifierMutator-Variable,buffer,byte,2,0.0011558307,<mask>," decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);<mask>[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2622,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,598,23794,23799,IdentifierMutator-Variable,buffer,buf,3,8.942169E-4,<mask>," decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);<mask>[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2623,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,598,23794,23799,IdentifierMutator-Variable,buffer,Buffer,4,8.8240596E-4,<mask>," decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);<mask>[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2624,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,598,23794,23799,FieldReferenceMutator,buffer,byte,2,0.0011558307,<mask>," decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);<mask>[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2625,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,598,23794,23799,FieldReferenceMutator,buffer,buf,3,8.942169E-4,<mask>," decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);<mask>[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2626,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,598,23794,23799,FieldReferenceMutator,buffer,Buffer,4,8.8240596E-4,<mask>," decodeSize) {
                resizeBuffer();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);<mask>[pos++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2627,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,598,23804,23805,UnaryOperatorMutator,++,--,2,1.96641E-4,pos<mask>,"
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos<mask>] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2628,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,598,23804,23805,UnaryOperatorMutator,++,++;,3,1.08095795E-4,pos<mask>,"
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos<mask>] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2629,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,598,23804,23805,UnaryOperatorMutator,++,+,4,6.994928E-5,pos<mask>,"
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos<mask>] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2630,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,598,23801,23803,IdentifierMutator-Variable,pos,len,1,3.680752E-4,<mask>,"();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[<mask>++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2631,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,598,23801,23803,IdentifierMutator-Variable,pos,neg,2,2.311004E-4,<mask>,"();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[<mask>++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2632,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,598,23801,23803,IdentifierMutator-Variable,pos,size,3,1.6216212E-4,<mask>,"();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[<mask>++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2633,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,598,23801,23803,IdentifierMutator-Variable,pos,end,4,8.0215E-5,<mask>,"();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[<mask>++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2634,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,598,23801,23803,FieldReferenceMutator,pos,len,1,3.680752E-4,<mask>,"();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[<mask>++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2635,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,598,23801,23803,FieldReferenceMutator,pos,neg,2,2.311004E-4,<mask>,"();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[<mask>++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2636,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,598,23801,23803,FieldReferenceMutator,pos,size,3,1.6216212E-4,<mask>,"();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[<mask>++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2637,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,598,23801,23803,FieldReferenceMutator,pos,end,4,8.0215E-5,<mask>,"();
            }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[<mask>++] = (byte) ((x >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2638,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,598,23826,23828,BinaryOperatorMutator,&,|,1,0.0052522095,(x >> 8) <mask> org.apache.commons.codec.binary.Base64.MASK_8BITS,"  }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8)<mask>MASK_8BITS);
                    break;
            }
        }
   "
2639,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,598,23826,23828,BinaryOperatorMutator,&,^,3,4.6928876E-4,(x >> 8) <mask> org.apache.commons.codec.binary.Base64.MASK_8BITS,"  }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8)<mask>MASK_8BITS);
                    break;
            }
        }
   "
2640,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,598,23826,23828,BinaryOperatorMutator,&,~,4,1.1599084E-4,(x >> 8) <mask> org.apache.commons.codec.binary.Base64.MASK_8BITS,"  }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8)<mask>MASK_8BITS);
                    break;
            }
        }
   "
2641,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,598,23820,23823,BinaryOperatorMutator,>>,<<,2,0.039471854,x <mask> 8,"     }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x<mask>8) & MASK_8BITS);
                    break;
            }
        }
   "
2642,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,598,23820,23823,BinaryOperatorMutator,>>,<<,3,0.024058945,x <mask> 8,"     }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x<mask>8) & MASK_8BITS);
                    break;
            }
        }
   "
2643,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,598,23820,23823,BinaryOperatorMutator,>>,>>>,4,0.018388566,x <mask> 8,"     }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x<mask>8) & MASK_8BITS);
                    break;
            }
        }
   "
2644,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,598,23819,23819,IdentifierMutator-Variable,x,y,2,2.2527309E-5,<mask>,"      }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((<mask> >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2645,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,598,23819,23819,IdentifierMutator-Variable,x,xx,3,1.4614718E-5,<mask>,"      }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((<mask> >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2646,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,598,23819,23819,IdentifierMutator-Variable,x,rx,4,9.149704E-6,<mask>,"      }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((<mask> >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2647,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,598,23819,23819,FieldReferenceMutator,x,y,2,2.2527309E-5,<mask>,"      }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((<mask> >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2648,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,598,23819,23819,FieldReferenceMutator,x,xx,3,1.4614718E-5,<mask>,"      }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((<mask> >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2649,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,598,23819,23819,FieldReferenceMutator,x,rx,4,9.149704E-6,<mask>,"      }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((<mask> >> 8) & MASK_8BITS);
                    break;
            }
        }
   "
2650,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,598,23824,23824,IdentifierMutator-Literal,8,16,0,0.42912993,<mask>,"    }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >><mask>) & MASK_8BITS);
                    break;
            }
        }
   "
2651,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,598,23824,23824,IdentifierMutator-Literal,8,6,2,0.08018238,<mask>,"    }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >><mask>) & MASK_8BITS);
                    break;
            }
        }
   "
2652,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,598,23824,23824,IdentifierMutator-Literal,8,24,3,0.024273429,<mask>,"    }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >><mask>) & MASK_8BITS);
                    break;
            }
        }
   "
2653,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,598,23824,23824,IdentifierMutator-Literal,8,12,4,0.019533249,<mask>,"    }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >><mask>) & MASK_8BITS);
                    break;
            }
        }
   "
2654,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,598,23829,23838,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,mask,0,0.17676954,<mask>," }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) &<mask>);
                    break;
            }
        }
   "
2655,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,598,23829,23838,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,255,1,0.15176429,<mask>," }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) &<mask>);
                    break;
            }
        }
   "
2656,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,598,23829,23838,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,1,2,0.11346248,<mask>," }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) &<mask>);
                    break;
            }
        }
   "
2657,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,598,23829,23838,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,7,3,0.100242555,<mask>," }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) &<mask>);
                    break;
            }
        }
   "
2658,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,598,23829,23838,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MASK_8BITS,0,4,0.03969893,<mask>," }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) &<mask>);
                    break;
            }
        }
   "
2659,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,598,23829,23838,FieldReferenceMutator,MASK_8BITS,mask,0,0.17676954,org.apache.commons.codec.binary.Base64.<mask>," }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) &<mask>);
                    break;
            }
        }
   "
2660,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,598,23829,23838,FieldReferenceMutator,MASK_8BITS,255,1,0.15176429,org.apache.commons.codec.binary.Base64.<mask>," }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) &<mask>);
                    break;
            }
        }
   "
2661,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,598,23829,23838,FieldReferenceMutator,MASK_8BITS,1,2,0.11346248,org.apache.commons.codec.binary.Base64.<mask>," }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) &<mask>);
                    break;
            }
        }
   "
2662,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,598,23829,23838,FieldReferenceMutator,MASK_8BITS,7,3,0.100242555,org.apache.commons.codec.binary.Base64.<mask>," }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) &<mask>);
                    break;
            }
        }
   "
2663,Base64.java,decode,"void decode(byte[] in, int inPos, int inAvail)",550,598,23829,23838,FieldReferenceMutator,MASK_8BITS,0,4,0.03969893,org.apache.commons.codec.binary.Base64.<mask>," }
            
            x = x << 6;
            switch (modulus) {
                case 2 :
                    x = x << 6;
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    break;
                case 3 :
                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
                    buffer[pos++] = (byte) ((x >> 8) &<mask>);
                    break;
            }
        }
   "
2664,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24271,24274,BinaryOperatorMutator,||,OR,1,0.023899864,(octet == org.apache.commons.codec.binary.Base64.PAD) <mask> (((octet >= 0) && (octet < org.apache.commons.codec.binary.Base64.DECODE_TABLE.length)) && (org.apache.commons.codec.binary.Base64.DECODE_TABLE[octet] != (-1))),"boolean isBase64(byte octet) {
        return octet == PAD<mask>(octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2665,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24271,24274,BinaryOperatorMutator,||,^,3,0.002628525,(octet == org.apache.commons.codec.binary.Base64.PAD) <mask> (((octet >= 0) && (octet < org.apache.commons.codec.binary.Base64.DECODE_TABLE.length)) && (org.apache.commons.codec.binary.Base64.DECODE_TABLE[octet] != (-1))),"boolean isBase64(byte octet) {
        return octet == PAD<mask>(octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2666,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24271,24274,BinaryOperatorMutator,||,OR,4,0.0026178379,(octet == org.apache.commons.codec.binary.Base64.PAD) <mask> (((octet >= 0) && (octet < org.apache.commons.codec.binary.Base64.DECODE_TABLE.length)) && (org.apache.commons.codec.binary.Base64.DECODE_TABLE[octet] != (-1))),"boolean isBase64(byte octet) {
        return octet == PAD<mask>(octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2667,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24264,24267,BinaryOperatorMutator,==,<,1,0.07549561,octet <mask> org.apache.commons.codec.binary.Base64.PAD,"boolean isBase64(byte octet) {
        return octet<mask>PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2668,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24264,24267,BinaryOperatorMutator,==,<,3,0.056596793,octet <mask> org.apache.commons.codec.binary.Base64.PAD,"boolean isBase64(byte octet) {
        return octet<mask>PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2669,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24264,24267,BinaryOperatorMutator,==,>=,4,0.042312745,octet <mask> org.apache.commons.codec.binary.Base64.PAD,"boolean isBase64(byte octet) {
        return octet<mask>PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2670,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24259,24263,IdentifierMutator-Variable,octet,mode,0,0.118902214,<mask>,"boolean isBase64(byte octet) {
        return<mask> == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2671,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24259,24263,IdentifierMutator-Variable,octet,padding,1,0.082646616,<mask>,"boolean isBase64(byte octet) {
        return<mask> == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2672,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24259,24263,IdentifierMutator-Variable,octet,type,2,0.07587567,<mask>,"boolean isBase64(byte octet) {
        return<mask> == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2673,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24259,24263,IdentifierMutator-Variable,octet,pad,3,0.0528352,<mask>,"boolean isBase64(byte octet) {
        return<mask> == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2674,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24259,24263,IdentifierMutator-Variable,octet,modifier,4,0.0295703,<mask>,"boolean isBase64(byte octet) {
        return<mask> == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2675,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24268,24270,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,0,0,0.6760146,<mask>,"boolean isBase64(byte octet) {
        return octet ==<mask> || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2676,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24268,24270,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,127,1,0.12894018,<mask>,"boolean isBase64(byte octet) {
        return octet ==<mask> || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2677,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24268,24270,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,1,2,0.050043073,<mask>,"boolean isBase64(byte octet) {
        return octet ==<mask> || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2678,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24268,24270,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,128,3,0.015066694,<mask>,"boolean isBase64(byte octet) {
        return octet ==<mask> || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2679,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24268,24270,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.PAD,8,4,0.012161313,<mask>,"boolean isBase64(byte octet) {
        return octet ==<mask> || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2680,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24268,24270,FieldReferenceMutator,PAD,0,0,0.6760146,org.apache.commons.codec.binary.Base64.<mask>,"boolean isBase64(byte octet) {
        return octet ==<mask> || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2681,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24268,24270,FieldReferenceMutator,PAD,127,1,0.12894018,org.apache.commons.codec.binary.Base64.<mask>,"boolean isBase64(byte octet) {
        return octet ==<mask> || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2682,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24268,24270,FieldReferenceMutator,PAD,1,2,0.050043073,org.apache.commons.codec.binary.Base64.<mask>,"boolean isBase64(byte octet) {
        return octet ==<mask> || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2683,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24268,24270,FieldReferenceMutator,PAD,128,3,0.015066694,org.apache.commons.codec.binary.Base64.<mask>,"boolean isBase64(byte octet) {
        return octet ==<mask> || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2684,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24268,24270,FieldReferenceMutator,PAD,8,4,0.012161313,org.apache.commons.codec.binary.Base64.<mask>,"boolean isBase64(byte octet) {
        return octet ==<mask> || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2685,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24317,24320,BinaryOperatorMutator,&&,),2,0.015546207,((octet >= 0) && (octet < org.apache.commons.codec.binary.Base64.DECODE_TABLE.length)) <mask> (org.apache.commons.codec.binary.Base64.DECODE_TABLE[octet] != (-1)),"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length<mask>DECODE_TABLE[octet] != -1);
    }"
2686,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24317,24320,BinaryOperatorMutator,&&,&,3,0.009839209,((octet >= 0) && (octet < org.apache.commons.codec.binary.Base64.DECODE_TABLE.length)) <mask> (org.apache.commons.codec.binary.Base64.DECODE_TABLE[octet] != (-1)),"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length<mask>DECODE_TABLE[octet] != -1);
    }"
2687,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24317,24320,BinaryOperatorMutator,&&,)(,4,0.0053272173,((octet >= 0) && (octet < org.apache.commons.codec.binary.Base64.DECODE_TABLE.length)) <mask> (org.apache.commons.codec.binary.Base64.DECODE_TABLE[octet] != (-1)),"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length<mask>DECODE_TABLE[octet] != -1);
    }"
2688,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24286,24289,BinaryOperatorMutator,&&,&,1,0.007764951,(octet >= 0) <mask> (octet < org.apache.commons.codec.binary.Base64.DECODE_TABLE.length),"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0<mask>octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2689,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24286,24289,BinaryOperatorMutator,&&,;,2,0.0037008193,(octet >= 0) <mask> (octet < org.apache.commons.codec.binary.Base64.DECODE_TABLE.length),"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0<mask>octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2690,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24286,24289,BinaryOperatorMutator,&&,x,4,6.8869506E-4,(octet >= 0) <mask> (octet < org.apache.commons.codec.binary.Base64.DECODE_TABLE.length),"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0<mask>octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2691,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24281,24284,BinaryOperatorMutator,>=,>,1,0.26759663,octet <mask> 0,"boolean isBase64(byte octet) {
        return octet == PAD || (octet<mask>0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2692,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24281,24284,BinaryOperatorMutator,>=,>,2,0.11323387,octet <mask> 0,"boolean isBase64(byte octet) {
        return octet == PAD || (octet<mask>0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2693,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24281,24284,BinaryOperatorMutator,>=,!=,3,0.037270978,octet <mask> 0,"boolean isBase64(byte octet) {
        return octet == PAD || (octet<mask>0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2694,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24281,24284,BinaryOperatorMutator,>=,==,4,0.003949202,octet <mask> 0,"boolean isBase64(byte octet) {
        return octet == PAD || (octet<mask>0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2695,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24276,24280,IdentifierMutator-Variable,octet,offset,0,0.34123796,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (<mask> >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2696,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24276,24280,IdentifierMutator-Variable,octet,oct,1,0.031099137,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (<mask> >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2697,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24276,24280,IdentifierMutator-Variable,octet,byte,2,0.03070193,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (<mask> >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2698,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24276,24280,IdentifierMutator-Variable,octet,length,3,0.026934959,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (<mask> >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2699,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24276,24280,IdentifierMutator-Variable,octet,token,4,0.026479842,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (<mask> >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2700,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24285,24285,IdentifierMutator-Literal,0,65,1,0.05318131,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >=<mask> && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2701,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24285,24285,IdentifierMutator-Literal,0,91,2,0.032727174,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >=<mask> && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2702,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24285,24285,IdentifierMutator-Literal,0,128,3,0.024104824,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >=<mask> && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2703,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24285,24285,IdentifierMutator-Literal,0,32,4,0.023525674,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >=<mask> && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2704,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24295,24297,BinaryOperatorMutator,<,<=,2,0.015910402,octet <mask> org.apache.commons.codec.binary.Base64.DECODE_TABLE.length,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet<mask>DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2705,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24295,24297,BinaryOperatorMutator,<,!=,3,0.0011444645,octet <mask> org.apache.commons.codec.binary.Base64.DECODE_TABLE.length,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet<mask>DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2706,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24295,24297,BinaryOperatorMutator,<,</,4,2.0202502E-4,octet <mask> org.apache.commons.codec.binary.Base64.DECODE_TABLE.length,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet<mask>DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2707,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24290,24294,IdentifierMutator-Variable,octet,offset,0,0.20411907,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 &&<mask> < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2708,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24290,24294,IdentifierMutator-Variable,octet,0,1,0.085765444,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 &&<mask> < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2709,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24290,24294,IdentifierMutator-Variable,octet,oct,2,0.071607515,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 &&<mask> < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2710,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24290,24294,IdentifierMutator-Variable,octet,it,3,0.058209114,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 &&<mask> < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2711,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24290,24294,IdentifierMutator-Variable,octet,index,4,0.035735756,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 &&<mask> < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);
    }"
2712,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24298,24316,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE.length,127,0,0.27685216,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet <<mask> && DECODE_TABLE[octet] != -1);
    }"
2713,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24298,24316,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE.length,256,1,0.13589524,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet <<mask> && DECODE_TABLE[octet] != -1);
    }"
2714,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24298,24316,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE.length,255,2,0.13157357,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet <<mask> && DECODE_TABLE[octet] != -1);
    }"
2715,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24298,24316,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE.length,128,3,0.04964197,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet <<mask> && DECODE_TABLE[octet] != -1);
    }"
2716,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24298,24316,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE.length,9,4,0.04771063,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet <<mask> && DECODE_TABLE[octet] != -1);
    }"
2717,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24298,24309,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE,bytes,0,0.159239,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet <<mask>.length && DECODE_TABLE[octet] != -1);
    }"
2718,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24298,24309,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE,decode,1,0.077534094,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet <<mask>.length && DECODE_TABLE[octet] != -1);
    }"
2719,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24298,24309,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE,alphabet,2,0.07610612,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet <<mask>.length && DECODE_TABLE[octet] != -1);
    }"
2720,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24298,24309,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE,code,3,0.038576912,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet <<mask>.length && DECODE_TABLE[octet] != -1);
    }"
2721,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24298,24309,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE,encoded,4,0.036381837,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet <<mask>.length && DECODE_TABLE[octet] != -1);
    }"
2722,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24298,24309,FieldReferenceMutator,DECODE_TABLE,bytes,0,0.159239,org.apache.commons.codec.binary.Base64.<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet <<mask>.length && DECODE_TABLE[octet] != -1);
    }"
2723,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24298,24309,FieldReferenceMutator,DECODE_TABLE,decode,1,0.077534094,org.apache.commons.codec.binary.Base64.<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet <<mask>.length && DECODE_TABLE[octet] != -1);
    }"
2724,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24298,24309,FieldReferenceMutator,DECODE_TABLE,alphabet,2,0.07610612,org.apache.commons.codec.binary.Base64.<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet <<mask>.length && DECODE_TABLE[octet] != -1);
    }"
2725,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24298,24309,FieldReferenceMutator,DECODE_TABLE,code,3,0.038576912,org.apache.commons.codec.binary.Base64.<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet <<mask>.length && DECODE_TABLE[octet] != -1);
    }"
2726,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24298,24309,FieldReferenceMutator,DECODE_TABLE,encoded,4,0.036381837,org.apache.commons.codec.binary.Base64.<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet <<mask>.length && DECODE_TABLE[octet] != -1);
    }"
2727,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24311,24316,FieldReferenceMutator,length,SIZE,2,0.0028505826,org.apache.commons.codec.binary.Base64.DECODE_TABLE.<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.<mask> && DECODE_TABLE[octet] != -1);
    }"
2728,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24311,24316,FieldReferenceMutator,length,Length,3,0.0016526881,org.apache.commons.codec.binary.Base64.DECODE_TABLE.<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.<mask> && DECODE_TABLE[octet] != -1);
    }"
2729,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24311,24316,FieldReferenceMutator,length,size,4,8.5723493E-4,org.apache.commons.codec.binary.Base64.DECODE_TABLE.<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.<mask> && DECODE_TABLE[octet] != -1);
    }"
2730,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24340,24343,BinaryOperatorMutator,!=,==,1,0.23318279,org.apache.commons.codec.binary.Base64.DECODE_TABLE[octet] <mask> (-1),"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet]<mask>-1);
    }"
2731,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24340,24343,BinaryOperatorMutator,!=,==,2,0.119848505,org.apache.commons.codec.binary.Base64.DECODE_TABLE[octet] <mask> (-1),"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet]<mask>-1);
    }"
2732,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24340,24343,BinaryOperatorMutator,!=,>,3,0.058224294,org.apache.commons.codec.binary.Base64.DECODE_TABLE[octet] <mask> (-1),"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet]<mask>-1);
    }"
2733,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24340,24343,BinaryOperatorMutator,!=,>,4,0.043894295,org.apache.commons.codec.binary.Base64.DECODE_TABLE[octet] <mask> (-1),"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet]<mask>-1);
    }"
2734,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24334,24338,ArrayAccessMutator,octet,oct,0,0.5286201,org.apache.commons.codec.binary.Base64.DECODE_TABLE[<mask>],"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[<mask>] != -1);
    }"
2735,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24334,24338,ArrayAccessMutator,octet,offset,1,0.07834759,org.apache.commons.codec.binary.Base64.DECODE_TABLE[<mask>],"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[<mask>] != -1);
    }"
2736,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24334,24338,ArrayAccessMutator,octet,letter,2,0.02860076,org.apache.commons.codec.binary.Base64.DECODE_TABLE[<mask>],"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[<mask>] != -1);
    }"
2737,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24334,24338,ArrayAccessMutator,octet,0,3,0.027785495,org.apache.commons.codec.binary.Base64.DECODE_TABLE[<mask>],"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[<mask>] != -1);
    }"
2738,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24334,24338,ArrayAccessMutator,octet,et,4,0.026095012,org.apache.commons.codec.binary.Base64.DECODE_TABLE[<mask>],"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[<mask>] != -1);
    }"
2739,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24321,24332,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE,table,0,0.19627516,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length &&<mask>[octet] != -1);
    }"
2740,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24321,24332,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE,bytes,1,0.09361875,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length &&<mask>[octet] != -1);
    }"
2741,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24321,24332,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE,decode,2,0.07034788,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length &&<mask>[octet] != -1);
    }"
2742,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24321,24332,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE,codes,3,0.045413338,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length &&<mask>[octet] != -1);
    }"
2743,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24321,24332,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.DECODE_TABLE,alphabet,4,0.038723953,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length &&<mask>[octet] != -1);
    }"
2744,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24321,24332,FieldReferenceMutator,DECODE_TABLE,table,0,0.19627516,org.apache.commons.codec.binary.Base64.<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length &&<mask>[octet] != -1);
    }"
2745,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24321,24332,FieldReferenceMutator,DECODE_TABLE,bytes,1,0.09361875,org.apache.commons.codec.binary.Base64.<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length &&<mask>[octet] != -1);
    }"
2746,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24321,24332,FieldReferenceMutator,DECODE_TABLE,decode,2,0.07034788,org.apache.commons.codec.binary.Base64.<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length &&<mask>[octet] != -1);
    }"
2747,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24321,24332,FieldReferenceMutator,DECODE_TABLE,codes,3,0.045413338,org.apache.commons.codec.binary.Base64.<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length &&<mask>[octet] != -1);
    }"
2748,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24321,24332,FieldReferenceMutator,DECODE_TABLE,alphabet,4,0.038723953,org.apache.commons.codec.binary.Base64.<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length &&<mask>[octet] != -1);
    }"
2749,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24334,24338,IdentifierMutator-Variable,octet,oct,0,0.5286201,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[<mask>] != -1);
    }"
2750,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24334,24338,IdentifierMutator-Variable,octet,offset,1,0.07834759,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[<mask>] != -1);
    }"
2751,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24334,24338,IdentifierMutator-Variable,octet,letter,2,0.02860076,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[<mask>] != -1);
    }"
2752,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24334,24338,IdentifierMutator-Variable,octet,0,3,0.027785495,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[<mask>] != -1);
    }"
2753,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24334,24338,IdentifierMutator-Variable,octet,et,4,0.026095012,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[<mask>] != -1);
    }"
2754,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24344,24344,UnaryOperatorMutator,-,$,1,0.22919798,<mask>1,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] !=<mask>1);
    }"
2755,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24344,24344,UnaryOperatorMutator,-,B,2,0.03972629,<mask>1,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] !=<mask>1);
    }"
2756,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24344,24344,UnaryOperatorMutator,-,SHA,3,0.03684826,<mask>1,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] !=<mask>1);
    }"
2757,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24344,24344,UnaryOperatorMutator,-,D,4,0.025036473,<mask>1,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] !=<mask>1);
    }"
2758,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24345,24345,IdentifierMutator-Literal,1,127,2,0.012477205,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -<mask>);
    }"
2759,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24345,24345,IdentifierMutator-Literal,1,2,3,0.0048761726,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -<mask>);
    }"
2760,Base64.java,isBase64,boolean isBase64(byte octet),612,613,24345,24345,IdentifierMutator-Literal,1,xff,4,0.004373362,<mask>,"boolean isBase64(byte octet) {
        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -<mask>);
    }"
2761,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,626,24841,24841,IdentifierMutator-Literal,0,1,2,0.0035594685,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i =<mask>; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2762,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,626,24841,24841,IdentifierMutator-Literal,0,2,3,2.1800085E-4,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i =<mask>; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2763,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,626,24841,24841,IdentifierMutator-Literal,0,1,4,1.453953E-4,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i =<mask>; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2764,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,626,24845,24847,BinaryOperatorMutator,<,++,2,0.0028799244,i <mask> arrayOctet.length,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i<mask>arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2765,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,626,24845,24847,BinaryOperatorMutator,<,==,3,0.0025075444,i <mask> arrayOctet.length,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i<mask>arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2766,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,626,24845,24847,BinaryOperatorMutator,<,+=,4,9.984601E-4,i <mask> arrayOctet.length,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i<mask>arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2767,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,626,24844,24844,IdentifierMutator-Variable,i,I,2,3.408563E-5,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0;<mask> < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2768,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,626,24844,24844,IdentifierMutator-Variable,i,0,3,1.4784161E-5,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0;<mask> < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2769,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,626,24844,24844,IdentifierMutator-Variable,i,j,4,1.0816622E-5,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0;<mask> < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2770,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,626,24848,24864,IdentifierMutator-Variable,arrayOctet.length,length,0,0.122951746,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i <<mask>; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2771,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,626,24848,24864,IdentifierMutator-Variable,arrayOctet.length,256,1,0.12235578,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i <<mask>; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2772,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,626,24848,24864,IdentifierMutator-Variable,arrayOctet.length,8,2,0.09216603,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i <<mask>; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2773,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,626,24848,24864,IdentifierMutator-Variable,arrayOctet.length,4,3,0.08148522,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i <<mask>; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2774,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,626,24848,24864,IdentifierMutator-Variable,arrayOctet.length,size,4,0.052057322,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i <<mask>; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2775,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,626,24848,24857,IdentifierMutator-Variable,arrayOctet,array,0,0.67766297,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i <<mask>.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2776,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,626,24848,24857,IdentifierMutator-Variable,arrayOctet,array,1,0.08930929,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i <<mask>.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2777,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,626,24848,24857,IdentifierMutator-Variable,arrayOctet,Array,2,0.07441305,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i <<mask>.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2778,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,626,24848,24857,IdentifierMutator-Variable,arrayOctet,string,3,0.027874095,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i <<mask>.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2779,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,626,24848,24857,IdentifierMutator-Variable,arrayOctet,byte,4,0.018235441,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i <<mask>.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2780,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,626,24859,24864,FieldReferenceMutator,length,size,1,2.1429358E-4,arrayOctet.<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.<mask>; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2781,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,626,24859,24864,FieldReferenceMutator,length,Length,2,1.12722926E-4,arrayOctet.<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.<mask>; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2782,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,626,24859,24864,FieldReferenceMutator,length,count,4,3.9862476E-5,arrayOctet.<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.<mask>; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2783,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,626,24868,24869,UnaryOperatorMutator,++,++),2,0.0077910745,i<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i<mask>) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2784,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,626,24868,24869,UnaryOperatorMutator,++,++;,3,3.7385066E-4,i<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i<mask>) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2785,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,626,24868,24869,UnaryOperatorMutator,++,*/,4,3.1063764E-4,i<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i<mask>) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2786,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,626,24867,24867,IdentifierMutator-Variable,i,,2,2.6425332E-5,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length;<mask>++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2787,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,626,24867,24867,IdentifierMutator-Variable,i,I,3,2.2259237E-5,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length;<mask>++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2788,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,626,24867,24867,IdentifierMutator-Variable,i,j,4,1.6588043E-5,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length;<mask>++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2789,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,627,24914,24917,BinaryOperatorMutator,&&,||,2,0.009330965,(!org.apache.commons.codec.binary.Base64.isBase64(arrayOctet[i])) <mask> (!org.apache.commons.codec.binary.Base64.isWhiteSpace(arrayOctet[i])),"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i])<mask>!isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2790,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,627,24914,24917,BinaryOperatorMutator,&&,&,3,0.0022995754,(!org.apache.commons.codec.binary.Base64.isBase64(arrayOctet[i])) <mask> (!org.apache.commons.codec.binary.Base64.isWhiteSpace(arrayOctet[i])),"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i])<mask>!isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2791,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,627,24914,24917,BinaryOperatorMutator,&&,|,4,4.6147482E-4,(!org.apache.commons.codec.binary.Base64.isBase64(arrayOctet[i])) <mask> (!org.apache.commons.codec.binary.Base64.isWhiteSpace(arrayOctet[i])),"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i])<mask>!isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2792,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,627,24890,24890,UnaryOperatorMutator,!,(!,2,1.0556497E-4,<mask>org.apache.commons.codec.binary.Base64.isBase64(arrayOctet[i]),"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (<mask>isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2793,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,627,24890,24890,UnaryOperatorMutator,!,!!,3,8.949993E-5,<mask>org.apache.commons.codec.binary.Base64.isBase64(arrayOctet[i]),"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (<mask>isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2794,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,627,24890,24890,UnaryOperatorMutator,!,...,4,8.819677E-5,<mask>org.apache.commons.codec.binary.Base64.isBase64(arrayOctet[i]),"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (<mask>isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2795,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,627,24891,24898,MethodCallMutator,isBase64,empty,0,0.37880233,<mask>(arrayOctet[i]),"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!<mask>(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2796,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,627,24891,24898,MethodCallMutator,isBase64,blank,1,0.09612266,<mask>(arrayOctet[i]),"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!<mask>(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2797,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,627,24891,24898,MethodCallMutator,isBase64,alpha,2,0.089658916,<mask>(arrayOctet[i]),"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!<mask>(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2798,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,627,24891,24898,MethodCallMutator,isBase64,space,3,0.07828203,<mask>(arrayOctet[i]),"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!<mask>(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2799,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,627,24891,24898,MethodCallMutator,isBase64,is,4,0.06573088,<mask>(arrayOctet[i]),"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!<mask>(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2800,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,627,24911,24911,ArrayAccessMutator,i,0,1,8.791312E-5,arrayOctet[<mask>],"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[<mask>]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2801,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,627,24911,24911,ArrayAccessMutator,i,j,3,2.9202614E-5,arrayOctet[<mask>],"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[<mask>]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2802,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,627,24911,24911,ArrayAccessMutator,i,I,4,2.7298442E-5,arrayOctet[<mask>],"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[<mask>]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2803,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,627,24900,24909,IdentifierMutator-Variable,arrayOctet,array,0,0.5709966,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(<mask>[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2804,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,627,24900,24909,IdentifierMutator-Variable,arrayOctet,string,1,0.07290433,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(<mask>[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2805,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,627,24900,24909,IdentifierMutator-Variable,arrayOctet,byte,2,0.050841868,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(<mask>[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2806,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,627,24900,24909,IdentifierMutator-Variable,arrayOctet,Array,3,0.045269314,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(<mask>[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2807,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,627,24900,24909,IdentifierMutator-Variable,arrayOctet,data,4,0.039686188,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(<mask>[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2808,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,627,24911,24911,IdentifierMutator-Variable,i,0,1,8.791312E-5,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[<mask>]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2809,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,627,24911,24911,IdentifierMutator-Variable,i,j,3,2.9202614E-5,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[<mask>]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2810,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,627,24911,24911,IdentifierMutator-Variable,i,I,4,2.7298442E-5,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[<mask>]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2811,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,627,24918,24918,UnaryOperatorMutator,!,(!,1,0.34020975,<mask>org.apache.commons.codec.binary.Base64.isWhiteSpace(arrayOctet[i]),"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) &&<mask>isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2812,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,627,24918,24918,UnaryOperatorMutator,!,(,2,0.0019162291,<mask>org.apache.commons.codec.binary.Base64.isWhiteSpace(arrayOctet[i]),"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) &&<mask>isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2813,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,627,24918,24918,UnaryOperatorMutator,!,!!,4,8.7095425E-5,<mask>org.apache.commons.codec.binary.Base64.isWhiteSpace(arrayOctet[i]),"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) &&<mask>isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2814,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,627,24919,24930,MethodCallMutator,isWhiteSpace,empty,0,0.17688563,<mask>(arrayOctet[i]),"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !<mask>(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2815,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,627,24919,24930,MethodCallMutator,isWhiteSpace,is,1,0.06621986,<mask>(arrayOctet[i]),"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !<mask>(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2816,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,627,24919,24930,MethodCallMutator,isWhiteSpace,array,2,0.0343685,<mask>(arrayOctet[i]),"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !<mask>(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2817,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,627,24919,24930,MethodCallMutator,isWhiteSpace,digit,3,0.030788166,<mask>(arrayOctet[i]),"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !<mask>(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2818,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,627,24919,24930,MethodCallMutator,isWhiteSpace,bytes,4,0.030544871,<mask>(arrayOctet[i]),"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !<mask>(arrayOctet[i])) {
                return false;
            }
        }
        return true;
    }"
2819,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,627,24943,24943,ArrayAccessMutator,i,j,1,1.4602471E-4,arrayOctet[<mask>],"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[<mask>])) {
                return false;
            }
        }
        return true;
    }"
2820,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,627,24943,24943,ArrayAccessMutator,i,I,3,7.9151854E-5,arrayOctet[<mask>],"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[<mask>])) {
                return false;
            }
        }
        return true;
    }"
2821,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,627,24943,24943,ArrayAccessMutator,i,0,4,5.552991E-5,arrayOctet[<mask>],"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[<mask>])) {
                return false;
            }
        }
        return true;
    }"
2822,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,627,24932,24941,IdentifierMutator-Variable,arrayOctet,array,0,0.45342407,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(<mask>[i])) {
                return false;
            }
        }
        return true;
    }"
2823,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,627,24932,24941,IdentifierMutator-Variable,arrayOctet,string,1,0.13066486,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(<mask>[i])) {
                return false;
            }
        }
        return true;
    }"
2824,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,627,24932,24941,IdentifierMutator-Variable,arrayOctet,byte,2,0.052330207,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(<mask>[i])) {
                return false;
            }
        }
        return true;
    }"
2825,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,627,24932,24941,IdentifierMutator-Variable,arrayOctet,Array,3,0.039709173,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(<mask>[i])) {
                return false;
            }
        }
        return true;
    }"
2826,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,627,24932,24941,IdentifierMutator-Variable,arrayOctet,data,4,0.031672865,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(<mask>[i])) {
                return false;
            }
        }
        return true;
    }"
2827,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,627,24943,24943,IdentifierMutator-Variable,i,j,1,1.4602471E-4,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[<mask>])) {
                return false;
            }
        }
        return true;
    }"
2828,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,627,24943,24943,IdentifierMutator-Variable,i,I,3,7.9151854E-5,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[<mask>])) {
                return false;
            }
        }
        return true;
    }"
2829,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,627,24943,24943,IdentifierMutator-Variable,i,0,4,5.552991E-5,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[<mask>])) {
                return false;
            }
        }
        return true;
    }"
2830,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,628,24973,24977,IdentifierMutator-Literal,false,true,1,0.049490158,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return<mask>;
            }
        }
        return true;
    }"
2831,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,628,24973,24977,IdentifierMutator-Literal,false,FALSE,2,2.4336837E-4,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return<mask>;
            }
        }
        return true;
    }"
2832,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,628,24973,24977,IdentifierMutator-Literal,false,0,3,1.917821E-4,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return<mask>;
            }
        }
        return true;
    }"
2833,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,628,24973,24977,IdentifierMutator-Literal,false,False,4,1.7795908E-4,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return<mask>;
            }
        }
        return true;
    }"
2834,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,631,25019,25022,IdentifierMutator-Literal,true,false,1,0.04038392,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return<mask>;
    }"
2835,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,631,25019,25022,IdentifierMutator-Literal,true,null,2,1.8374268E-4,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return<mask>;
    }"
2836,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,631,25019,25022,IdentifierMutator-Literal,true,1,3,1.7323364E-4,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return<mask>;
    }"
2837,Base64.java,isArrayByteBase64,boolean isArrayByteBase64(byte[] arrayOctet),625,631,25019,25022,IdentifierMutator-Literal,true,0,4,1.436519E-4,<mask>,"boolean isArrayByteBase64(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {
                return false;
            }
        }
        return<mask>;
    }"
2838,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),641,642,25414,25414,IdentifierMutator-Literal,0,1,2,0.003959158,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i =<mask>; i < arrayOctet.length; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2839,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),641,642,25414,25414,IdentifierMutator-Literal,0,2,3,2.262098E-4,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i =<mask>; i < arrayOctet.length; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2840,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),641,642,25414,25414,IdentifierMutator-Literal,0,1,4,1.558296E-4,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i =<mask>; i < arrayOctet.length; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2841,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),641,642,25418,25420,BinaryOperatorMutator,<,++,2,0.0026359782,i <mask> arrayOctet.length,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i<mask>arrayOctet.length; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2842,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),641,642,25418,25420,BinaryOperatorMutator,<,==,3,0.0019484478,i <mask> arrayOctet.length,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i<mask>arrayOctet.length; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2843,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),641,642,25418,25420,BinaryOperatorMutator,<,+=,4,9.264703E-4,i <mask> arrayOctet.length,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i<mask>arrayOctet.length; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2844,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),641,642,25417,25417,IdentifierMutator-Variable,i,I,2,3.6854744E-5,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0;<mask> < arrayOctet.length; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2845,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),641,642,25417,25417,IdentifierMutator-Variable,i,0,3,1.640468E-5,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0;<mask> < arrayOctet.length; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2846,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),641,642,25417,25417,IdentifierMutator-Variable,i,j,4,1.3535984E-5,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0;<mask> < arrayOctet.length; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2847,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),641,642,25421,25437,IdentifierMutator-Variable,arrayOctet.length,256,0,0.14680465,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i <<mask>; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2848,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),641,642,25421,25437,IdentifierMutator-Variable,arrayOctet.length,8,1,0.11345136,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i <<mask>; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2849,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),641,642,25421,25437,IdentifierMutator-Variable,arrayOctet.length,length,2,0.087559626,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i <<mask>; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2850,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),641,642,25421,25437,IdentifierMutator-Variable,arrayOctet.length,4,3,0.07424522,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i <<mask>; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2851,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),641,642,25421,25437,IdentifierMutator-Variable,arrayOctet.length,32,4,0.046386782,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i <<mask>; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2852,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),641,642,25421,25430,IdentifierMutator-Variable,arrayOctet,array,0,0.72395766,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i <<mask>.length; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2853,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),641,642,25421,25430,IdentifierMutator-Variable,arrayOctet,byte,1,0.044849873,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i <<mask>.length; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2854,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),641,642,25421,25430,IdentifierMutator-Variable,arrayOctet,string,2,0.023763862,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i <<mask>.length; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2855,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),641,642,25421,25430,IdentifierMutator-Variable,arrayOctet,Array,3,0.019308094,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i <<mask>.length; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2856,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),641,642,25421,25430,IdentifierMutator-Variable,arrayOctet,buffer,4,0.019216686,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i <<mask>.length; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2857,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),641,642,25432,25437,FieldReferenceMutator,length,size,1,1.707799E-4,arrayOctet.<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.<mask>; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2858,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),641,642,25432,25437,FieldReferenceMutator,length,Length,3,9.1871945E-5,arrayOctet.<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.<mask>; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2859,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),641,642,25432,25437,FieldReferenceMutator,length,count,4,3.4216948E-5,arrayOctet.<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.<mask>; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2860,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),641,642,25441,25442,UnaryOperatorMutator,++,++),2,0.0064816885,i<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i<mask>) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2861,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),641,642,25441,25442,UnaryOperatorMutator,++,*/,3,3.7730436E-4,i<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i<mask>) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2862,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),641,642,25441,25442,UnaryOperatorMutator,++,++;,4,3.5322306E-4,i<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i<mask>) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2863,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),641,642,25440,25440,IdentifierMutator-Variable,i,I,2,3.095618E-5,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length;<mask>++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2864,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),641,642,25440,25440,IdentifierMutator-Variable,i,,3,1.6567137E-5,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length;<mask>++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2865,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),641,642,25440,25440,IdentifierMutator-Variable,i,j,4,1.5247159E-5,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length;<mask>++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2866,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),641,643,25463,25470,MethodCallMutator,isBase64,bytes,0,0.05634457,<mask>(arrayOctet[i]),"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (<mask>(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2867,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),641,643,25463,25470,MethodCallMutator,isBase64,check,1,0.051514942,<mask>(arrayOctet[i]),"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (<mask>(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2868,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),641,643,25463,25470,MethodCallMutator,isBase64,match,2,0.0469116,<mask>(arrayOctet[i]),"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (<mask>(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2869,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),641,643,25463,25470,MethodCallMutator,isBase64,is,3,0.045205876,<mask>(arrayOctet[i]),"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (<mask>(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2870,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),641,643,25463,25470,MethodCallMutator,isBase64,contains,4,0.043610103,<mask>(arrayOctet[i]),"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (<mask>(arrayOctet[i])) {
                return true;
            }
        }
        return false;
    }"
2871,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),641,643,25483,25483,ArrayAccessMutator,i,0,2,1.6736319E-4,arrayOctet[<mask>],"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (isBase64(arrayOctet[<mask>])) {
                return true;
            }
        }
        return false;
    }"
2872,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),641,643,25483,25483,ArrayAccessMutator,i,I,3,1.6114512E-4,arrayOctet[<mask>],"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (isBase64(arrayOctet[<mask>])) {
                return true;
            }
        }
        return false;
    }"
2873,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),641,643,25483,25483,ArrayAccessMutator,i,j,4,2.1005095E-5,arrayOctet[<mask>],"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (isBase64(arrayOctet[<mask>])) {
                return true;
            }
        }
        return false;
    }"
2874,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),641,643,25472,25481,IdentifierMutator-Variable,arrayOctet,array,0,0.24167866,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (isBase64(<mask>[i])) {
                return true;
            }
        }
        return false;
    }"
2875,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),641,643,25472,25481,IdentifierMutator-Variable,arrayOctet,byte,1,0.2171457,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (isBase64(<mask>[i])) {
                return true;
            }
        }
        return false;
    }"
2876,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),641,643,25472,25481,IdentifierMutator-Variable,arrayOctet,data,2,0.076957785,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (isBase64(<mask>[i])) {
                return true;
            }
        }
        return false;
    }"
2877,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),641,643,25472,25481,IdentifierMutator-Variable,arrayOctet,buffer,3,0.0666544,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (isBase64(<mask>[i])) {
                return true;
            }
        }
        return false;
    }"
2878,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),641,643,25472,25481,IdentifierMutator-Variable,arrayOctet,string,4,0.05060413,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (isBase64(<mask>[i])) {
                return true;
            }
        }
        return false;
    }"
2879,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),641,643,25483,25483,IdentifierMutator-Variable,i,0,2,1.6736319E-4,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (isBase64(arrayOctet[<mask>])) {
                return true;
            }
        }
        return false;
    }"
2880,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),641,643,25483,25483,IdentifierMutator-Variable,i,I,3,1.6114512E-4,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (isBase64(arrayOctet[<mask>])) {
                return true;
            }
        }
        return false;
    }"
2881,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),641,643,25483,25483,IdentifierMutator-Variable,i,j,4,2.1005095E-5,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (isBase64(arrayOctet[<mask>])) {
                return true;
            }
        }
        return false;
    }"
2882,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),641,644,25513,25516,IdentifierMutator-Literal,true,i,1,0.0021050747,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (isBase64(arrayOctet[i])) {
                return<mask>;
            }
        }
        return false;
    }"
2883,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),641,644,25513,25516,IdentifierMutator-Literal,true,false,2,0.0015918087,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (isBase64(arrayOctet[i])) {
                return<mask>;
            }
        }
        return false;
    }"
2884,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),641,644,25513,25516,IdentifierMutator-Literal,true,1,3,9.919776E-5,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (isBase64(arrayOctet[i])) {
                return<mask>;
            }
        }
        return false;
    }"
2885,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),641,644,25513,25516,IdentifierMutator-Literal,true,True,4,9.051935E-5,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (isBase64(arrayOctet[i])) {
                return<mask>;
            }
        }
        return false;
    }"
2886,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),641,647,25558,25562,IdentifierMutator-Literal,false,true,1,0.005027194,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return<mask>;
    }"
2887,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),641,647,25558,25562,IdentifierMutator-Literal,false,False,2,2.1422916E-4,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return<mask>;
    }"
2888,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),641,647,25558,25562,IdentifierMutator-Literal,false,null,3,1.6523841E-4,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return<mask>;
    }"
2889,Base64.java,containsBase64Byte,boolean containsBase64Byte(byte[] arrayOctet),641,647,25558,25562,IdentifierMutator-Literal,false,undefined,4,8.806465E-5,<mask>,"boolean containsBase64Byte(byte[] arrayOctet) {
        for (int i = 0; i < arrayOctet.length; i++) {
            if (isBase64(arrayOctet[i])) {
                return true;
            }
        }
        return<mask>;
    }"
2890,Base64.java,encodeBase64,byte[] encodeBase64(byte[] binaryData),657,658,25902,25913,MethodCallMutator,encodeBase64,encode,0,0.94405687,"<mask>(binaryData, false)","byte[] encodeBase64(byte[] binaryData) {
        return<mask>(binaryData, false);
    }"
2891,Base64.java,encodeBase64,byte[] encodeBase64(byte[] binaryData),657,658,25902,25913,MethodCallMutator,encodeBase64,decode,1,0.039374847,"<mask>(binaryData, false)","byte[] encodeBase64(byte[] binaryData) {
        return<mask>(binaryData, false);
    }"
2892,Base64.java,encodeBase64,byte[] encodeBase64(byte[] binaryData),657,658,25902,25913,MethodCallMutator,encodeBase64,encrypt,2,0.0022694818,"<mask>(binaryData, false)","byte[] encodeBase64(byte[] binaryData) {
        return<mask>(binaryData, false);
    }"
2893,Base64.java,encodeBase64,byte[] encodeBase64(byte[] binaryData),657,658,25902,25913,MethodCallMutator,encodeBase64,write,3,0.0014574287,"<mask>(binaryData, false)","byte[] encodeBase64(byte[] binaryData) {
        return<mask>(binaryData, false);
    }"
2894,Base64.java,encodeBase64,byte[] encodeBase64(byte[] binaryData),657,658,25902,25913,MethodCallMutator,encodeBase64,convert,4,0.0012849576,"<mask>(binaryData, false)","byte[] encodeBase64(byte[] binaryData) {
        return<mask>(binaryData, false);
    }"
2895,Base64.java,encodeBase64,byte[] encodeBase64(byte[] binaryData),657,658,25915,25924,IdentifierMutator-Variable,binaryData,data,0,0.56965536,<mask>,"byte[] encodeBase64(byte[] binaryData) {
        return encodeBase64(<mask>, false);
    }"
2896,Base64.java,encodeBase64,byte[] encodeBase64(byte[] binaryData),657,658,25915,25924,IdentifierMutator-Variable,binaryData,binary,1,0.34878767,<mask>,"byte[] encodeBase64(byte[] binaryData) {
        return encodeBase64(<mask>, false);
    }"
2897,Base64.java,encodeBase64,byte[] encodeBase64(byte[] binaryData),657,658,25915,25924,IdentifierMutator-Variable,binaryData,bin,2,0.014435808,<mask>,"byte[] encodeBase64(byte[] binaryData) {
        return encodeBase64(<mask>, false);
    }"
2898,Base64.java,encodeBase64,byte[] encodeBase64(byte[] binaryData),657,658,25915,25924,IdentifierMutator-Variable,binaryData,bytes,3,0.011640079,<mask>,"byte[] encodeBase64(byte[] binaryData) {
        return encodeBase64(<mask>, false);
    }"
2899,Base64.java,encodeBase64,byte[] encodeBase64(byte[] binaryData),657,658,25915,25924,IdentifierMutator-Variable,binaryData,input,4,0.006641374,<mask>,"byte[] encodeBase64(byte[] binaryData) {
        return encodeBase64(<mask>, false);
    }"
2900,Base64.java,encodeBase64,byte[] encodeBase64(byte[] binaryData),657,658,25927,25931,IdentifierMutator-Literal,false,true,0,0.41194126,<mask>,"byte[] encodeBase64(byte[] binaryData) {
        return encodeBase64(binaryData,<mask>);
    }"
2901,Base64.java,encodeBase64,byte[] encodeBase64(byte[] binaryData),657,658,25927,25931,IdentifierMutator-Literal,false,encoding,1,0.18011749,<mask>,"byte[] encodeBase64(byte[] binaryData) {
        return encodeBase64(binaryData,<mask>);
    }"
2902,Base64.java,encodeBase64,byte[] encodeBase64(byte[] binaryData),657,658,25927,25931,IdentifierMutator-Literal,false,enc,3,0.026365332,<mask>,"byte[] encodeBase64(byte[] binaryData) {
        return encodeBase64(binaryData,<mask>);
    }"
2903,Base64.java,encodeBase64,byte[] encodeBase64(byte[] binaryData),657,658,25927,25931,IdentifierMutator-Literal,false,null,4,0.02244457,<mask>,"byte[] encodeBase64(byte[] binaryData) {
        return encodeBase64(binaryData,<mask>);
    }"
2904,Base64.java,encodeBase64String,String encodeBase64String(byte[] binaryData),669,670,26294,26306,MethodCallMutator,newStringUtf8,escape,0,0.23385602,"StringUtils.<mask>(encodeBase64(binaryData, false))","String encodeBase64String(byte[] binaryData) {
        return StringUtils.<mask>(encodeBase64(binaryData, false));
    }"
2905,Base64.java,encodeBase64String,String encodeBase64String(byte[] binaryData),669,670,26294,26306,MethodCallMutator,newStringUtf8,strip,1,0.107515045,"StringUtils.<mask>(encodeBase64(binaryData, false))","String encodeBase64String(byte[] binaryData) {
        return StringUtils.<mask>(encodeBase64(binaryData, false));
    }"
2906,Base64.java,encodeBase64String,String encodeBase64String(byte[] binaryData),669,670,26294,26306,MethodCallMutator,newStringUtf8,format,2,0.0642058,"StringUtils.<mask>(encodeBase64(binaryData, false))","String encodeBase64String(byte[] binaryData) {
        return StringUtils.<mask>(encodeBase64(binaryData, false));
    }"
2907,Base64.java,encodeBase64String,String encodeBase64String(byte[] binaryData),669,670,26294,26306,MethodCallMutator,newStringUtf8,str,3,0.057990506,"StringUtils.<mask>(encodeBase64(binaryData, false))","String encodeBase64String(byte[] binaryData) {
        return StringUtils.<mask>(encodeBase64(binaryData, false));
    }"
2908,Base64.java,encodeBase64String,String encodeBase64String(byte[] binaryData),669,670,26294,26306,MethodCallMutator,newStringUtf8,copy,4,0.057060964,"StringUtils.<mask>(encodeBase64(binaryData, false))","String encodeBase64String(byte[] binaryData) {
        return StringUtils.<mask>(encodeBase64(binaryData, false));
    }"
2909,Base64.java,encodeBase64String,String encodeBase64String(byte[] binaryData),669,670,26308,26319,MethodCallMutator,encodeBase64,append,0,0.12281522,"<mask>(binaryData, false)","String encodeBase64String(byte[] binaryData) {
        return StringUtils.newStringUtf8(<mask>(binaryData, false));
    }"
2910,Base64.java,encodeBase64String,String encodeBase64String(byte[] binaryData),669,670,26308,26319,MethodCallMutator,encodeBase64,string,1,0.11252674,"<mask>(binaryData, false)","String encodeBase64String(byte[] binaryData) {
        return StringUtils.newStringUtf8(<mask>(binaryData, false));
    }"
2911,Base64.java,encodeBase64String,String encodeBase64String(byte[] binaryData),669,670,26308,26319,MethodCallMutator,encodeBase64,escape,2,0.07781235,"<mask>(binaryData, false)","String encodeBase64String(byte[] binaryData) {
        return StringUtils.newStringUtf8(<mask>(binaryData, false));
    }"
2912,Base64.java,encodeBase64String,String encodeBase64String(byte[] binaryData),669,670,26308,26319,MethodCallMutator,encodeBase64,write,3,0.06607993,"<mask>(binaryData, false)","String encodeBase64String(byte[] binaryData) {
        return StringUtils.newStringUtf8(<mask>(binaryData, false));
    }"
2913,Base64.java,encodeBase64String,String encodeBase64String(byte[] binaryData),669,670,26308,26319,MethodCallMutator,encodeBase64,binary,4,0.06031722,"<mask>(binaryData, false)","String encodeBase64String(byte[] binaryData) {
        return StringUtils.newStringUtf8(<mask>(binaryData, false));
    }"
2914,Base64.java,encodeBase64String,String encodeBase64String(byte[] binaryData),669,670,26321,26330,IdentifierMutator-Variable,binaryData,data,0,0.70177454,<mask>,"String encodeBase64String(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(<mask>, false));
    }"
2915,Base64.java,encodeBase64String,String encodeBase64String(byte[] binaryData),669,670,26321,26330,IdentifierMutator-Variable,binaryData,binary,1,0.20574424,<mask>,"String encodeBase64String(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(<mask>, false));
    }"
2916,Base64.java,encodeBase64String,String encodeBase64String(byte[] binaryData),669,670,26321,26330,IdentifierMutator-Variable,binaryData,bytes,2,0.016056625,<mask>,"String encodeBase64String(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(<mask>, false));
    }"
2917,Base64.java,encodeBase64String,String encodeBase64String(byte[] binaryData),669,670,26321,26330,IdentifierMutator-Variable,binaryData,bin,3,0.0116743045,<mask>,"String encodeBase64String(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(<mask>, false));
    }"
2918,Base64.java,encodeBase64String,String encodeBase64String(byte[] binaryData),669,670,26321,26330,IdentifierMutator-Variable,binaryData,input,4,0.0068338863,<mask>,"String encodeBase64String(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(<mask>, false));
    }"
2919,Base64.java,encodeBase64String,String encodeBase64String(byte[] binaryData),669,670,26333,26337,IdentifierMutator-Literal,false,true,0,0.3419416,<mask>,"String encodeBase64String(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(binaryData,<mask>));
    }"
2920,Base64.java,encodeBase64String,String encodeBase64String(byte[] binaryData),669,670,26333,26337,IdentifierMutator-Literal,false,encoding,1,0.30814728,<mask>,"String encodeBase64String(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(binaryData,<mask>));
    }"
2921,Base64.java,encodeBase64String,String encodeBase64String(byte[] binaryData),669,670,26333,26337,IdentifierMutator-Literal,false,16,3,0.023923935,<mask>,"String encodeBase64String(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(binaryData,<mask>));
    }"
2922,Base64.java,encodeBase64String,String encodeBase64String(byte[] binaryData),669,670,26333,26337,IdentifierMutator-Literal,false,null,4,0.018529011,<mask>,"String encodeBase64String(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(binaryData,<mask>));
    }"
2923,Base64.java,encodeBase64URLSafe,byte[] encodeBase64URLSafe(byte[] binaryData),682,683,26807,26818,MethodCallMutator,encodeBase64,encode,0,0.9291539,"<mask>(binaryData, false, true)","byte[] encodeBase64URLSafe(byte[] binaryData) {
        return<mask>(binaryData, false, true);
    }"
2924,Base64.java,encodeBase64URLSafe,byte[] encodeBase64URLSafe(byte[] binaryData),682,683,26807,26818,MethodCallMutator,encodeBase64,decode,1,0.04959106,"<mask>(binaryData, false, true)","byte[] encodeBase64URLSafe(byte[] binaryData) {
        return<mask>(binaryData, false, true);
    }"
2925,Base64.java,encodeBase64URLSafe,byte[] encodeBase64URLSafe(byte[] binaryData),682,683,26807,26818,MethodCallMutator,encodeBase64,encrypt,2,0.0033817214,"<mask>(binaryData, false, true)","byte[] encodeBase64URLSafe(byte[] binaryData) {
        return<mask>(binaryData, false, true);
    }"
2926,Base64.java,encodeBase64URLSafe,byte[] encodeBase64URLSafe(byte[] binaryData),682,683,26807,26818,MethodCallMutator,encodeBase64,escape,3,0.0017478258,"<mask>(binaryData, false, true)","byte[] encodeBase64URLSafe(byte[] binaryData) {
        return<mask>(binaryData, false, true);
    }"
2927,Base64.java,encodeBase64URLSafe,byte[] encodeBase64URLSafe(byte[] binaryData),682,683,26807,26818,MethodCallMutator,encodeBase64,convert,4,0.001501609,"<mask>(binaryData, false, true)","byte[] encodeBase64URLSafe(byte[] binaryData) {
        return<mask>(binaryData, false, true);
    }"
2928,Base64.java,encodeBase64URLSafe,byte[] encodeBase64URLSafe(byte[] binaryData),682,683,26820,26829,IdentifierMutator-Variable,binaryData,data,0,0.57694554,<mask>,"byte[] encodeBase64URLSafe(byte[] binaryData) {
        return encodeBase64(<mask>, false, true);
    }"
2929,Base64.java,encodeBase64URLSafe,byte[] encodeBase64URLSafe(byte[] binaryData),682,683,26820,26829,IdentifierMutator-Variable,binaryData,binary,1,0.35582703,<mask>,"byte[] encodeBase64URLSafe(byte[] binaryData) {
        return encodeBase64(<mask>, false, true);
    }"
2930,Base64.java,encodeBase64URLSafe,byte[] encodeBase64URLSafe(byte[] binaryData),682,683,26820,26829,IdentifierMutator-Variable,binaryData,bin,2,0.010326671,<mask>,"byte[] encodeBase64URLSafe(byte[] binaryData) {
        return encodeBase64(<mask>, false, true);
    }"
2931,Base64.java,encodeBase64URLSafe,byte[] encodeBase64URLSafe(byte[] binaryData),682,683,26820,26829,IdentifierMutator-Variable,binaryData,bytes,3,0.00878207,<mask>,"byte[] encodeBase64URLSafe(byte[] binaryData) {
        return encodeBase64(<mask>, false, true);
    }"
2932,Base64.java,encodeBase64URLSafe,byte[] encodeBase64URLSafe(byte[] binaryData),682,683,26820,26829,IdentifierMutator-Variable,binaryData,input,4,0.007093513,<mask>,"byte[] encodeBase64URLSafe(byte[] binaryData) {
        return encodeBase64(<mask>, false, true);
    }"
2933,Base64.java,encodeBase64URLSafe,byte[] encodeBase64URLSafe(byte[] binaryData),682,683,26832,26836,IdentifierMutator-Literal,false,true,0,0.33701757,<mask>,"byte[] encodeBase64URLSafe(byte[] binaryData) {
        return encodeBase64(binaryData,<mask>, true);
    }"
2934,Base64.java,encodeBase64URLSafe,byte[] encodeBase64URLSafe(byte[] binaryData),682,683,26832,26836,IdentifierMutator-Literal,false,null,2,0.077673286,<mask>,"byte[] encodeBase64URLSafe(byte[] binaryData) {
        return encodeBase64(binaryData,<mask>, true);
    }"
2935,Base64.java,encodeBase64URLSafe,byte[] encodeBase64URLSafe(byte[] binaryData),682,683,26832,26836,IdentifierMutator-Literal,false,encoding,3,0.064455956,<mask>,"byte[] encodeBase64URLSafe(byte[] binaryData) {
        return encodeBase64(binaryData,<mask>, true);
    }"
2936,Base64.java,encodeBase64URLSafe,byte[] encodeBase64URLSafe(byte[] binaryData),682,683,26832,26836,IdentifierMutator-Literal,false,0,4,0.026886055,<mask>,"byte[] encodeBase64URLSafe(byte[] binaryData) {
        return encodeBase64(binaryData,<mask>, true);
    }"
2937,Base64.java,encodeBase64URLSafe,byte[] encodeBase64URLSafe(byte[] binaryData),682,683,26839,26842,IdentifierMutator-Literal,true,false,1,0.2752255,<mask>,"byte[] encodeBase64URLSafe(byte[] binaryData) {
        return encodeBase64(binaryData, false,<mask>);
    }"
2938,Base64.java,encodeBase64URLSafe,byte[] encodeBase64URLSafe(byte[] binaryData),682,683,26839,26842,IdentifierMutator-Literal,true,encoding,2,0.037517346,<mask>,"byte[] encodeBase64URLSafe(byte[] binaryData) {
        return encodeBase64(binaryData, false,<mask>);
    }"
2939,Base64.java,encodeBase64URLSafe,byte[] encodeBase64URLSafe(byte[] binaryData),682,683,26839,26842,IdentifierMutator-Literal,true,null,3,0.028304271,<mask>,"byte[] encodeBase64URLSafe(byte[] binaryData) {
        return encodeBase64(binaryData, false,<mask>);
    }"
2940,Base64.java,encodeBase64URLSafe,byte[] encodeBase64URLSafe(byte[] binaryData),682,683,26839,26842,IdentifierMutator-Literal,true,0,4,0.02069018,<mask>,"byte[] encodeBase64URLSafe(byte[] binaryData) {
        return encodeBase64(binaryData, false,<mask>);
    }"
2941,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),695,696,27297,27309,MethodCallMutator,newStringUtf8,escape,0,0.27712065,"StringUtils.<mask>(encodeBase64(binaryData, false, true))","String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.<mask>(encodeBase64(binaryData, false, true));
    }"
2942,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),695,696,27297,27309,MethodCallMutator,newStringUtf8,strip,1,0.15997787,"StringUtils.<mask>(encodeBase64(binaryData, false, true))","String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.<mask>(encodeBase64(binaryData, false, true));
    }"
2943,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),695,696,27297,27309,MethodCallMutator,newStringUtf8,String,2,0.051742323,"StringUtils.<mask>(encodeBase64(binaryData, false, true))","String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.<mask>(encodeBase64(binaryData, false, true));
    }"
2944,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),695,696,27297,27309,MethodCallMutator,newStringUtf8,str,3,0.039697804,"StringUtils.<mask>(encodeBase64(binaryData, false, true))","String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.<mask>(encodeBase64(binaryData, false, true));
    }"
2945,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),695,696,27297,27309,MethodCallMutator,newStringUtf8,copy,4,0.03933654,"StringUtils.<mask>(encodeBase64(binaryData, false, true))","String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.<mask>(encodeBase64(binaryData, false, true));
    }"
2946,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),695,696,27311,27322,MethodCallMutator,encodeBase64,append,0,0.13126743,"<mask>(binaryData, false, true)","String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.newStringUtf8(<mask>(binaryData, false, true));
    }"
2947,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),695,696,27311,27322,MethodCallMutator,encodeBase64,escape,1,0.101710126,"<mask>(binaryData, false, true)","String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.newStringUtf8(<mask>(binaryData, false, true));
    }"
2948,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),695,696,27311,27322,MethodCallMutator,encodeBase64,string,2,0.07036338,"<mask>(binaryData, false, true)","String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.newStringUtf8(<mask>(binaryData, false, true));
    }"
2949,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),695,696,27311,27322,MethodCallMutator,encodeBase64,copy,3,0.0588506,"<mask>(binaryData, false, true)","String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.newStringUtf8(<mask>(binaryData, false, true));
    }"
2950,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),695,696,27311,27322,MethodCallMutator,encodeBase64,bytes,4,0.053650454,"<mask>(binaryData, false, true)","String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.newStringUtf8(<mask>(binaryData, false, true));
    }"
2951,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),695,696,27324,27333,IdentifierMutator-Variable,binaryData,data,0,0.7014834,<mask>,"String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(<mask>, false, true));
    }"
2952,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),695,696,27324,27333,IdentifierMutator-Variable,binaryData,binary,1,0.21778993,<mask>,"String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(<mask>, false, true));
    }"
2953,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),695,696,27324,27333,IdentifierMutator-Variable,binaryData,bytes,2,0.01396412,<mask>,"String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(<mask>, false, true));
    }"
2954,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),695,696,27324,27333,IdentifierMutator-Variable,binaryData,bin,3,0.006630474,<mask>,"String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(<mask>, false, true));
    }"
2955,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),695,696,27324,27333,IdentifierMutator-Variable,binaryData,input,4,0.005561476,<mask>,"String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(<mask>, false, true));
    }"
2956,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),695,696,27336,27340,IdentifierMutator-Literal,false,true,0,0.5513804,<mask>,"String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(binaryData,<mask>, true));
    }"
2957,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),695,696,27336,27340,IdentifierMutator-Literal,false,encoding,2,0.04882754,<mask>,"String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(binaryData,<mask>, true));
    }"
2958,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),695,696,27336,27340,IdentifierMutator-Literal,false,null,3,0.04679208,<mask>,"String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(binaryData,<mask>, true));
    }"
2959,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),695,696,27336,27340,IdentifierMutator-Literal,false,16,4,0.013512293,<mask>,"String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(binaryData,<mask>, true));
    }"
2960,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),695,696,27343,27346,IdentifierMutator-Literal,true,false,0,0.40773466,<mask>,"String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(binaryData, false,<mask>));
    }"
2961,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),695,696,27343,27346,IdentifierMutator-Literal,true,encoding,2,0.04217342,<mask>,"String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(binaryData, false,<mask>));
    }"
2962,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),695,696,27343,27346,IdentifierMutator-Literal,true,null,3,0.032313563,<mask>,"String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(binaryData, false,<mask>));
    }"
2963,Base64.java,encodeBase64URLSafeString,String encodeBase64URLSafeString(byte[] binaryData),695,696,27343,27346,IdentifierMutator-Literal,true,0,4,0.016010568,<mask>,"String encodeBase64URLSafeString(byte[] binaryData) {
        return StringUtils.newStringUtf8(encodeBase64(binaryData, false,<mask>));
    }"
2964,Base64.java,encodeBase64Chunked,byte[] encodeBase64Chunked(byte[] binaryData),706,707,27705,27716,MethodCallMutator,encodeBase64,encode,0,0.82261014,"<mask>(binaryData, true)","byte[] encodeBase64Chunked(byte[] binaryData) {
        return<mask>(binaryData, true);
    }"
2965,Base64.java,encodeBase64Chunked,byte[] encodeBase64Chunked(byte[] binaryData),706,707,27705,27716,MethodCallMutator,encodeBase64,decode,1,0.09652989,"<mask>(binaryData, true)","byte[] encodeBase64Chunked(byte[] binaryData) {
        return<mask>(binaryData, true);
    }"
2966,Base64.java,encodeBase64Chunked,byte[] encodeBase64Chunked(byte[] binaryData),706,707,27705,27716,MethodCallMutator,encodeBase64,chunk,2,0.022350585,"<mask>(binaryData, true)","byte[] encodeBase64Chunked(byte[] binaryData) {
        return<mask>(binaryData, true);
    }"
2967,Base64.java,encodeBase64Chunked,byte[] encodeBase64Chunked(byte[] binaryData),706,707,27705,27716,MethodCallMutator,encodeBase64,write,3,0.006138433,"<mask>(binaryData, true)","byte[] encodeBase64Chunked(byte[] binaryData) {
        return<mask>(binaryData, true);
    }"
2968,Base64.java,encodeBase64Chunked,byte[] encodeBase64Chunked(byte[] binaryData),706,707,27705,27716,MethodCallMutator,encodeBase64,compress,4,0.0039744885,"<mask>(binaryData, true)","byte[] encodeBase64Chunked(byte[] binaryData) {
        return<mask>(binaryData, true);
    }"
2969,Base64.java,encodeBase64Chunked,byte[] encodeBase64Chunked(byte[] binaryData),706,707,27718,27727,IdentifierMutator-Variable,binaryData,data,0,0.6595072,<mask>,"byte[] encodeBase64Chunked(byte[] binaryData) {
        return encodeBase64(<mask>, true);
    }"
2970,Base64.java,encodeBase64Chunked,byte[] encodeBase64Chunked(byte[] binaryData),706,707,27718,27727,IdentifierMutator-Variable,binaryData,binary,1,0.26427338,<mask>,"byte[] encodeBase64Chunked(byte[] binaryData) {
        return encodeBase64(<mask>, true);
    }"
2971,Base64.java,encodeBase64Chunked,byte[] encodeBase64Chunked(byte[] binaryData),706,707,27718,27727,IdentifierMutator-Variable,binaryData,bin,2,0.013548699,<mask>,"byte[] encodeBase64Chunked(byte[] binaryData) {
        return encodeBase64(<mask>, true);
    }"
2972,Base64.java,encodeBase64Chunked,byte[] encodeBase64Chunked(byte[] binaryData),706,707,27718,27727,IdentifierMutator-Variable,binaryData,bytes,3,0.011362956,<mask>,"byte[] encodeBase64Chunked(byte[] binaryData) {
        return encodeBase64(<mask>, true);
    }"
2973,Base64.java,encodeBase64Chunked,byte[] encodeBase64Chunked(byte[] binaryData),706,707,27718,27727,IdentifierMutator-Variable,binaryData,input,4,0.005645278,<mask>,"byte[] encodeBase64Chunked(byte[] binaryData) {
        return encodeBase64(<mask>, true);
    }"
2974,Base64.java,encodeBase64Chunked,byte[] encodeBase64Chunked(byte[] binaryData),706,707,27730,27733,IdentifierMutator-Literal,true,chunk,1,0.22533223,<mask>,"byte[] encodeBase64Chunked(byte[] binaryData) {
        return encodeBase64(binaryData,<mask>);
    }"
2975,Base64.java,encodeBase64Chunked,byte[] encodeBase64Chunked(byte[] binaryData),706,707,27730,27733,IdentifierMutator-Literal,true,false,2,0.14861713,<mask>,"byte[] encodeBase64Chunked(byte[] binaryData) {
        return encodeBase64(binaryData,<mask>);
    }"
2976,Base64.java,encodeBase64Chunked,byte[] encodeBase64Chunked(byte[] binaryData),706,707,27730,27733,IdentifierMutator-Literal,true,chunks,3,0.067457154,<mask>,"byte[] encodeBase64Chunked(byte[] binaryData) {
        return encodeBase64(binaryData,<mask>);
    }"
2977,Base64.java,encodeBase64Chunked,byte[] encodeBase64Chunked(byte[] binaryData),706,707,27730,27733,IdentifierMutator-Literal,true,encoding,4,0.027869578,<mask>,"byte[] encodeBase64Chunked(byte[] binaryData) {
        return encodeBase64(binaryData,<mask>);
    }"
2978,Base64.java,decode,byte[] decode(String pArray),738,739,29006,29011,MethodCallMutator,decode,encode,1,0.004830821,<mask>(StringUtils.getBytesUtf8(pArray)),"byte[] decode(String pArray) {
        return<mask>(StringUtils.getBytesUtf8(pArray));
    }"
2979,Base64.java,decode,byte[] decode(String pArray),738,739,29006,29011,MethodCallMutator,decode,parse,2,1.7826313E-4,<mask>(StringUtils.getBytesUtf8(pArray)),"byte[] decode(String pArray) {
        return<mask>(StringUtils.getBytesUtf8(pArray));
    }"
2980,Base64.java,decode,byte[] decode(String pArray),738,739,29006,29011,MethodCallMutator,decode,dec,3,1.3111597E-4,<mask>(StringUtils.getBytesUtf8(pArray)),"byte[] decode(String pArray) {
        return<mask>(StringUtils.getBytesUtf8(pArray));
    }"
2981,Base64.java,decode,byte[] decode(String pArray),738,739,29006,29011,MethodCallMutator,decode,convert,4,9.6891796E-5,<mask>(StringUtils.getBytesUtf8(pArray)),"byte[] decode(String pArray) {
        return<mask>(StringUtils.getBytesUtf8(pArray));
    }"
2982,Base64.java,decode,byte[] decode(String pArray),738,739,29025,29036,MethodCallMutator,getBytesUtf8,split,0,0.28131217,StringUtils.<mask>(pArray),"byte[] decode(String pArray) {
        return decode(StringUtils.<mask>(pArray));
    }"
2983,Base64.java,decode,byte[] decode(String pArray),738,739,29025,29036,MethodCallMutator,getBytesUtf8,escape,1,0.15086763,StringUtils.<mask>(pArray),"byte[] decode(String pArray) {
        return decode(StringUtils.<mask>(pArray));
    }"
2984,Base64.java,decode,byte[] decode(String pArray),738,739,29025,29036,MethodCallMutator,getBytesUtf8,copy,2,0.09991636,StringUtils.<mask>(pArray),"byte[] decode(String pArray) {
        return decode(StringUtils.<mask>(pArray));
    }"
2985,Base64.java,decode,byte[] decode(String pArray),738,739,29025,29036,MethodCallMutator,getBytesUtf8,bytes,3,0.07844052,StringUtils.<mask>(pArray),"byte[] decode(String pArray) {
        return decode(StringUtils.<mask>(pArray));
    }"
2986,Base64.java,decode,byte[] decode(String pArray),738,739,29025,29036,MethodCallMutator,getBytesUtf8,strip,4,0.056334697,StringUtils.<mask>(pArray),"byte[] decode(String pArray) {
        return decode(StringUtils.<mask>(pArray));
    }"
2987,Base64.java,decode,byte[] decode(String pArray),738,739,29038,29043,IdentifierMutator-Variable,pArray,Array,0,0.48545185,<mask>,"byte[] decode(String pArray) {
        return decode(StringUtils.getBytesUtf8(<mask>));
    }"
2988,Base64.java,decode,byte[] decode(String pArray),738,739,29038,29043,IdentifierMutator-Variable,pArray,array,1,0.47099465,<mask>,"byte[] decode(String pArray) {
        return decode(StringUtils.getBytesUtf8(<mask>));
    }"
2989,Base64.java,decode,byte[] decode(String pArray),738,739,29038,29043,IdentifierMutator-Variable,pArray,string,2,0.017953781,<mask>,"byte[] decode(String pArray) {
        return decode(StringUtils.getBytesUtf8(<mask>));
    }"
2990,Base64.java,decode,byte[] decode(String pArray),738,739,29038,29043,IdentifierMutator-Variable,pArray,arr,3,0.0070915967,<mask>,"byte[] decode(String pArray) {
        return decode(StringUtils.getBytesUtf8(<mask>));
    }"
2991,Base64.java,decode,byte[] decode(String pArray),738,739,29038,29043,IdentifierMutator-Variable,pArray,p,4,0.0027387305,<mask>,"byte[] decode(String pArray) {
        return decode(StringUtils.getBytesUtf8(<mask>));
    }"
2992,Base64.java,decode,byte[] decode(byte[] pArray),749,750,29335,29339,MethodCallMutator,reset,close,0,0.29311025,<mask>(),"byte[] decode(byte[] pArray) {<mask>();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2993,Base64.java,decode,byte[] decode(byte[] pArray),749,750,29335,29339,MethodCallMutator,reset,flush,1,0.22567762,<mask>(),"byte[] decode(byte[] pArray) {<mask>();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2994,Base64.java,decode,byte[] decode(byte[] pArray),749,750,29335,29339,MethodCallMutator,reset,cleanup,2,0.040211882,<mask>(),"byte[] decode(byte[] pArray) {<mask>();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2995,Base64.java,decode,byte[] decode(byte[] pArray),749,750,29335,29339,MethodCallMutator,reset,init,4,0.019027384,<mask>(),"byte[] decode(byte[] pArray) {<mask>();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2996,Base64.java,decode,byte[] decode(byte[] pArray),749,751,29370,29373,BinaryOperatorMutator,||,|,2,0.001427604,(pArray == null) <mask> (pArray.length == 0),"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null<mask>pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2997,Base64.java,decode,byte[] decode(byte[] pArray),749,751,29370,29373,BinaryOperatorMutator,||,/,3,7.403621E-4,(pArray == null) <mask> (pArray.length == 0),"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null<mask>pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2998,Base64.java,decode,byte[] decode(byte[] pArray),749,751,29370,29373,BinaryOperatorMutator,||,.,4,5.871437E-4,(pArray == null) <mask> (pArray.length == 0),"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null<mask>pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
2999,Base64.java,decode,byte[] decode(byte[] pArray),749,751,29362,29365,BinaryOperatorMutator,==,=,2,0.0023566228,pArray <mask> null,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray<mask>null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3000,Base64.java,decode,byte[] decode(byte[] pArray),749,751,29362,29365,BinaryOperatorMutator,==,===,3,4.4237502E-4,pArray <mask> null,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray<mask>null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3001,Base64.java,decode,byte[] decode(byte[] pArray),749,751,29362,29365,BinaryOperatorMutator,==,!=,4,3.2553056E-4,pArray <mask> null,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray<mask>null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3002,Base64.java,decode,byte[] decode(byte[] pArray),749,751,29356,29361,IdentifierMutator-Variable,pArray,array,0,0.6440706,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (<mask> == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3003,Base64.java,decode,byte[] decode(byte[] pArray),749,751,29356,29361,IdentifierMutator-Variable,pArray,Array,1,0.15573049,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (<mask> == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3004,Base64.java,decode,byte[] decode(byte[] pArray),749,751,29356,29361,IdentifierMutator-Variable,pArray,p,2,0.020875828,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (<mask> == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3005,Base64.java,decode,byte[] decode(byte[] pArray),749,751,29356,29361,IdentifierMutator-Variable,pArray,buf,3,0.016114723,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (<mask> == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3006,Base64.java,decode,byte[] decode(byte[] pArray),749,751,29356,29361,IdentifierMutator-Variable,pArray,null,4,0.014322291,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (<mask> == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3007,Base64.java,decode,byte[] decode(byte[] pArray),749,751,29366,29369,IdentifierMutator-Literal,null,NULL,1,3.2657746E-4,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray ==<mask> || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3008,Base64.java,decode,byte[] decode(byte[] pArray),749,751,29366,29369,IdentifierMutator-Literal,null,nil,2,2.4082862E-4,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray ==<mask> || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3009,Base64.java,decode,byte[] decode(byte[] pArray),749,751,29366,29369,IdentifierMutator-Literal,null,undefined,3,5.1762367E-5,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray ==<mask> || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3010,Base64.java,decode,byte[] decode(byte[] pArray),749,751,29387,29390,BinaryOperatorMutator,==,<=,2,0.021815151,pArray.length <mask> 0,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length<mask>0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3011,Base64.java,decode,byte[] decode(byte[] pArray),749,751,29387,29390,BinaryOperatorMutator,==,>,3,0.0137489615,pArray.length <mask> 0,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length<mask>0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3012,Base64.java,decode,byte[] decode(byte[] pArray),749,751,29387,29390,BinaryOperatorMutator,==,=,4,0.0066935173,pArray.length <mask> 0,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length<mask>0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3013,Base64.java,decode,byte[] decode(byte[] pArray),749,751,29374,29386,IdentifierMutator-Variable,pArray.length,len,0,0.6492807,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null ||<mask> == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3014,Base64.java,decode,byte[] decode(byte[] pArray),749,751,29374,29386,IdentifierMutator-Variable,pArray.length,pos,1,0.13718276,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null ||<mask> == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3015,Base64.java,decode,byte[] decode(byte[] pArray),749,751,29374,29386,IdentifierMutator-Variable,pArray.length,length,2,0.044427995,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null ||<mask> == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3016,Base64.java,decode,byte[] decode(byte[] pArray),749,751,29374,29386,IdentifierMutator-Variable,pArray.length,size,3,0.013606399,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null ||<mask> == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3017,Base64.java,decode,byte[] decode(byte[] pArray),749,751,29374,29386,IdentifierMutator-Variable,pArray.length,n,4,0.011469467,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null ||<mask> == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3018,Base64.java,decode,byte[] decode(byte[] pArray),749,751,29374,29379,IdentifierMutator-Variable,pArray,array,0,0.654248,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null ||<mask>.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3019,Base64.java,decode,byte[] decode(byte[] pArray),749,751,29374,29379,IdentifierMutator-Variable,pArray,Array,1,0.12155765,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null ||<mask>.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3020,Base64.java,decode,byte[] decode(byte[] pArray),749,751,29374,29379,IdentifierMutator-Variable,pArray,Array,2,0.10531302,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null ||<mask>.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3021,Base64.java,decode,byte[] decode(byte[] pArray),749,751,29374,29379,IdentifierMutator-Variable,pArray,p,3,0.055892926,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null ||<mask>.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3022,Base64.java,decode,byte[] decode(byte[] pArray),749,751,29374,29379,IdentifierMutator-Variable,pArray,arr,4,0.022102147,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null ||<mask>.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3023,Base64.java,decode,byte[] decode(byte[] pArray),749,751,29381,29386,FieldReferenceMutator,length,size,1,1.00654135E-4,pArray.<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.<mask> == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3024,Base64.java,decode,byte[] decode(byte[] pArray),749,751,29381,29386,FieldReferenceMutator,length,count,2,7.356181E-5,pArray.<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.<mask> == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3025,Base64.java,decode,byte[] decode(byte[] pArray),749,751,29381,29386,FieldReferenceMutator,length,len,4,5.5381715E-5,pArray.<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.<mask> == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3026,Base64.java,decode,byte[] decode(byte[] pArray),749,751,29391,29391,IdentifierMutator-Literal,0,1,1,0.0038162712,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length ==<mask>) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3027,Base64.java,decode,byte[] decode(byte[] pArray),749,751,29391,29391,IdentifierMutator-Literal,0,3,2,0.0034057563,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length ==<mask>) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3028,Base64.java,decode,byte[] decode(byte[] pArray),749,751,29391,29391,IdentifierMutator-Literal,0,4,3,0.002279608,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length ==<mask>) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3029,Base64.java,decode,byte[] decode(byte[] pArray),749,751,29391,29391,IdentifierMutator-Literal,0,2,4,7.9594256E-4,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length ==<mask>) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3030,Base64.java,decode,byte[] decode(byte[] pArray),749,752,29415,29420,IdentifierMutator-Variable,pArray,null,0,0.90077907,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return<mask>;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3031,Base64.java,decode,byte[] decode(byte[] pArray),749,752,29415,29420,IdentifierMutator-Variable,pArray,"""""",1,0.01694632,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return<mask>;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3032,Base64.java,decode,byte[] decode(byte[] pArray),749,752,29415,29420,IdentifierMutator-Variable,pArray,array,2,0.012491131,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return<mask>;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3033,Base64.java,decode,byte[] decode(byte[] pArray),749,752,29415,29420,IdentifierMutator-Variable,pArray,[],3,0.008028291,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return<mask>;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3034,Base64.java,decode,byte[] decode(byte[] pArray),749,752,29415,29420,IdentifierMutator-Variable,pArray,false,4,0.0068730284,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return<mask>;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3035,Base64.java,decode,byte[] decode(byte[] pArray),749,754,29471,29473,BinaryOperatorMutator,/,*,0,0.38207403,(pArray.length * 3) <mask> 4,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3)<mask>4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3036,Base64.java,decode,byte[] decode(byte[] pArray),749,754,29471,29473,BinaryOperatorMutator,/,**,2,0.10835841,(pArray.length * 3) <mask> 4,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3)<mask>4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3037,Base64.java,decode,byte[] decode(byte[] pArray),749,754,29471,29473,BinaryOperatorMutator,/,^,4,0.04042175,(pArray.length * 3) <mask> 4,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3)<mask>4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3038,Base64.java,decode,byte[] decode(byte[] pArray),749,754,29466,29468,BinaryOperatorMutator,*,/,2,0.11176675,pArray.length <mask> 3,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length<mask>3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3039,Base64.java,decode,byte[] decode(byte[] pArray),749,754,29466,29468,BinaryOperatorMutator,*,**,3,0.10790839,pArray.length <mask> 3,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length<mask>3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3040,Base64.java,decode,byte[] decode(byte[] pArray),749,754,29466,29468,BinaryOperatorMutator,*,+,4,0.062860705,pArray.length <mask> 3,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length<mask>3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3041,Base64.java,decode,byte[] decode(byte[] pArray),749,754,29453,29465,IdentifierMutator-Variable,pArray.length,pos,0,0.7825447,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (<mask> * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3042,Base64.java,decode,byte[] decode(byte[] pArray),749,754,29453,29465,IdentifierMutator-Variable,pArray.length,len,1,0.03910921,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (<mask> * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3043,Base64.java,decode,byte[] decode(byte[] pArray),749,754,29453,29465,IdentifierMutator-Variable,pArray.length,size,2,0.017186545,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (<mask> * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3044,Base64.java,decode,byte[] decode(byte[] pArray),749,754,29453,29465,IdentifierMutator-Variable,pArray.length,length,3,0.013432003,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (<mask> * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3045,Base64.java,decode,byte[] decode(byte[] pArray),749,754,29453,29465,IdentifierMutator-Variable,pArray.length,position,4,0.008809444,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (<mask> * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3046,Base64.java,decode,byte[] decode(byte[] pArray),749,754,29453,29458,IdentifierMutator-Variable,pArray,Array,0,0.73206896,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (<mask>.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3047,Base64.java,decode,byte[] decode(byte[] pArray),749,754,29453,29458,IdentifierMutator-Variable,pArray,array,1,0.14223102,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (<mask>.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3048,Base64.java,decode,byte[] decode(byte[] pArray),749,754,29453,29458,IdentifierMutator-Variable,pArray,buf,2,0.045471475,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (<mask>.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3049,Base64.java,decode,byte[] decode(byte[] pArray),749,754,29453,29458,IdentifierMutator-Variable,pArray,buffer,3,0.013771095,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (<mask>.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3050,Base64.java,decode,byte[] decode(byte[] pArray),749,754,29453,29458,IdentifierMutator-Variable,pArray,Buffer,4,0.011538839,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (<mask>.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3051,Base64.java,decode,byte[] decode(byte[] pArray),749,754,29460,29465,FieldReferenceMutator,length,size,1,1.8882744E-4,pArray.<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.<mask> * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3052,Base64.java,decode,byte[] decode(byte[] pArray),749,754,29460,29465,FieldReferenceMutator,length,len,3,4.3324453E-5,pArray.<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.<mask> * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3053,Base64.java,decode,byte[] decode(byte[] pArray),749,754,29460,29465,FieldReferenceMutator,length,Length,4,3.256458E-5,pArray.<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.<mask> * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3054,Base64.java,decode,byte[] decode(byte[] pArray),749,754,29469,29469,IdentifierMutator-Literal,3,4,0,0.7973908,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length *<mask>) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3055,Base64.java,decode,byte[] decode(byte[] pArray),749,754,29469,29469,IdentifierMutator-Literal,3,2,1,0.09884618,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length *<mask>) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3056,Base64.java,decode,byte[] decode(byte[] pArray),749,754,29469,29469,IdentifierMutator-Literal,3,8,3,0.020916928,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length *<mask>) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3057,Base64.java,decode,byte[] decode(byte[] pArray),749,754,29469,29469,IdentifierMutator-Literal,3,5,4,0.010882504,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length *<mask>) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3058,Base64.java,decode,byte[] decode(byte[] pArray),749,754,29474,29474,IdentifierMutator-Literal,4,3,0,0.4723877,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) /<mask>;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3059,Base64.java,decode,byte[] decode(byte[] pArray),749,754,29474,29474,IdentifierMutator-Literal,4,2,2,0.1703532,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) /<mask>;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3060,Base64.java,decode,byte[] decode(byte[] pArray),749,754,29474,29474,IdentifierMutator-Literal,4,5,3,0.012801542,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) /<mask>;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3061,Base64.java,decode,byte[] decode(byte[] pArray),749,754,29474,29474,IdentifierMutator-Literal,4,8,4,0.009204588,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) /<mask>;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3062,Base64.java,decode,byte[] decode(byte[] pArray),749,755,29507,29515,IdentifierMutator-Variable,((int)(len)),len,0,0.97318876,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[<mask>];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3063,Base64.java,decode,byte[] decode(byte[] pArray),749,755,29507,29515,IdentifierMutator-Variable,((int)(len)),Len,1,0.012246223,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[<mask>];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3064,Base64.java,decode,byte[] decode(byte[] pArray),749,755,29507,29515,IdentifierMutator-Variable,((int)(len)),len,2,0.0025785384,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[<mask>];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3065,Base64.java,decode,byte[] decode(byte[] pArray),749,755,29507,29515,IdentifierMutator-Variable,((int)(len)),8,3,9.5274363E-4,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[<mask>];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3066,Base64.java,decode,byte[] decode(byte[] pArray),749,755,29507,29515,IdentifierMutator-Variable,((int)(len)),pos,4,9.202035E-4,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[<mask>];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3067,Base64.java,decode,byte[] decode(byte[] pArray),749,756,29527,29542,MethodCallMutator,setInitialBuffer,decode,0,0.75707847,"<mask>(buf, 0, buf.length)","byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];<mask>(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3068,Base64.java,decode,byte[] decode(byte[] pArray),749,756,29527,29542,MethodCallMutator,setInitialBuffer,encode,1,0.15612443,"<mask>(buf, 0, buf.length)","byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];<mask>(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3069,Base64.java,decode,byte[] decode(byte[] pArray),749,756,29527,29542,MethodCallMutator,setInitialBuffer,write,2,0.045522977,"<mask>(buf, 0, buf.length)","byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];<mask>(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3070,Base64.java,decode,byte[] decode(byte[] pArray),749,756,29527,29542,MethodCallMutator,setInitialBuffer,read,3,0.008943793,"<mask>(buf, 0, buf.length)","byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];<mask>(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3071,Base64.java,decode,byte[] decode(byte[] pArray),749,756,29527,29542,MethodCallMutator,setInitialBuffer,copy,4,0.005535366,"<mask>(buf, 0, buf.length)","byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];<mask>(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3072,Base64.java,decode,byte[] decode(byte[] pArray),749,756,29544,29546,IdentifierMutator-Variable,buf,buffer,1,0.0077944896,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(<mask>, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3073,Base64.java,decode,byte[] decode(byte[] pArray),749,756,29544,29546,IdentifierMutator-Variable,buf,buff,2,0.001584308,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(<mask>, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3074,Base64.java,decode,byte[] decode(byte[] pArray),749,756,29544,29546,IdentifierMutator-Variable,buf,uf,4,4.233095E-4,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(<mask>, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3075,Base64.java,decode,byte[] decode(byte[] pArray),749,756,29549,29549,IdentifierMutator-Literal,0,len,1,0.022269534,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf,<mask>, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3076,Base64.java,decode,byte[] decode(byte[] pArray),749,756,29549,29549,IdentifierMutator-Literal,0,pos,2,0.004915987,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf,<mask>, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3077,Base64.java,decode,byte[] decode(byte[] pArray),749,756,29549,29549,IdentifierMutator-Literal,0,1,3,0.0020303703,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf,<mask>, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3078,Base64.java,decode,byte[] decode(byte[] pArray),749,756,29549,29549,IdentifierMutator-Literal,0,2,4,0.0017054862,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf,<mask>, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3079,Base64.java,decode,byte[] decode(byte[] pArray),749,756,29552,29561,IdentifierMutator-Variable,buf.length,len,0,0.96348965,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0,<mask>);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3080,Base64.java,decode,byte[] decode(byte[] pArray),749,756,29552,29561,IdentifierMutator-Variable,buf.length,0,1,0.022022992,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0,<mask>);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3081,Base64.java,decode,byte[] decode(byte[] pArray),749,756,29552,29561,IdentifierMutator-Variable,buf.length,pos,2,0.003061171,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0,<mask>);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3082,Base64.java,decode,byte[] decode(byte[] pArray),749,756,29552,29561,IdentifierMutator-Variable,buf.length,length,3,9.949489E-4,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0,<mask>);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3083,Base64.java,decode,byte[] decode(byte[] pArray),749,756,29552,29561,IdentifierMutator-Variable,buf.length,1,4,9.2737755E-4,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0,<mask>);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3084,Base64.java,decode,byte[] decode(byte[] pArray),749,756,29552,29554,IdentifierMutator-Variable,buf,buffer,1,0.00790834,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0,<mask>.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3085,Base64.java,decode,byte[] decode(byte[] pArray),749,756,29552,29554,IdentifierMutator-Variable,buf,array,3,8.9608645E-4,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0,<mask>.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3086,Base64.java,decode,byte[] decode(byte[] pArray),749,756,29552,29554,IdentifierMutator-Variable,buf,Buffer,4,5.894584E-4,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0,<mask>.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3087,Base64.java,decode,byte[] decode(byte[] pArray),749,756,29556,29561,FieldReferenceMutator,length,position,1,2.5898602E-4,buf.<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.<mask>);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3088,Base64.java,decode,byte[] decode(byte[] pArray),749,756,29556,29561,FieldReferenceMutator,length,capacity,2,1.1189465E-4,buf.<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.<mask>);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3089,Base64.java,decode,byte[] decode(byte[] pArray),749,756,29556,29561,FieldReferenceMutator,length,limit,4,5.524563E-5,buf.<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.<mask>);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3090,Base64.java,decode,byte[] decode(byte[] pArray),749,757,29573,29578,MethodCallMutator,decode,encode,0,0.57853675,"<mask>(pArray, 0, pArray.length)","byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);<mask>(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3091,Base64.java,decode,byte[] decode(byte[] pArray),749,757,29573,29578,MethodCallMutator,decode,write,2,0.060283706,"<mask>(pArray, 0, pArray.length)","byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);<mask>(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3092,Base64.java,decode,byte[] decode(byte[] pArray),749,757,29573,29578,MethodCallMutator,decode,read,3,0.010713613,"<mask>(pArray, 0, pArray.length)","byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);<mask>(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3093,Base64.java,decode,byte[] decode(byte[] pArray),749,757,29573,29578,MethodCallMutator,decode,copy,4,0.0045376318,"<mask>(pArray, 0, pArray.length)","byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);<mask>(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3094,Base64.java,decode,byte[] decode(byte[] pArray),749,757,29580,29585,IdentifierMutator-Variable,pArray,buf,0,0.9961629,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(<mask>, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3095,Base64.java,decode,byte[] decode(byte[] pArray),749,757,29580,29585,IdentifierMutator-Variable,pArray,buff,1,0.0019237438,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(<mask>, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3096,Base64.java,decode,byte[] decode(byte[] pArray),749,757,29580,29585,IdentifierMutator-Variable,pArray,buffer,2,8.664793E-4,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(<mask>, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3097,Base64.java,decode,byte[] decode(byte[] pArray),749,757,29580,29585,IdentifierMutator-Variable,pArray,buf,3,2.1638506E-4,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(<mask>, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3098,Base64.java,decode,byte[] decode(byte[] pArray),749,757,29580,29585,IdentifierMutator-Variable,pArray,uf,4,2.0816692E-4,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(<mask>, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3099,Base64.java,decode,byte[] decode(byte[] pArray),749,757,29588,29588,IdentifierMutator-Literal,0,1,1,0.018857978,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray,<mask>, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3100,Base64.java,decode,byte[] decode(byte[] pArray),749,757,29588,29588,IdentifierMutator-Literal,0,2,2,0.008514455,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray,<mask>, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3101,Base64.java,decode,byte[] decode(byte[] pArray),749,757,29588,29588,IdentifierMutator-Literal,0,pos,3,0.002415152,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray,<mask>, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3102,Base64.java,decode,byte[] decode(byte[] pArray),749,757,29588,29588,IdentifierMutator-Literal,0,4,4,0.0017652753,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray,<mask>, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3103,Base64.java,decode,byte[] decode(byte[] pArray),749,757,29591,29603,IdentifierMutator-Variable,pArray.length,buf,0,0.739257,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0,<mask>);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3104,Base64.java,decode,byte[] decode(byte[] pArray),749,757,29591,29603,IdentifierMutator-Variable,pArray.length,0,1,0.1110485,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0,<mask>);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3105,Base64.java,decode,byte[] decode(byte[] pArray),749,757,29591,29603,IdentifierMutator-Variable,pArray.length,len,2,0.03518577,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0,<mask>);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3106,Base64.java,decode,byte[] decode(byte[] pArray),749,757,29591,29603,IdentifierMutator-Variable,pArray.length,1,3,0.026180904,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0,<mask>);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3107,Base64.java,decode,byte[] decode(byte[] pArray),749,757,29591,29603,IdentifierMutator-Variable,pArray.length,pos,4,0.025970452,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0,<mask>);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3108,Base64.java,decode,byte[] decode(byte[] pArray),749,757,29591,29596,IdentifierMutator-Variable,pArray,buf,0,0.99489355,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0,<mask>.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3109,Base64.java,decode,byte[] decode(byte[] pArray),749,757,29591,29596,IdentifierMutator-Variable,pArray,buf,1,0.0019086293,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0,<mask>.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3110,Base64.java,decode,byte[] decode(byte[] pArray),749,757,29591,29596,IdentifierMutator-Variable,pArray,buffer,2,0.0018892701,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0,<mask>.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3111,Base64.java,decode,byte[] decode(byte[] pArray),749,757,29591,29596,IdentifierMutator-Variable,pArray,buff,3,2.3934359E-4,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0,<mask>.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3112,Base64.java,decode,byte[] decode(byte[] pArray),749,757,29591,29596,IdentifierMutator-Variable,pArray,tmp,4,5.5140918E-5,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0,<mask>.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3113,Base64.java,decode,byte[] decode(byte[] pArray),749,757,29598,29603,FieldReferenceMutator,length,position,1,6.5589865E-4,pArray.<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.<mask>);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3114,Base64.java,decode,byte[] decode(byte[] pArray),749,757,29598,29603,FieldReferenceMutator,length,count,2,1.07720836E-4,pArray.<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.<mask>);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3115,Base64.java,decode,byte[] decode(byte[] pArray),749,757,29598,29603,FieldReferenceMutator,length,offset,3,7.518692E-5,pArray.<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.<mask>);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3116,Base64.java,decode,byte[] decode(byte[] pArray),749,757,29598,29603,FieldReferenceMutator,length,buffer,4,7.3997544E-5,pArray.<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.<mask>);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3117,Base64.java,decode,byte[] decode(byte[] pArray),749,758,29615,29620,MethodCallMutator,decode,encode,1,0.2324727,"<mask>(pArray, 0, -1)","byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);<mask>(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3118,Base64.java,decode,byte[] decode(byte[] pArray),749,758,29615,29620,MethodCallMutator,decode,write,2,0.107024305,"<mask>(pArray, 0, -1)","byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);<mask>(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3119,Base64.java,decode,byte[] decode(byte[] pArray),749,758,29615,29620,MethodCallMutator,decode,read,3,0.028653799,"<mask>(pArray, 0, -1)","byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);<mask>(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3120,Base64.java,decode,byte[] decode(byte[] pArray),749,758,29615,29620,MethodCallMutator,decode,end,4,0.015619144,"<mask>(pArray, 0, -1)","byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);<mask>(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3121,Base64.java,decode,byte[] decode(byte[] pArray),749,758,29622,29627,IdentifierMutator-Variable,pArray,buf,0,0.9869573,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(<mask>, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3122,Base64.java,decode,byte[] decode(byte[] pArray),749,758,29622,29627,IdentifierMutator-Variable,pArray,buffer,1,0.0026390755,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(<mask>, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3123,Base64.java,decode,byte[] decode(byte[] pArray),749,758,29622,29627,IdentifierMutator-Variable,pArray,buff,2,0.002300166,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(<mask>, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3124,Base64.java,decode,byte[] decode(byte[] pArray),749,758,29622,29627,IdentifierMutator-Variable,pArray,buf,3,6.250636E-4,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(<mask>, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3125,Base64.java,decode,byte[] decode(byte[] pArray),749,758,29622,29627,IdentifierMutator-Variable,pArray,uf,4,5.632952E-4,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(<mask>, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3126,Base64.java,decode,byte[] decode(byte[] pArray),749,758,29630,29630,IdentifierMutator-Literal,0,pos,1,0.24137343,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray,<mask>, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3127,Base64.java,decode,byte[] decode(byte[] pArray),749,758,29630,29630,IdentifierMutator-Literal,0,buf,2,0.1430198,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray,<mask>, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3128,Base64.java,decode,byte[] decode(byte[] pArray),749,758,29630,29630,IdentifierMutator-Literal,0,1,3,0.04150583,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray,<mask>, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3129,Base64.java,decode,byte[] decode(byte[] pArray),749,758,29630,29630,IdentifierMutator-Literal,0,2,4,0.013553122,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray,<mask>, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3130,Base64.java,decode,byte[] decode(byte[] pArray),749,758,29633,29633,UnaryOperatorMutator,-,pos,0,0.38719437,<mask>1,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0,<mask>1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3131,Base64.java,decode,byte[] decode(byte[] pArray),749,758,29633,29633,UnaryOperatorMutator,-,len,2,0.029224245,<mask>1,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0,<mask>1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3132,Base64.java,decode,byte[] decode(byte[] pArray),749,758,29633,29633,UnaryOperatorMutator,-,+,3,0.027765863,<mask>1,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0,<mask>1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3133,Base64.java,decode,byte[] decode(byte[] pArray),749,758,29633,29633,UnaryOperatorMutator,-,buf,4,0.024901174,<mask>1,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0,<mask>1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3134,Base64.java,decode,byte[] decode(byte[] pArray),749,758,29634,29634,IdentifierMutator-Literal,1,len,2,0.020640587,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -<mask>); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3135,Base64.java,decode,byte[] decode(byte[] pArray),749,758,29634,29634,IdentifierMutator-Literal,1,2,3,0.012736833,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -<mask>); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3136,Base64.java,decode,byte[] decode(byte[] pArray),749,758,29634,29634,IdentifierMutator-Literal,1,pos,4,0.007357698,<mask>,"byte[] decode(byte[] pArray) {
        reset();
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -<mask>); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return result;
    }"
3137,Base64.java,decode,byte[] decode(byte[] pArray),749,766,30051,30053,IdentifierMutator-Variable,pos,2,0,0.18372501,<mask>,"       return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[<mask>];
        readResults(result, 0, result.length);
        return result;
    }"
3138,Base64.java,decode,byte[] decode(byte[] pArray),749,766,30051,30053,IdentifierMutator-Variable,pos,32,1,0.07036458,<mask>,"       return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[<mask>];
        readResults(result, 0, result.length);
        return result;
    }"
3139,Base64.java,decode,byte[] decode(byte[] pArray),749,766,30051,30053,IdentifierMutator-Variable,pos,4,2,0.060960602,<mask>,"       return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[<mask>];
        readResults(result, 0, result.length);
        return result;
    }"
3140,Base64.java,decode,byte[] decode(byte[] pArray),749,766,30051,30053,IdentifierMutator-Variable,pos,3,3,0.047790106,<mask>,"       return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[<mask>];
        readResults(result, 0, result.length);
        return result;
    }"
3141,Base64.java,decode,byte[] decode(byte[] pArray),749,766,30051,30053,IdentifierMutator-Variable,pos,1,4,0.046757415,<mask>,"       return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[<mask>];
        readResults(result, 0, result.length);
        return result;
    }"
3142,Base64.java,decode,byte[] decode(byte[] pArray),749,766,30051,30053,FieldReferenceMutator,pos,2,0,0.18372501,<mask>,"       return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[<mask>];
        readResults(result, 0, result.length);
        return result;
    }"
3143,Base64.java,decode,byte[] decode(byte[] pArray),749,766,30051,30053,FieldReferenceMutator,pos,32,1,0.07036458,<mask>,"       return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[<mask>];
        readResults(result, 0, result.length);
        return result;
    }"
3144,Base64.java,decode,byte[] decode(byte[] pArray),749,766,30051,30053,FieldReferenceMutator,pos,4,2,0.060960602,<mask>,"       return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[<mask>];
        readResults(result, 0, result.length);
        return result;
    }"
3145,Base64.java,decode,byte[] decode(byte[] pArray),749,766,30051,30053,FieldReferenceMutator,pos,3,3,0.047790106,<mask>,"       return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[<mask>];
        readResults(result, 0, result.length);
        return result;
    }"
3146,Base64.java,decode,byte[] decode(byte[] pArray),749,766,30051,30053,FieldReferenceMutator,pos,1,4,0.046757415,<mask>,"       return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[<mask>];
        readResults(result, 0, result.length);
        return result;
    }"
3147,Base64.java,decode,byte[] decode(byte[] pArray),749,767,30065,30075,MethodCallMutator,readResults,decode,0,0.8743439,"<mask>(result, 0, result.length)","     return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];<mask>(result, 0, result.length);
        return result;
    }"
3148,Base64.java,decode,byte[] decode(byte[] pArray),749,767,30065,30075,MethodCallMutator,readResults,encode,1,0.06933877,"<mask>(result, 0, result.length)","     return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];<mask>(result, 0, result.length);
        return result;
    }"
3149,Base64.java,decode,byte[] decode(byte[] pArray),749,767,30065,30075,MethodCallMutator,readResults,write,2,0.013498469,"<mask>(result, 0, result.length)","     return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];<mask>(result, 0, result.length);
        return result;
    }"
3150,Base64.java,decode,byte[] decode(byte[] pArray),749,767,30065,30075,MethodCallMutator,readResults,copy,3,0.0070073027,"<mask>(result, 0, result.length)","     return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];<mask>(result, 0, result.length);
        return result;
    }"
3151,Base64.java,decode,byte[] decode(byte[] pArray),749,767,30065,30075,MethodCallMutator,readResults,get,4,0.0034166859,"<mask>(result, 0, result.length)","     return pArray;
        }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];<mask>(result, 0, result.length);
        return result;
    }"
3152,Base64.java,decode,byte[] decode(byte[] pArray),749,767,30077,30082,IdentifierMutator-Variable,result,buf,1,0.01754705,<mask>,"      }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(<mask>, 0, result.length);
        return result;
    }"
3153,Base64.java,decode,byte[] decode(byte[] pArray),749,767,30077,30082,IdentifierMutator-Variable,result,buffer,2,0.013947579,<mask>,"      }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(<mask>, 0, result.length);
        return result;
    }"
3154,Base64.java,decode,byte[] decode(byte[] pArray),749,767,30077,30082,IdentifierMutator-Variable,result,Result,3,0.0017252263,<mask>,"      }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(<mask>, 0, result.length);
        return result;
    }"
3155,Base64.java,decode,byte[] decode(byte[] pArray),749,767,30085,30085,IdentifierMutator-Literal,0,pos,0,0.5303586,<mask>,"    }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result,<mask>, result.length);
        return result;
    }"
3156,Base64.java,decode,byte[] decode(byte[] pArray),749,767,30085,30085,IdentifierMutator-Literal,0,buf,2,0.04631783,<mask>,"    }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result,<mask>, result.length);
        return result;
    }"
3157,Base64.java,decode,byte[] decode(byte[] pArray),749,767,30085,30085,IdentifierMutator-Literal,0,position,3,0.009556857,<mask>,"    }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result,<mask>, result.length);
        return result;
    }"
3158,Base64.java,decode,byte[] decode(byte[] pArray),749,767,30085,30085,IdentifierMutator-Literal,0,1,4,0.0064126896,<mask>,"    }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result,<mask>, result.length);
        return result;
    }"
3159,Base64.java,decode,byte[] decode(byte[] pArray),749,767,30088,30100,IdentifierMutator-Variable,result.length,pos,0,0.8234639,<mask>,"  }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0,<mask>);
        return result;
    }"
3160,Base64.java,decode,byte[] decode(byte[] pArray),749,767,30088,30100,IdentifierMutator-Variable,result.length,buf,1,0.05307799,<mask>,"  }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0,<mask>);
        return result;
    }"
3161,Base64.java,decode,byte[] decode(byte[] pArray),749,767,30088,30100,IdentifierMutator-Variable,result.length,len,2,0.010301085,<mask>,"  }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0,<mask>);
        return result;
    }"
3162,Base64.java,decode,byte[] decode(byte[] pArray),749,767,30088,30100,IdentifierMutator-Variable,result.length,position,3,0.008760195,<mask>,"  }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0,<mask>);
        return result;
    }"
3163,Base64.java,decode,byte[] decode(byte[] pArray),749,767,30088,30100,IdentifierMutator-Variable,result.length,result,4,0.008323859,<mask>,"  }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0,<mask>);
        return result;
    }"
3164,Base64.java,decode,byte[] decode(byte[] pArray),749,767,30088,30093,IdentifierMutator-Variable,result,Result,2,0.0022663448,<mask>,"  }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0,<mask>.length);
        return result;
    }"
3165,Base64.java,decode,byte[] decode(byte[] pArray),749,767,30088,30093,IdentifierMutator-Variable,result,buf,3,0.0019676678,<mask>,"  }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0,<mask>.length);
        return result;
    }"
3166,Base64.java,decode,byte[] decode(byte[] pArray),749,767,30088,30093,IdentifierMutator-Variable,result,results,4,0.0013248664,<mask>,"  }
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0,<mask>.length);
        return result;
    }"
3167,Base64.java,decode,byte[] decode(byte[] pArray),749,767,30095,30100,FieldReferenceMutator,length,class,2,8.59496E-5,result.<mask>,"
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.<mask>);
        return result;
    }"
3168,Base64.java,decode,byte[] decode(byte[] pArray),749,767,30095,30100,FieldReferenceMutator,length,shape,3,2.2123924E-5,result.<mask>,"
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.<mask>);
        return result;
    }"
3169,Base64.java,decode,byte[] decode(byte[] pArray),749,767,30095,30100,FieldReferenceMutator,length,read,4,2.1257874E-5,result.<mask>,"
        long len = (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.<mask>);
        return result;
    }"
3170,Base64.java,decode,byte[] decode(byte[] pArray),749,768,30119,30124,IdentifierMutator-Variable,result,buf,1,0.001439841,<mask>," (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return<mask>;
    }"
3171,Base64.java,decode,byte[] decode(byte[] pArray),749,768,30119,30124,IdentifierMutator-Variable,result,null,2,9.912705E-4,<mask>," (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return<mask>;
    }"
3172,Base64.java,decode,byte[] decode(byte[] pArray),749,768,30119,30124,IdentifierMutator-Variable,result,buffer,3,8.04314E-4,<mask>," (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return<mask>;
    }"
3173,Base64.java,decode,byte[] decode(byte[] pArray),749,768,30119,30124,IdentifierMutator-Variable,result,true,4,4.7972254E-4,<mask>," (pArray.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        decode(pArray, 0, pArray.length);
        decode(pArray, 0, -1); // Notify decoder of EOF.

        // Would be nice to just return buf (like we sometimes do in the encode
        // logic), but we have no idea what the line-length was (could even be
        // variable).  So we cannot determine ahead of time exactly how big an
        // array is necessary.  Hence the need to construct a 2nd byte array to
        // hold the final result:

        byte[] result = new byte[pos];
        readResults(result, 0, result.length);
        return<mask>;
    }"
3174,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked)",782,783,30759,30770,MethodCallMutator,encodeBase64,encode,0,0.96945983,"<mask>(binaryData, isChunked, false)","byte[] encodeBase64(byte[] binaryData, boolean isChunked) {
        return<mask>(binaryData, isChunked, false);
    }"
3175,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked)",782,783,30759,30770,MethodCallMutator,encodeBase64,decode,1,0.017711729,"<mask>(binaryData, isChunked, false)","byte[] encodeBase64(byte[] binaryData, boolean isChunked) {
        return<mask>(binaryData, isChunked, false);
    }"
3176,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked)",782,783,30759,30770,MethodCallMutator,encodeBase64,convert,2,0.0014596981,"<mask>(binaryData, isChunked, false)","byte[] encodeBase64(byte[] binaryData, boolean isChunked) {
        return<mask>(binaryData, isChunked, false);
    }"
3177,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked)",782,783,30759,30770,MethodCallMutator,encodeBase64,encrypt,3,0.0013073772,"<mask>(binaryData, isChunked, false)","byte[] encodeBase64(byte[] binaryData, boolean isChunked) {
        return<mask>(binaryData, isChunked, false);
    }"
3178,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked)",782,783,30759,30770,MethodCallMutator,encodeBase64,write,4,7.6936977E-4,"<mask>(binaryData, isChunked, false)","byte[] encodeBase64(byte[] binaryData, boolean isChunked) {
        return<mask>(binaryData, isChunked, false);
    }"
3179,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked)",782,783,30772,30781,IdentifierMutator-Variable,binaryData,data,0,0.6559646,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked) {
        return encodeBase64(<mask>, isChunked, false);
    }"
3180,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked)",782,783,30772,30781,IdentifierMutator-Variable,binaryData,binary,1,0.2709676,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked) {
        return encodeBase64(<mask>, isChunked, false);
    }"
3181,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked)",782,783,30772,30781,IdentifierMutator-Variable,binaryData,bytes,2,0.011036762,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked) {
        return encodeBase64(<mask>, isChunked, false);
    }"
3182,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked)",782,783,30772,30781,IdentifierMutator-Variable,binaryData,bin,3,0.00727332,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked) {
        return encodeBase64(<mask>, isChunked, false);
    }"
3183,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked)",782,783,30772,30781,IdentifierMutator-Variable,binaryData,null,4,0.006988416,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked) {
        return encodeBase64(<mask>, isChunked, false);
    }"
3184,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked)",782,783,30784,30792,IdentifierMutator-Variable,isChunked,true,0,0.3742739,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked) {
        return encodeBase64(binaryData,<mask>, false);
    }"
3185,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked)",782,783,30784,30792,IdentifierMutator-Variable,isChunked,false,1,0.21662262,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked) {
        return encodeBase64(binaryData,<mask>, false);
    }"
3186,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked)",782,783,30784,30792,IdentifierMutator-Variable,isChunked,chunk,2,0.067907944,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked) {
        return encodeBase64(binaryData,<mask>, false);
    }"
3187,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked)",782,783,30784,30792,IdentifierMutator-Variable,isChunked,null,3,0.051294964,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked) {
        return encodeBase64(binaryData,<mask>, false);
    }"
3188,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked)",782,783,30784,30792,IdentifierMutator-Variable,isChunked,encoding,4,0.037491746,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked) {
        return encodeBase64(binaryData,<mask>, false);
    }"
3189,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked)",782,783,30795,30799,IdentifierMutator-Literal,false,true,0,0.41044897,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked) {
        return encodeBase64(binaryData, isChunked,<mask>);
    }"
3190,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked)",782,783,30795,30799,IdentifierMutator-Literal,false,null,2,0.05827159,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked) {
        return encodeBase64(binaryData, isChunked,<mask>);
    }"
3191,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked)",782,783,30795,30799,IdentifierMutator-Literal,false,encoding,3,0.040970728,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked) {
        return encodeBase64(binaryData, isChunked,<mask>);
    }"
3192,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked)",782,783,30795,30799,IdentifierMutator-Literal,false,0,4,0.02338439,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked) {
        return encodeBase64(binaryData, isChunked,<mask>);
    }"
3193,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",800,801,31603,31614,MethodCallMutator,encodeBase64,encode,0,0.97584516,"<mask>(binaryData, isChunked, urlSafe, Integer.MAX_VALUE)","byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return<mask>(binaryData, isChunked, urlSafe, Integer.MAX_VALUE);
    }"
3194,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",800,801,31603,31614,MethodCallMutator,encodeBase64,decode,1,0.013778917,"<mask>(binaryData, isChunked, urlSafe, Integer.MAX_VALUE)","byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return<mask>(binaryData, isChunked, urlSafe, Integer.MAX_VALUE);
    }"
3195,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",800,801,31603,31614,MethodCallMutator,encodeBase64,encrypt,2,0.0018567225,"<mask>(binaryData, isChunked, urlSafe, Integer.MAX_VALUE)","byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return<mask>(binaryData, isChunked, urlSafe, Integer.MAX_VALUE);
    }"
3196,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",800,801,31603,31614,MethodCallMutator,encodeBase64,convert,3,9.6652255E-4,"<mask>(binaryData, isChunked, urlSafe, Integer.MAX_VALUE)","byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return<mask>(binaryData, isChunked, urlSafe, Integer.MAX_VALUE);
    }"
3197,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",800,801,31603,31614,MethodCallMutator,encodeBase64,encoded,4,6.6856673E-4,"<mask>(binaryData, isChunked, urlSafe, Integer.MAX_VALUE)","byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return<mask>(binaryData, isChunked, urlSafe, Integer.MAX_VALUE);
    }"
3198,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",800,801,31616,31625,IdentifierMutator-Variable,binaryData,binary,0,0.4719807,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(<mask>, isChunked, urlSafe, Integer.MAX_VALUE);
    }"
3199,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",800,801,31616,31625,IdentifierMutator-Variable,binaryData,data,1,0.46579558,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(<mask>, isChunked, urlSafe, Integer.MAX_VALUE);
    }"
3200,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",800,801,31616,31625,IdentifierMutator-Variable,binaryData,bytes,2,0.010550368,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(<mask>, isChunked, urlSafe, Integer.MAX_VALUE);
    }"
3201,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",800,801,31616,31625,IdentifierMutator-Variable,binaryData,this,3,0.008777915,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(<mask>, isChunked, urlSafe, Integer.MAX_VALUE);
    }"
3202,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",800,801,31616,31625,IdentifierMutator-Variable,binaryData,bin,4,0.0063010533,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(<mask>, isChunked, urlSafe, Integer.MAX_VALUE);
    }"
3203,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",800,801,31628,31636,IdentifierMutator-Variable,isChunked,chunk,0,0.33446503,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(binaryData,<mask>, urlSafe, Integer.MAX_VALUE);
    }"
3204,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",800,801,31628,31636,IdentifierMutator-Variable,isChunked,true,1,0.20736079,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(binaryData,<mask>, urlSafe, Integer.MAX_VALUE);
    }"
3205,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",800,801,31628,31636,IdentifierMutator-Variable,isChunked,false,2,0.19937013,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(binaryData,<mask>, urlSafe, Integer.MAX_VALUE);
    }"
3206,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",800,801,31628,31636,IdentifierMutator-Variable,isChunked,chunks,3,0.04113835,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(binaryData,<mask>, urlSafe, Integer.MAX_VALUE);
    }"
3207,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",800,801,31628,31636,IdentifierMutator-Variable,isChunked,encoded,4,0.021251934,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(binaryData,<mask>, urlSafe, Integer.MAX_VALUE);
    }"
3208,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",800,801,31639,31645,IdentifierMutator-Variable,urlSafe,url,0,0.3277066,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(binaryData, isChunked,<mask>, Integer.MAX_VALUE);
    }"
3209,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",800,801,31639,31645,IdentifierMutator-Variable,urlSafe,false,1,0.29387927,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(binaryData, isChunked,<mask>, Integer.MAX_VALUE);
    }"
3210,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",800,801,31639,31645,IdentifierMutator-Variable,urlSafe,true,2,0.25466722,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(binaryData, isChunked,<mask>, Integer.MAX_VALUE);
    }"
3211,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",800,801,31639,31645,IdentifierMutator-Variable,urlSafe,null,3,0.05202581,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(binaryData, isChunked,<mask>, Integer.MAX_VALUE);
    }"
3212,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",800,801,31639,31645,IdentifierMutator-Variable,urlSafe,0,4,0.011407451,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(binaryData, isChunked,<mask>, Integer.MAX_VALUE);
    }"
3213,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",800,801,31648,31664,IdentifierMutator-Variable,java.lang.Integer.MAX_VALUE,true,0,0.46313015,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(binaryData, isChunked, urlSafe,<mask>);
    }"
3214,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",800,801,31648,31664,IdentifierMutator-Variable,java.lang.Integer.MAX_VALUE,false,1,0.30426246,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(binaryData, isChunked, urlSafe,<mask>);
    }"
3215,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",800,801,31648,31664,IdentifierMutator-Variable,java.lang.Integer.MAX_VALUE,null,2,0.05156211,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(binaryData, isChunked, urlSafe,<mask>);
    }"
3216,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",800,801,31648,31664,IdentifierMutator-Variable,java.lang.Integer.MAX_VALUE,encoding,3,0.046732217,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(binaryData, isChunked, urlSafe,<mask>);
    }"
3217,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",800,801,31648,31664,IdentifierMutator-Variable,java.lang.Integer.MAX_VALUE,0,4,0.012317601,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(binaryData, isChunked, urlSafe,<mask>);
    }"
3218,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",800,801,31656,31664,FieldReferenceMutator,MAX_VALUE,MAX,0,0.81098574,java.lang.Integer.<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(binaryData, isChunked, urlSafe, Integer.<mask>);
    }"
3219,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",800,801,31656,31664,FieldReferenceMutator,MAX_VALUE,class,1,0.040453304,java.lang.Integer.<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(binaryData, isChunked, urlSafe, Integer.<mask>);
    }"
3220,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",800,801,31656,31664,FieldReferenceMutator,MAX_VALUE,MIN,2,0.035998788,java.lang.Integer.<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(binaryData, isChunked, urlSafe, Integer.<mask>);
    }"
3221,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",800,801,31656,31664,FieldReferenceMutator,MAX_VALUE,VALUE,3,0.026722755,java.lang.Integer.<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(binaryData, isChunked, urlSafe, Integer.<mask>);
    }"
3222,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe)",800,801,31656,31664,FieldReferenceMutator,MAX_VALUE,SIZE,4,0.0136624,java.lang.Integer.<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {
        return encodeBase64(binaryData, isChunked, urlSafe, Integer.<mask>);
    }"
3223,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,821,32571,32574,BinaryOperatorMutator,||,/,2,0.005680748,(binaryData == null) <mask> (binaryData.length == 0),"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null<mask>binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3224,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,821,32571,32574,BinaryOperatorMutator,||,|,3,0.005238703,(binaryData == null) <mask> (binaryData.length == 0),"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null<mask>binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3225,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,821,32571,32574,BinaryOperatorMutator,||,.,4,0.0011665828,(binaryData == null) <mask> (binaryData.length == 0),"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null<mask>binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3226,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,821,32563,32566,BinaryOperatorMutator,==,=,2,0.0020524685,binaryData <mask> null,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData<mask>null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3227,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,821,32563,32566,BinaryOperatorMutator,==,===,3,2.3053767E-4,binaryData <mask> null,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData<mask>null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3228,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,821,32563,32566,BinaryOperatorMutator,==,!=,4,1.6335538E-4,binaryData <mask> null,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData<mask>null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3229,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,821,32553,32562,IdentifierMutator-Variable,binaryData,data,0,0.6914588,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (<mask> == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3230,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,821,32553,32562,IdentifierMutator-Variable,binaryData,binary,1,0.06650832,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (<mask> == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3231,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,821,32553,32562,IdentifierMutator-Variable,binaryData,input,2,0.031243432,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (<mask> == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3232,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,821,32553,32562,IdentifierMutator-Variable,binaryData,bytes,3,0.016900618,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (<mask> == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3233,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,821,32553,32562,IdentifierMutator-Variable,binaryData,null,4,0.012977123,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (<mask> == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3234,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,821,32567,32570,IdentifierMutator-Literal,null,NULL,1,2.8554728E-4,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData ==<mask> || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3235,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,821,32567,32570,IdentifierMutator-Literal,null,nil,2,1.16588424E-4,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData ==<mask> || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3236,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,821,32567,32570,IdentifierMutator-Literal,null,undefined,4,2.1787557E-5,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData ==<mask> || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3237,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,821,32592,32595,BinaryOperatorMutator,==,>,2,0.038619313,binaryData.length <mask> 0,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length<mask>0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3238,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,821,32592,32595,BinaryOperatorMutator,==,<=,3,0.015232827,binaryData.length <mask> 0,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length<mask>0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3239,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,821,32592,32595,BinaryOperatorMutator,==,=,4,0.011085489,binaryData.length <mask> 0,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length<mask>0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3240,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,821,32575,32591,IdentifierMutator-Variable,binaryData.length,len,0,0.80494946,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null ||<mask> == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3241,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,821,32575,32591,IdentifierMutator-Variable,binaryData.length,length,1,0.11384548,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null ||<mask> == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3242,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,821,32575,32591,IdentifierMutator-Variable,binaryData.length,size,2,0.02504228,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null ||<mask> == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3243,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,821,32575,32591,IdentifierMutator-Variable,binaryData.length,count,3,0.008685974,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null ||<mask> == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3244,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,821,32575,32591,IdentifierMutator-Variable,binaryData.length,bytes,4,0.0028266113,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null ||<mask> == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3245,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,821,32575,32584,IdentifierMutator-Variable,binaryData,data,0,0.5732565,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null ||<mask>.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3246,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,821,32575,32584,IdentifierMutator-Variable,binaryData,bytes,1,0.115472086,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null ||<mask>.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3247,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,821,32575,32584,IdentifierMutator-Variable,binaryData,arguments,2,0.062510625,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null ||<mask>.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3248,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,821,32575,32584,IdentifierMutator-Variable,binaryData,input,3,0.05430178,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null ||<mask>.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3249,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,821,32575,32584,IdentifierMutator-Variable,binaryData,buffer,4,0.04487746,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null ||<mask>.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3250,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,821,32586,32591,FieldReferenceMutator,length,len,2,1.6626014E-4,binaryData.<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.<mask> == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3251,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,821,32586,32591,FieldReferenceMutator,length,size,3,7.169948E-5,binaryData.<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.<mask> == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3252,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,821,32586,32591,FieldReferenceMutator,length,Length,4,5.1268293E-5,binaryData.<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.<mask> == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3253,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,821,32596,32596,IdentifierMutator-Literal,0,1,1,0.002125403,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length ==<mask>) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3254,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,821,32596,32596,IdentifierMutator-Literal,0,length,2,6.8176637E-4,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length ==<mask>) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3255,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,821,32596,32596,IdentifierMutator-Literal,0,512,3,6.4796774E-4,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length ==<mask>) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3256,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,821,32596,32596,IdentifierMutator-Literal,0,size,4,5.417418E-4,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length ==<mask>) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3257,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,822,32620,32629,IdentifierMutator-Variable,binaryData,null,0,0.89433336,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return<mask>;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3258,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,822,32620,32629,IdentifierMutator-Variable,binaryData,"""""",1,0.059016712,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return<mask>;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3259,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,822,32620,32629,IdentifierMutator-Variable,binaryData,bytes,2,0.0054132845,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return<mask>;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3260,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,822,32620,32629,IdentifierMutator-Variable,binaryData,NULL,3,0.005319625,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return<mask>;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3261,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,822,32620,32629,IdentifierMutator-Variable,binaryData,"''",4,0.0052273367,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return<mask>;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3262,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,825,32662,32676,MethodCallMutator,getEncodeLength,encode,0,0.45844477,"<mask>(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR)","byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len =<mask>(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3263,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,825,32662,32676,MethodCallMutator,getEncodeLength,len,1,0.15439634,"<mask>(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR)","byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len =<mask>(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3264,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,825,32662,32676,MethodCallMutator,getEncodeLength,length,2,0.079201385,"<mask>(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR)","byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len =<mask>(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3265,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,825,32662,32676,MethodCallMutator,getEncodeLength,decode,3,0.061414093,"<mask>(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR)","byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len =<mask>(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3266,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,825,32662,32676,MethodCallMutator,getEncodeLength,size,4,0.044619154,"<mask>(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR)","byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len =<mask>(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3267,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,825,32678,32687,IdentifierMutator-Variable,binaryData,input,0,0.38564187,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(<mask>, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3268,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,825,32678,32687,IdentifierMutator-Variable,binaryData,data,1,0.22830185,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(<mask>, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3269,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,825,32678,32687,IdentifierMutator-Variable,binaryData,bytes,2,0.03716306,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(<mask>, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3270,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,825,32678,32687,IdentifierMutator-Variable,binaryData,in,3,0.0363346,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(<mask>, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3271,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,825,32678,32687,IdentifierMutator-Variable,binaryData,array,4,0.034665555,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(<mask>, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3272,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,825,32690,32704,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MIME_CHUNK_SIZE,0,0,0.58408165,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData,<mask>, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3273,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,825,32690,32704,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MIME_CHUNK_SIZE,true,1,0.079815425,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData,<mask>, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3274,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,825,32690,32704,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MIME_CHUNK_SIZE,false,2,0.06417632,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData,<mask>, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3275,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,825,32690,32704,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MIME_CHUNK_SIZE,null,3,0.015368145,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData,<mask>, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3276,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,825,32690,32704,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.MIME_CHUNK_SIZE,encoding,4,0.009270011,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData,<mask>, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3277,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,825,32690,32704,FieldReferenceMutator,MIME_CHUNK_SIZE,0,0,0.58408165,org.apache.commons.codec.binary.Base64.<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData,<mask>, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3278,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,825,32690,32704,FieldReferenceMutator,MIME_CHUNK_SIZE,true,1,0.079815425,org.apache.commons.codec.binary.Base64.<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData,<mask>, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3279,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,825,32690,32704,FieldReferenceMutator,MIME_CHUNK_SIZE,false,2,0.06417632,org.apache.commons.codec.binary.Base64.<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData,<mask>, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3280,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,825,32690,32704,FieldReferenceMutator,MIME_CHUNK_SIZE,null,3,0.015368145,org.apache.commons.codec.binary.Base64.<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData,<mask>, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3281,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,825,32690,32704,FieldReferenceMutator,MIME_CHUNK_SIZE,encoding,4,0.009270011,org.apache.commons.codec.binary.Base64.<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData,<mask>, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3282,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,825,32707,32721,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.CHUNK_SEPARATOR,true,0,0.43476674,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE,<mask>);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3283,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,825,32707,32721,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.CHUNK_SEPARATOR,false,1,0.27590004,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE,<mask>);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3284,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,825,32707,32721,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.CHUNK_SEPARATOR,encoding,2,0.038360983,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE,<mask>);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3285,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,825,32707,32721,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.CHUNK_SEPARATOR,0,3,0.023925789,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE,<mask>);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3286,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,825,32707,32721,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.CHUNK_SEPARATOR,null,4,0.012335771,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE,<mask>);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3287,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,825,32707,32721,FieldReferenceMutator,CHUNK_SEPARATOR,true,0,0.43476674,org.apache.commons.codec.binary.Base64.<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE,<mask>);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3288,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,825,32707,32721,FieldReferenceMutator,CHUNK_SEPARATOR,false,1,0.27590004,org.apache.commons.codec.binary.Base64.<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE,<mask>);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3289,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,825,32707,32721,FieldReferenceMutator,CHUNK_SEPARATOR,encoding,2,0.038360983,org.apache.commons.codec.binary.Base64.<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE,<mask>);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3290,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,825,32707,32721,FieldReferenceMutator,CHUNK_SEPARATOR,0,3,0.023925789,org.apache.commons.codec.binary.Base64.<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE,<mask>);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3291,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,825,32707,32721,FieldReferenceMutator,CHUNK_SEPARATOR,null,4,0.012335771,org.apache.commons.codec.binary.Base64.<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE,<mask>);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3292,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,826,32740,32742,BinaryOperatorMutator,>,>=,2,0.01786829,len <mask> maxResultSize,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len<mask>maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3293,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,826,32740,32742,BinaryOperatorMutator,>,<,3,0.017044513,len <mask> maxResultSize,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len<mask>maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3294,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,826,32740,32742,BinaryOperatorMutator,>,<=,4,0.0039419783,len <mask> maxResultSize,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len<mask>maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3295,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,826,32737,32739,IdentifierMutator-Variable,len,Len,2,3.5092022E-4,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (<mask> > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3296,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,826,32737,32739,IdentifierMutator-Variable,len,length,3,7.9569756E-5,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (<mask> > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3297,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,826,32737,32739,IdentifierMutator-Variable,len,en,4,3.3681994E-5,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (<mask> > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3298,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,826,32743,32755,IdentifierMutator-Variable,maxResultSize,max,0,0.31357995,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len ><mask>) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3299,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,826,32743,32755,IdentifierMutator-Variable,maxResultSize,1024,1,0.05319815,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len ><mask>) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3300,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,826,32743,32755,IdentifierMutator-Variable,maxResultSize,255,2,0.04896046,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len ><mask>) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3301,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,826,32743,32755,IdentifierMutator-Variable,maxResultSize,limit,3,0.043229584,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len ><mask>) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3302,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,826,32743,32755,IdentifierMutator-Variable,maxResultSize,512,4,0.043197732,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len ><mask>) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3303,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,829,32943,32961,BinaryOperatorMutator,+,"""+",2,0.029903173,"((""Input array too big, the output array would be bigger ("" + len) + "") than the specified maxium size of "") <mask> maxResultSize","byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of ""<mask>maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3304,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,829,32943,32961,BinaryOperatorMutator,+,+(,3,0.004336832,"((""Input array too big, the output array would be bigger ("" + len) + "") than the specified maxium size of "") <mask> maxResultSize","byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of ""<mask>maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3305,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,829,32943,32961,BinaryOperatorMutator,+,)+,4,4.151791E-4,"((""Input array too big, the output array would be bigger ("" + len) + "") than the specified maxium size of "") <mask> maxResultSize","byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of ""<mask>maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3306,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,828,32886,32904,BinaryOperatorMutator,+,)+,2,0.0033758963,"(""Input array too big, the output array would be bigger ("" + len) <mask> "") than the specified maxium size of ""","byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len<mask>"") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3307,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,828,32886,32904,BinaryOperatorMutator,+,"\",3,0.0028523596,"(""Input array too big, the output array would be bigger ("" + len) <mask> "") than the specified maxium size of ""","byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len<mask>"") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3308,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,828,32886,32904,BinaryOperatorMutator,+,"\",4,8.9035387E-4,"(""Input array too big, the output array would be bigger ("" + len) <mask> "") than the specified maxium size of ""","byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len<mask>"") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3309,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,827,32864,32882,BinaryOperatorMutator,+,+(,2,0.001289508,"""Input array too big, the output array would be bigger ("" <mask> len","byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger (""<mask>len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3310,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,827,32864,32882,BinaryOperatorMutator,+,"""+",3,0.0010698005,"""Input array too big, the output array would be bigger ("" <mask> len","byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger (""<mask>len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3311,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,827,32864,32882,BinaryOperatorMutator,+,*,4,9.720484E-5,"""Input array too big, the output array would be bigger ("" <mask> len","byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger (""<mask>len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3312,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,827,32807,32863,IdentifierMutator-Literal,"""Inputarraytoobig,theoutputarraywouldbebigger(""","(""",0,0.648947,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(<mask> +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3313,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,827,32807,32863,IdentifierMutator-Literal,"""Inputarraytoobig,theoutputarraywouldbebigger(""","{""",1,0.042458788,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(<mask> +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3314,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,827,32807,32863,IdentifierMutator-Literal,"""Inputarraytoobig,theoutputarraywouldbebigger(""","""",2,0.034229062,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(<mask> +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3315,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,827,32807,32863,IdentifierMutator-Literal,"""Inputarraytoobig,theoutputarraywouldbebigger(""","""""",3,0.028836025,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(<mask> +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3316,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,827,32807,32863,IdentifierMutator-Literal,"""Inputarraytoobig,theoutputarraywouldbebigger(""",(,4,0.026643338,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(<mask> +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3317,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,828,32883,32885,IdentifierMutator-Variable,len,length,1,0.0010646223,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +<mask> +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3318,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,828,32883,32885,IdentifierMutator-Variable,len,lang,2,4.3615286E-4,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +<mask> +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3319,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,828,32883,32885,IdentifierMutator-Variable,len,str,3,4.2734548E-4,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +<mask> +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3320,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,828,32883,32885,IdentifierMutator-Variable,len,"""""",4,3.7456644E-4,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +<mask> +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3321,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,829,32905,32942,IdentifierMutator-Literal,""")thanthespecifiedmaxiumsizeof""",//,0,0.3292997,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +<mask> +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3322,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,829,32905,32942,IdentifierMutator-Literal,""")thanthespecifiedmaxiumsizeof""","""",1,0.29073513,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +<mask> +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3323,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,829,32905,32942,IdentifierMutator-Literal,""")thanthespecifiedmaxiumsizeof""","""""",2,0.058950666,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +<mask> +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3324,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,829,32905,32942,IdentifierMutator-Literal,""")thanthespecifiedmaxiumsizeof""",,3,0.04399964,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +<mask> +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3325,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,829,32905,32942,IdentifierMutator-Literal,""")thanthespecifiedmaxiumsizeof""",""")",4,0.038212966,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +<mask> +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3326,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,830,32962,32974,IdentifierMutator-Variable,maxResultSize,len,0,0.3234891,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +<mask>);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3327,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,830,32962,32974,IdentifierMutator-Variable,maxResultSize,size,1,0.12567717,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +<mask>);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3328,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,830,32962,32974,IdentifierMutator-Variable,maxResultSize,max,2,0.1010888,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +<mask>);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3329,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,830,32962,32974,IdentifierMutator-Variable,maxResultSize,1,3,0.031210367,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +<mask>);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3330,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,830,32962,32974,IdentifierMutator-Variable,maxResultSize,limit,4,0.030797254,<mask>,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +<mask>);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3331,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,833,33026,33098,IdentifierMutator-Conditional,"(isChunked)?neworg.apache.commons.codec.binary.Base64(urlSafe):neworg.apache.commons.codec.binary.Base64(0,org.apache.commons.codec.binary.Base64.CHUNK_SEPARATOR,urlSafe)",null,0,0.8715846,<mask>,"Data, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 =<mask>;
        return b64.encode(binaryData);
    }"
3332,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,833,33026,33098,IdentifierMutator-Conditional,"(isChunked)?neworg.apache.commons.codec.binary.Base64(urlSafe):neworg.apache.commons.codec.binary.Base64(0,org.apache.commons.codec.binary.Base64.CHUNK_SEPARATOR,urlSafe)",this,1,0.051565737,<mask>,"Data, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 =<mask>;
        return b64.encode(binaryData);
    }"
3333,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,833,33026,33098,IdentifierMutator-Conditional,"(isChunked)?neworg.apache.commons.codec.binary.Base64(urlSafe):neworg.apache.commons.codec.binary.Base64(0,org.apache.commons.codec.binary.Base64.CHUNK_SEPARATOR,urlSafe)",NULL,2,0.022475941,<mask>,"Data, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 =<mask>;
        return b64.encode(binaryData);
    }"
3334,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,833,33026,33098,IdentifierMutator-Conditional,"(isChunked)?neworg.apache.commons.codec.binary.Base64(urlSafe):neworg.apache.commons.codec.binary.Base64(0,org.apache.commons.codec.binary.Base64.CHUNK_SEPARATOR,urlSafe)","""""",3,0.010357452,<mask>,"Data, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 =<mask>;
        return b64.encode(binaryData);
    }"
3335,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,833,33026,33098,IdentifierMutator-Conditional,"(isChunked)?neworg.apache.commons.codec.binary.Base64(urlSafe):neworg.apache.commons.codec.binary.Base64(0,org.apache.commons.codec.binary.Base64.CHUNK_SEPARATOR,urlSafe)",64,4,0.0027457816,<mask>,"Data, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 =<mask>;
        return b64.encode(binaryData);
    }"
3336,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,833,33026,33034,IdentifierMutator-Variable,isChunked,secure,0,0.22123437,<mask>,"Data, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 =<mask> ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3337,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,833,33026,33034,IdentifierMutator-Variable,isChunked,safe,1,0.2088338,<mask>,"Data, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 =<mask> ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3338,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,833,33026,33034,IdentifierMutator-Variable,isChunked,escaped,2,0.055224158,<mask>,"Data, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 =<mask> ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3339,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,833,33026,33034,IdentifierMutator-Variable,isChunked,encoded,3,0.04544912,<mask>,"Data, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 =<mask> ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3340,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,833,33026,33034,IdentifierMutator-Variable,isChunked,strict,4,0.036001693,<mask>,"Data, boolean isChunked, boolean urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 =<mask> ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3341,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,833,33049,33055,IdentifierMutator-Variable,urlSafe,0,0,0.108795315,<mask>," urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(<mask>) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3342,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,833,33049,33055,IdentifierMutator-Variable,urlSafe,bytes,1,0.093213886,<mask>," urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(<mask>) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3343,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,833,33049,33055,IdentifierMutator-Variable,urlSafe,data,2,0.066369146,<mask>," urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(<mask>) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3344,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,833,33049,33055,IdentifierMutator-Variable,urlSafe,64,3,0.06306313,<mask>," urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(<mask>) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3345,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,833,33049,33055,IdentifierMutator-Variable,urlSafe,512,4,0.054143406,<mask>," urlSafe, int maxResultSize) {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(<mask>) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3346,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,833,33071,33071,IdentifierMutator-Literal,0,data,0,0.25298807,<mask>," {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(<mask>, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3347,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,833,33071,33071,IdentifierMutator-Literal,0,bytes,1,0.17301323,<mask>," {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(<mask>, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3348,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,833,33071,33071,IdentifierMutator-Literal,0,src,2,0.04875233,<mask>," {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(<mask>, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3349,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,833,33071,33071,IdentifierMutator-Literal,0,string,3,0.0431315,<mask>," {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(<mask>, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3350,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,833,33071,33071,IdentifierMutator-Literal,0,url,4,0.027205577,<mask>," {
        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(<mask>, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(binaryData);
    }"
3351,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,833,33074,33088,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.CHUNK_SEPARATOR,len,0,0.59658617,<mask>,"        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0,<mask>, urlSafe);
        return b64.encode(binaryData);
    }"
3352,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,833,33074,33088,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.CHUNK_SEPARATOR,0,1,0.14188406,<mask>,"        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0,<mask>, urlSafe);
        return b64.encode(binaryData);
    }"
3353,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,833,33074,33088,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.CHUNK_SEPARATOR,null,2,0.023807593,<mask>,"        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0,<mask>, urlSafe);
        return b64.encode(binaryData);
    }"
3354,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,833,33074,33088,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.CHUNK_SEPARATOR,length,3,0.020673549,<mask>,"        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0,<mask>, urlSafe);
        return b64.encode(binaryData);
    }"
3355,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,833,33074,33088,IdentifierMutator-Variable,org.apache.commons.codec.binary.Base64.CHUNK_SEPARATOR,"''",4,0.01707315,<mask>,"        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0,<mask>, urlSafe);
        return b64.encode(binaryData);
    }"
3356,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,833,33074,33088,FieldReferenceMutator,CHUNK_SEPARATOR,len,0,0.59658617,org.apache.commons.codec.binary.Base64.<mask>,"        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0,<mask>, urlSafe);
        return b64.encode(binaryData);
    }"
3357,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,833,33074,33088,FieldReferenceMutator,CHUNK_SEPARATOR,0,1,0.14188406,org.apache.commons.codec.binary.Base64.<mask>,"        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0,<mask>, urlSafe);
        return b64.encode(binaryData);
    }"
3358,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,833,33074,33088,FieldReferenceMutator,CHUNK_SEPARATOR,null,2,0.023807593,org.apache.commons.codec.binary.Base64.<mask>,"        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0,<mask>, urlSafe);
        return b64.encode(binaryData);
    }"
3359,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,833,33074,33088,FieldReferenceMutator,CHUNK_SEPARATOR,length,3,0.020673549,org.apache.commons.codec.binary.Base64.<mask>,"        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0,<mask>, urlSafe);
        return b64.encode(binaryData);
    }"
3360,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,833,33074,33088,FieldReferenceMutator,CHUNK_SEPARATOR,"''",4,0.01707315,org.apache.commons.codec.binary.Base64.<mask>,"        if (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0,<mask>, urlSafe);
        return b64.encode(binaryData);
    }"
3361,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,833,33091,33097,IdentifierMutator-Variable,urlSafe,len,0,0.24490587,<mask>," (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR,<mask>);
        return b64.encode(binaryData);
    }"
3362,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,833,33091,33097,IdentifierMutator-Variable,urlSafe,0,1,0.10563107,<mask>," (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR,<mask>);
        return b64.encode(binaryData);
    }"
3363,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,833,33091,33097,IdentifierMutator-Variable,urlSafe,"''",2,0.05678806,<mask>," (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR,<mask>);
        return b64.encode(binaryData);
    }"
3364,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,833,33091,33097,IdentifierMutator-Variable,urlSafe,true,3,0.055273216,<mask>," (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR,<mask>);
        return b64.encode(binaryData);
    }"
3365,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,833,33091,33097,IdentifierMutator-Variable,urlSafe,encoding,4,0.045699693,<mask>," (binaryData == null || binaryData.length == 0) {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR,<mask>);
        return b64.encode(binaryData);
    }"
3366,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,834,33120,33125,MethodCallMutator,encode,write,0,0.4675696,b64.<mask>(binaryData),"            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.<mask>(binaryData);
    }"
3367,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,834,33120,33125,MethodCallMutator,encode,code,1,0.122728914,b64.<mask>(binaryData),"            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.<mask>(binaryData);
    }"
3368,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,834,33120,33125,MethodCallMutator,encode,update,2,0.05121316,b64.<mask>(binaryData),"            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.<mask>(binaryData);
    }"
3369,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,834,33120,33125,MethodCallMutator,encode,copy,3,0.04684352,b64.<mask>(binaryData),"            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.<mask>(binaryData);
    }"
3370,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,834,33120,33125,MethodCallMutator,encode,replace,4,0.034323327,b64.<mask>(binaryData),"            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.<mask>(binaryData);
    }"
3371,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,834,33116,33118,IdentifierMutator-Variable,b64,enc,0,0.34804705,<mask>,") {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return<mask>.encode(binaryData);
    }"
3372,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,834,33116,33118,IdentifierMutator-Variable,b64,codec,1,0.1603494,<mask>,") {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return<mask>.encode(binaryData);
    }"
3373,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,834,33116,33118,IdentifierMutator-Variable,b64,super,2,0.08644313,<mask>,") {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return<mask>.encode(binaryData);
    }"
3374,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,834,33116,33118,IdentifierMutator-Variable,b64,bos,3,0.03308142,<mask>,") {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return<mask>.encode(binaryData);
    }"
3375,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,834,33116,33118,IdentifierMutator-Variable,b64,this,4,0.029916229,<mask>,") {
            return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return<mask>.encode(binaryData);
    }"
3376,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,834,33127,33136,IdentifierMutator-Variable,binaryData,output,0,0.13606969,<mask>,"         return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(<mask>);
    }"
3377,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,834,33127,33136,IdentifierMutator-Variable,binaryData,data,1,0.11674586,<mask>,"         return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(<mask>);
    }"
3378,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,834,33127,33136,IdentifierMutator-Variable,binaryData,bytes,2,0.07375142,<mask>,"         return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(<mask>);
    }"
3379,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,834,33127,33136,IdentifierMutator-Variable,binaryData,null,3,0.06461119,<mask>,"         return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(<mask>);
    }"
3380,Base64.java,encodeBase64,"byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)",820,834,33127,33136,IdentifierMutator-Variable,binaryData,string,4,0.049395796,<mask>,"         return binaryData;
        }

        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);
        if (len > maxResultSize) {
            throw new IllegalArgumentException(""Input array too big, the output array would be bigger ("" +
                len +
                "") than the specified maxium size of "" +
                maxResultSize);
        }
                
        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
        return b64.encode(<mask>);
    }"
3381,Base64.java,decodeBase64,byte[] decodeBase64(String base64String),845,846,33441,33446,MethodCallMutator,decode,read,0,0.23005044,new Base64().<mask>(base64String),"byte[] decodeBase64(String base64String) {
        return new Base64().<mask>(base64String);
    }"
3382,Base64.java,decodeBase64,byte[] decodeBase64(String base64String),845,846,33441,33446,MethodCallMutator,decode,ode,2,0.13044131,new Base64().<mask>(base64String),"byte[] decodeBase64(String base64String) {
        return new Base64().<mask>(base64String);
    }"
3383,Base64.java,decodeBase64,byte[] decodeBase64(String base64String),845,846,33441,33446,MethodCallMutator,decode,load,3,0.113766424,new Base64().<mask>(base64String),"byte[] decodeBase64(String base64String) {
        return new Base64().<mask>(base64String);
    }"
3384,Base64.java,decodeBase64,byte[] decodeBase64(String base64String),845,846,33441,33446,MethodCallMutator,decode,dec,4,0.08550016,new Base64().<mask>(base64String),"byte[] decodeBase64(String base64String) {
        return new Base64().<mask>(base64String);
    }"
3385,Base64.java,decodeBase64,byte[] decodeBase64(String base64String),845,846,33448,33459,IdentifierMutator-Variable,base64String,string,0,0.51462966,<mask>,"byte[] decodeBase64(String base64String) {
        return new Base64().decode(<mask>);
    }"
3386,Base64.java,decodeBase64,byte[] decodeBase64(String base64String),845,846,33448,33459,IdentifierMutator-Variable,base64String,bytes,1,0.14441289,<mask>,"byte[] decodeBase64(String base64String) {
        return new Base64().decode(<mask>);
    }"
3387,Base64.java,decodeBase64,byte[] decodeBase64(String base64String),845,846,33448,33459,IdentifierMutator-Variable,base64String,input,2,0.050064214,<mask>,"byte[] decodeBase64(String base64String) {
        return new Base64().decode(<mask>);
    }"
3388,Base64.java,decodeBase64,byte[] decodeBase64(String base64String),845,846,33448,33459,IdentifierMutator-Variable,base64String,data,3,0.043782957,<mask>,"byte[] decodeBase64(String base64String) {
        return new Base64().decode(<mask>);
    }"
3389,Base64.java,decodeBase64,byte[] decodeBase64(String base64String),845,846,33448,33459,IdentifierMutator-Variable,base64String,str,4,0.033860866,<mask>,"byte[] decodeBase64(String base64String) {
        return new Base64().decode(<mask>);
    }"
3390,Base64.java,decodeBase64,byte[] decodeBase64(byte[] base64Data),856,857,33743,33748,MethodCallMutator,decode,read,0,0.16027991,new Base64().<mask>(base64Data),"byte[] decodeBase64(byte[] base64Data) {
        return new Base64().<mask>(base64Data);
    }"
3391,Base64.java,decodeBase64,byte[] decodeBase64(byte[] base64Data),856,857,33743,33748,MethodCallMutator,decode,split,2,0.117556654,new Base64().<mask>(base64Data),"byte[] decodeBase64(byte[] base64Data) {
        return new Base64().<mask>(base64Data);
    }"
3392,Base64.java,decodeBase64,byte[] decodeBase64(byte[] base64Data),856,857,33743,33748,MethodCallMutator,decode,load,3,0.0880729,new Base64().<mask>(base64Data),"byte[] decodeBase64(byte[] base64Data) {
        return new Base64().<mask>(base64Data);
    }"
3393,Base64.java,decodeBase64,byte[] decodeBase64(byte[] base64Data),856,857,33743,33748,MethodCallMutator,decode,ode,4,0.08669638,new Base64().<mask>(base64Data),"byte[] decodeBase64(byte[] base64Data) {
        return new Base64().<mask>(base64Data);
    }"
3394,Base64.java,decodeBase64,byte[] decodeBase64(byte[] base64Data),856,857,33750,33759,IdentifierMutator-Variable,base64Data,data,0,0.84126043,<mask>,"byte[] decodeBase64(byte[] base64Data) {
        return new Base64().decode(<mask>);
    }"
3395,Base64.java,decodeBase64,byte[] decodeBase64(byte[] base64Data),856,857,33750,33759,IdentifierMutator-Variable,base64Data,bytes,1,0.039528534,<mask>,"byte[] decodeBase64(byte[] base64Data) {
        return new Base64().decode(<mask>);
    }"
3396,Base64.java,decodeBase64,byte[] decodeBase64(byte[] base64Data),856,857,33750,33759,IdentifierMutator-Variable,base64Data,input,2,0.023998328,<mask>,"byte[] decodeBase64(byte[] base64Data) {
        return new Base64().decode(<mask>);
    }"
3397,Base64.java,decodeBase64,byte[] decodeBase64(byte[] base64Data),856,857,33750,33759,IdentifierMutator-Variable,base64Data,buffer,3,0.013202573,<mask>,"byte[] decodeBase64(byte[] base64Data) {
        return new Base64().decode(<mask>);
    }"
3398,Base64.java,decodeBase64,byte[] decodeBase64(byte[] base64Data),856,857,33750,33759,IdentifierMutator-Variable,base64Data,raw,4,0.008954871,<mask>,"byte[] decodeBase64(byte[] base64Data) {
        return new Base64().decode(<mask>);
    }"
3399,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,869,34146,34156,IdentifierMutator-Variable,data.length,size,0,0.088934466,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[<mask>];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3400,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,869,34146,34156,IdentifierMutator-Variable,data.length,0,1,0.07688801,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[<mask>];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3401,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,869,34146,34156,IdentifierMutator-Variable,data.length,1024,2,0.07662493,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[<mask>];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3402,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,869,34146,34156,IdentifierMutator-Variable,data.length,1,3,0.038702115,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[<mask>];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3403,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,869,34146,34156,IdentifierMutator-Variable,data.length,16,4,0.037849266,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[<mask>];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3404,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,869,34146,34149,IdentifierMutator-Variable,data,Data,2,7.707885E-4,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[<mask>.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3405,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,869,34146,34149,IdentifierMutator-Variable,data,DATA,3,1.8118248E-4,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[<mask>.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3406,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,869,34146,34149,IdentifierMutator-Variable,data,string,4,1.207517E-4,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[<mask>.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3407,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,869,34151,34156,FieldReferenceMutator,length,size,1,4.4816086E-5,data.<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.<mask>];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3408,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,869,34151,34156,FieldReferenceMutator,length,len,3,1.0469613E-5,data.<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.<mask>];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3409,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,869,34151,34156,FieldReferenceMutator,length,count,4,6.2486515E-6,data.<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.<mask>];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3410,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,870,34186,34186,IdentifierMutator-Literal,0,1,1,0.037395295,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied =<mask>;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3411,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,870,34186,34186,IdentifierMutator-Literal,0,2,2,0.0011831039,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied =<mask>;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3412,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,870,34186,34186,IdentifierMutator-Literal,0,4,3,4.8331072E-4,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied =<mask>;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3413,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,871,34210,34210,IdentifierMutator-Literal,0,1,1,0.0064545837,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i =<mask>; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3414,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,871,34210,34210,IdentifierMutator-Literal,0,i,3,2.7148053E-4,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i =<mask>; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3415,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,871,34210,34210,IdentifierMutator-Literal,0,2,4,2.3112416E-4,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i =<mask>; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3416,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,871,34214,34216,BinaryOperatorMutator,<,++,2,0.0012738135,i <mask> data.length,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i<mask>data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3417,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,871,34214,34216,BinaryOperatorMutator,<,==,3,6.527805E-4,i <mask> data.length,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i<mask>data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3418,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,871,34214,34216,BinaryOperatorMutator,<,.<,4,5.5742805E-4,i <mask> data.length,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i<mask>data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3419,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,871,34213,34213,IdentifierMutator-Variable,i,I,2,8.1750586E-5,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0;<mask> < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3420,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,871,34213,34213,IdentifierMutator-Variable,i,0,3,4.6001685E-5,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0;<mask> < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3421,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,871,34213,34213,IdentifierMutator-Variable,i,I,4,3.5065892E-5,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0;<mask> < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3422,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,871,34217,34227,IdentifierMutator-Variable,data.length,length,0,0.20823966,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i <<mask>; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3423,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,871,34217,34227,IdentifierMutator-Variable,data.length,size,1,0.14010033,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i <<mask>; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3424,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,871,34217,34227,IdentifierMutator-Variable,data.length,len,2,0.10720097,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i <<mask>; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3425,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,871,34217,34227,IdentifierMutator-Variable,data.length,n,3,0.046964757,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i <<mask>; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3426,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,871,34217,34227,IdentifierMutator-Variable,data.length,256,4,0.04154463,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i <<mask>; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3427,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,871,34217,34220,IdentifierMutator-Variable,data,buffer,2,1.7749013E-4,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i <<mask>.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3428,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,871,34217,34220,IdentifierMutator-Variable,data,Data,3,1.2010338E-4,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i <<mask>.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3429,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,871,34217,34220,IdentifierMutator-Variable,data,input,4,9.787504E-5,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i <<mask>.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3430,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,871,34222,34227,FieldReferenceMutator,length,size,2,1.1294446E-5,data.<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.<mask>; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3431,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,871,34222,34227,FieldReferenceMutator,length,Length,3,5.3892527E-6,data.<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.<mask>; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3432,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,871,34222,34227,FieldReferenceMutator,length,position,4,4.986031E-6,data.<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.<mask>; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3433,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,871,34231,34232,UnaryOperatorMutator,++,++),2,0.004225447,i<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i<mask>) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3434,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,871,34231,34232,UnaryOperatorMutator,++,++;,3,2.2569772E-4,i<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i<mask>) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3435,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,871,34231,34232,UnaryOperatorMutator,++,--,4,1.2584057E-4,i<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i<mask>) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3436,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,871,34230,34230,IdentifierMutator-Variable,i,I,2,2.4985928E-5,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length;<mask>++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3437,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,871,34230,34230,IdentifierMutator-Variable,i,++,3,1.842373E-5,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length;<mask>++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3438,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,871,34230,34230,IdentifierMutator-Variable,i,,4,1.6523276E-5,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length;<mask>++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3439,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,872,34262,34262,ArrayAccessMutator,i,I,2,4.016381E-5,data[<mask>],"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[<mask>]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3440,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,872,34262,34262,ArrayAccessMutator,i,0,3,2.2881375E-5,data[<mask>],"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[<mask>]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3441,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,872,34262,34262,ArrayAccessMutator,i,j,4,9.057474E-6,data[<mask>],"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[<mask>]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3442,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,872,34257,34260,IdentifierMutator-Variable,data,input,2,1.8172493E-4,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (<mask>[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3443,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,872,34257,34260,IdentifierMutator-Variable,data,string,3,1.7926209E-4,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (<mask>[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3444,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,872,34257,34260,IdentifierMutator-Variable,data,Data,4,1.5542985E-4,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (<mask>[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3445,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,872,34262,34262,IdentifierMutator-Variable,i,I,2,4.016381E-5,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[<mask>]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3446,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,872,34262,34262,IdentifierMutator-Variable,i,0,3,2.2881375E-5,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[<mask>]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3447,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,872,34262,34262,IdentifierMutator-Variable,i,j,4,9.057474E-6,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[<mask>]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3448,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,873,34289,34291,IdentifierMutator-Literal,"''",0,1,0.08244818,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case<mask> :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3449,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,873,34289,34291,IdentifierMutator-Literal,"''",127,2,0.06145017,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case<mask> :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3450,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,873,34289,34291,IdentifierMutator-Literal,"''",null,3,0.0526348,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case<mask> :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3451,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,873,34289,34291,IdentifierMutator-Literal,"''","'",4,0.041249163,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case<mask> :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3452,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,874,34316,34319,IdentifierMutator-Literal,"'\n'","''",0,0.28521597,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case<mask> :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3453,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,874,34316,34319,IdentifierMutator-Literal,"'\n'",0,1,0.089137726,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case<mask> :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3454,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,874,34316,34319,IdentifierMutator-Literal,"'\n'",null,2,0.04380775,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case<mask> :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3455,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,874,34316,34319,IdentifierMutator-Literal,"'\n'","'",3,0.029761141,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case<mask> :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3456,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,874,34316,34319,IdentifierMutator-Literal,"'\n'",32,4,0.029639969,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case<mask> :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3457,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,875,34344,34347,IdentifierMutator-Literal,"'\r'","''",0,0.5357186,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case<mask> :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3458,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,875,34344,34347,IdentifierMutator-Literal,"'\r'",0,1,0.065153934,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case<mask> :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3459,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,875,34344,34347,IdentifierMutator-Literal,"'\r'",null,2,0.048696417,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case<mask> :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3460,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,875,34344,34347,IdentifierMutator-Literal,"'\r'",undefined,3,0.012858429,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case<mask> :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3461,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,875,34344,34347,IdentifierMutator-Literal,"'\r'",2,4,0.01121744,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case<mask> :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3462,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,876,34372,34375,IdentifierMutator-Literal,"'\t'","''",0,0.6441391,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case<mask> :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3463,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,876,34372,34375,IdentifierMutator-Literal,"'\t'",null,1,0.116853796,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case<mask> :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3464,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,876,34372,34375,IdentifierMutator-Literal,"'\t'",undefined,2,0.038914785,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case<mask> :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3465,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,876,34372,34375,IdentifierMutator-Literal,"'\t'",0,3,0.022741282,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case<mask> :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3466,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,876,34372,34375,IdentifierMutator-Literal,"'\t'",false,4,0.015436804,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case<mask> :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3467,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,879,34478,34478,AssignmentMutator,groomedData[bytesCopied++]=data[i],^,0,0.6197974,groomedData[bytesCopied++] <mask>= data[i],"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++]<mask>= data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3468,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,879,34478,34478,AssignmentMutator,groomedData[bytesCopied++]=data[i],|,1,0.33990026,groomedData[bytesCopied++] <mask>= data[i],"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++]<mask>= data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3469,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,879,34478,34478,AssignmentMutator,groomedData[bytesCopied++]=data[i],*,2,0.012758829,groomedData[bytesCopied++] <mask>= data[i],"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++]<mask>= data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3470,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,879,34478,34478,AssignmentMutator,groomedData[bytesCopied++]=data[i],&,3,0.0063087577,groomedData[bytesCopied++] <mask>= data[i],"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++]<mask>= data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3471,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,879,34478,34478,AssignmentMutator,groomedData[bytesCopied++]=data[i],.,4,0.0041533955,groomedData[bytesCopied++] <mask>= data[i],"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++]<mask>= data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3472,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,879,34464,34476,ArrayAccessMutator,bytesCopied++,i,0,0.99585956,groomedData[<mask>],"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[<mask>] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3473,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,879,34464,34476,ArrayAccessMutator,bytesCopied++,i,1,7.5192103E-4,groomedData[<mask>],"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[<mask>] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3474,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,879,34464,34476,ArrayAccessMutator,bytesCopied++,0,2,5.581337E-4,groomedData[<mask>],"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[<mask>] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3475,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,879,34464,34476,ArrayAccessMutator,bytesCopied++,j,3,5.111515E-4,groomedData[<mask>],"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[<mask>] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3476,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,879,34464,34476,ArrayAccessMutator,bytesCopied++,1,4,1.2407721E-4,groomedData[<mask>],"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[<mask>] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3477,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,879,34452,34462,IdentifierMutator-Variable,groomedData,data,0,0.5821798,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :<mask>[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3478,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,879,34452,34462,IdentifierMutator-Variable,groomedData,buffer,1,0.035347022,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :<mask>[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3479,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,879,34452,34462,IdentifierMutator-Variable,groomedData,data,2,0.028639225,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :<mask>[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3480,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,879,34452,34462,IdentifierMutator-Variable,groomedData,bytes,3,0.025771677,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :<mask>[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3481,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,879,34452,34462,IdentifierMutator-Variable,groomedData,byte,4,0.025038369,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :<mask>[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3482,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,879,34475,34476,UnaryOperatorMutator,++,][,2,0.053754125,bytesCopied<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied<mask>] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3483,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,879,34475,34476,UnaryOperatorMutator,++,Index,3,0.0029078415,bytesCopied<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied<mask>] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3484,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,879,34475,34476,UnaryOperatorMutator,++,:,4,0.0018770318,bytesCopied<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied<mask>] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3485,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,879,34464,34474,IdentifierMutator-Variable,bytesCopied,i,0,0.9793088,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[<mask>++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3486,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,879,34464,34474,IdentifierMutator-Variable,bytesCopied,j,1,0.0033990694,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[<mask>++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3487,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,879,34464,34474,IdentifierMutator-Variable,bytesCopied,c,2,0.0017561538,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[<mask>++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3488,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,879,34464,34474,IdentifierMutator-Variable,bytesCopied,i,3,0.0016460998,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[<mask>++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3489,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,879,34464,34474,IdentifierMutator-Variable,bytesCopied,d,4,0.0010722802,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[<mask>++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3490,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,879,34486,34486,ArrayAccessMutator,i,j,2,1.691398E-4,data[<mask>],"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[<mask>];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3491,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,879,34486,34486,ArrayAccessMutator,i,I,3,1.0576023E-4,data[<mask>],"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[<mask>];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3492,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,879,34486,34486,ArrayAccessMutator,i,c,4,3.8448088E-5,data[<mask>],"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[<mask>];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3493,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,879,34481,34484,IdentifierMutator-Variable,data,buffer,2,9.732032E-5,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] =<mask>[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3494,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,879,34481,34484,IdentifierMutator-Variable,data,text,3,9.033422E-5,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] =<mask>[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3495,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,879,34481,34484,IdentifierMutator-Variable,data,input,4,4.8283306E-5,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] =<mask>[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3496,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,879,34486,34486,IdentifierMutator-Variable,i,j,2,1.691398E-4,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[<mask>];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3497,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,879,34486,34486,IdentifierMutator-Variable,i,I,3,1.0576023E-4,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[<mask>];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3498,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,879,34486,34486,IdentifierMutator-Variable,i,c,4,3.8448088E-5,<mask>,"byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[<mask>];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3499,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,882,34551,34561,IdentifierMutator-Variable,bytesCopied,0,0,0.16547705,<mask>,"        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[<mask>];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3500,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,882,34551,34561,IdentifierMutator-Variable,bytesCopied,1024,1,0.08230046,<mask>,"        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[<mask>];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3501,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,882,34551,34561,IdentifierMutator-Variable,bytesCopied,size,2,0.075461954,<mask>,"        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[<mask>];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3502,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,882,34551,34561,IdentifierMutator-Variable,bytesCopied,1,3,0.044450767,<mask>,"        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[<mask>];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3503,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,882,34551,34561,IdentifierMutator-Variable,bytesCopied,64,4,0.03297563,<mask>,"        int bytesCopied = 0;
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[<mask>];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3504,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,883,34580,34588,MethodCallMutator,arraycopy,copy,0,0.98436165,"System.<mask>(groomedData, 0, packedData, 0, bytesCopied)","
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.<mask>(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3505,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,883,34580,34588,MethodCallMutator,arraycopy,dump,1,0.0050194873,"System.<mask>(groomedData, 0, packedData, 0, bytesCopied)","
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.<mask>(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3506,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,883,34580,34588,MethodCallMutator,arraycopy,printf,2,0.0035116472,"System.<mask>(groomedData, 0, packedData, 0, bytesCopied)","
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.<mask>(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3507,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,883,34580,34588,MethodCallMutator,arraycopy,array,3,0.002767085,"System.<mask>(groomedData, 0, packedData, 0, bytesCopied)","
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.<mask>(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3508,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,883,34580,34588,MethodCallMutator,arraycopy,write,4,5.26446E-4,"System.<mask>(groomedData, 0, packedData, 0, bytesCopied)","
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.<mask>(groomedData, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3509,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,883,34590,34600,IdentifierMutator-Variable,groomedData,data,0,0.98286706,<mask>,"      for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(<mask>, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3510,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,883,34590,34600,IdentifierMutator-Variable,groomedData,buffer,1,0.0033180923,<mask>,"      for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(<mask>, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3511,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,883,34590,34600,IdentifierMutator-Variable,groomedData,bytes,2,0.0025030847,<mask>,"      for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(<mask>, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3512,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,883,34590,34600,IdentifierMutator-Variable,groomedData,DATA,3,7.962062E-4,<mask>,"      for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(<mask>, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3513,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,883,34590,34600,IdentifierMutator-Variable,groomedData,buf,4,5.89633E-4,<mask>,"      for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(<mask>, 0, packedData, 0, bytesCopied);
        return packedData;
    }"
3514,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,883,34603,34603,IdentifierMutator-Literal,0,1,1,0.011507818,<mask>," for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData,<mask>, packedData, 0, bytesCopied);
        return packedData;
    }"
3515,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,883,34603,34603,IdentifierMutator-Literal,0,i,3,0.0029997528,<mask>," for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData,<mask>, packedData, 0, bytesCopied);
        return packedData;
    }"
3516,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,883,34603,34603,IdentifierMutator-Literal,0,2,4,0.0010386878,<mask>," for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData,<mask>, packedData, 0, bytesCopied);
        return packedData;
    }"
3517,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,883,34606,34615,IdentifierMutator-Variable,packedData,data,0,0.89924085,<mask>,"int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0,<mask>, 0, bytesCopied);
        return packedData;
    }"
3518,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,883,34606,34615,IdentifierMutator-Variable,packedData,packed,1,0.033504687,<mask>,"int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0,<mask>, 0, bytesCopied);
        return packedData;
    }"
3519,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,883,34606,34615,IdentifierMutator-Variable,packedData,array,2,0.007896026,<mask>,"int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0,<mask>, 0, bytesCopied);
        return packedData;
    }"
3520,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,883,34606,34615,IdentifierMutator-Variable,packedData,tmp,3,0.0047962023,<mask>,"int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0,<mask>, 0, bytesCopied);
        return packedData;
    }"
3521,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,883,34606,34615,IdentifierMutator-Variable,packedData,buf,4,0.0030134527,<mask>,"int i = 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0,<mask>, 0, bytesCopied);
        return packedData;
    }"
3522,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,883,34618,34618,IdentifierMutator-Literal,0,1,1,0.011871785,<mask>," 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData,<mask>, bytesCopied);
        return packedData;
    }"
3523,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,883,34618,34618,IdentifierMutator-Literal,0,i,3,7.7413017E-4,<mask>," 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData,<mask>, bytesCopied);
        return packedData;
    }"
3524,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,883,34618,34618,IdentifierMutator-Literal,0,2,4,7.4331305E-4,<mask>," 0; i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData,<mask>, bytesCopied);
        return packedData;
    }"
3525,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,883,34621,34631,IdentifierMutator-Variable,bytesCopied,length,0,0.16044208,<mask>," i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0,<mask>);
        return packedData;
    }"
3526,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,883,34621,34631,IdentifierMutator-Variable,bytesCopied,len,1,0.1513442,<mask>," i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0,<mask>);
        return packedData;
    }"
3527,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,883,34621,34631,IdentifierMutator-Variable,bytesCopied,n,2,0.10035997,<mask>," i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0,<mask>);
        return packedData;
    }"
3528,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,883,34621,34631,IdentifierMutator-Variable,bytesCopied,count,3,0.07970854,<mask>," i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0,<mask>);
        return packedData;
    }"
3529,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,883,34621,34631,IdentifierMutator-Variable,bytesCopied,bytes,4,0.07962785,<mask>," i < data.length; i++) {
            switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0,<mask>);
        return packedData;
    }"
3530,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,884,34650,34659,IdentifierMutator-Variable,packedData,0,0,0.1298416,<mask>,"         switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return<mask>;
    }"
3531,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,884,34650,34659,IdentifierMutator-Variable,packedData,data,1,0.11107518,<mask>,"         switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return<mask>;
    }"
3532,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,884,34650,34659,IdentifierMutator-Variable,packedData,true,2,0.099648565,<mask>,"         switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return<mask>;
    }"
3533,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,884,34650,34659,IdentifierMutator-Variable,packedData,null,3,0.08064939,<mask>,"         switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return<mask>;
    }"
3534,Base64.java,discardWhitespace,byte[] discardWhitespace(byte[] data),868,884,34650,34659,IdentifierMutator-Variable,packedData,"""""",4,0.0639,<mask>,"         switch (data[i]) {
                case ' ' :
                case '\n' :
                case '\r' :
                case '\t' :
                    break;
                default :
                    groomedData[bytesCopied++] = data[i];
            }
        }
        byte packedData[] = new byte[bytesCopied];
        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);
        return<mask>;
    }"
3535,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),894,895,34942,34952,IdentifierMutator-Variable,byteToCheck,byte,0,0.87689835,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (<mask>) {
            case ' ' :
            case '\n' :
            case '\r' :
            case '\t' :
                return true;
            default :
                return false;
        }
    }"
3536,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),894,895,34942,34952,IdentifierMutator-Variable,byteToCheck,char,1,0.041675314,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (<mask>) {
            case ' ' :
            case '\n' :
            case '\r' :
            case '\t' :
                return true;
            default :
                return false;
        }
    }"
3537,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),894,895,34942,34952,IdentifierMutator-Variable,byteToCheck,token,2,0.011559272,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (<mask>) {
            case ' ' :
            case '\n' :
            case '\r' :
            case '\t' :
                return true;
            default :
                return false;
        }
    }"
3538,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),894,895,34942,34952,IdentifierMutator-Variable,byteToCheck,character,3,0.0059702797,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (<mask>) {
            case ' ' :
            case '\n' :
            case '\r' :
            case '\t' :
                return true;
            default :
                return false;
        }
    }"
3539,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),894,895,34942,34952,IdentifierMutator-Variable,byteToCheck,letter,4,0.0045639197,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (<mask>) {
            case ' ' :
            case '\n' :
            case '\r' :
            case '\t' :
                return true;
            default :
                return false;
        }
    }"
3540,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),894,896,34974,34976,IdentifierMutator-Literal,"''",127,1,0.11638416,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case<mask> :
            case '\n' :
            case '\r' :
            case '\t' :
                return true;
            default :
                return false;
        }
    }"
3541,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),894,896,34974,34976,IdentifierMutator-Literal,"''","'",2,0.100291535,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case<mask> :
            case '\n' :
            case '\r' :
            case '\t' :
                return true;
            default :
                return false;
        }
    }"
3542,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),894,896,34974,34976,IdentifierMutator-Literal,"''",0,3,0.07361801,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case<mask> :
            case '\n' :
            case '\r' :
            case '\t' :
                return true;
            default :
                return false;
        }
    }"
3543,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),894,896,34974,34976,IdentifierMutator-Literal,"''",null,4,0.030010344,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case<mask> :
            case '\n' :
            case '\r' :
            case '\t' :
                return true;
            default :
                return false;
        }
    }"
3544,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),894,897,34997,35000,IdentifierMutator-Literal,"'\n'","''",0,0.31404096,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case<mask> :
            case '\r' :
            case '\t' :
                return true;
            default :
                return false;
        }
    }"
3545,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),894,897,34997,35000,IdentifierMutator-Literal,"'\n'",0,1,0.06704349,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case<mask> :
            case '\r' :
            case '\t' :
                return true;
            default :
                return false;
        }
    }"
3546,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),894,897,34997,35000,IdentifierMutator-Literal,"'\n'","'",2,0.048901446,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case<mask> :
            case '\r' :
            case '\t' :
                return true;
            default :
                return false;
        }
    }"
3547,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),894,897,34997,35000,IdentifierMutator-Literal,"'\n'",null,3,0.04076971,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case<mask> :
            case '\r' :
            case '\t' :
                return true;
            default :
                return false;
        }
    }"
3548,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),894,897,34997,35000,IdentifierMutator-Literal,"'\n'",127,4,0.030773241,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case<mask> :
            case '\r' :
            case '\t' :
                return true;
            default :
                return false;
        }
    }"
3549,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),894,898,35021,35024,IdentifierMutator-Literal,"'\r'","''",0,0.31427732,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case '\n' :
            case<mask> :
            case '\t' :
                return true;
            default :
                return false;
        }
    }"
3550,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),894,898,35021,35024,IdentifierMutator-Literal,"'\r'",0,1,0.070253536,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case '\n' :
            case<mask> :
            case '\t' :
                return true;
            default :
                return false;
        }
    }"
3551,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),894,898,35021,35024,IdentifierMutator-Literal,"'\r'",127,2,0.041286614,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case '\n' :
            case<mask> :
            case '\t' :
                return true;
            default :
                return false;
        }
    }"
3552,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),894,898,35021,35024,IdentifierMutator-Literal,"'\r'",null,3,0.0325793,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case '\n' :
            case<mask> :
            case '\t' :
                return true;
            default :
                return false;
        }
    }"
3553,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),894,898,35021,35024,IdentifierMutator-Literal,"'\r'",13,4,0.030142767,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case '\n' :
            case<mask> :
            case '\t' :
                return true;
            default :
                return false;
        }
    }"
3554,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),894,899,35045,35048,IdentifierMutator-Literal,"'\t'","''",0,0.3427563,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case '\n' :
            case '\r' :
            case<mask> :
                return true;
            default :
                return false;
        }
    }"
3555,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),894,899,35045,35048,IdentifierMutator-Literal,"'\t'",0,1,0.13208826,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case '\n' :
            case '\r' :
            case<mask> :
                return true;
            default :
                return false;
        }
    }"
3556,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),894,899,35045,35048,IdentifierMutator-Literal,"'\t'",127,2,0.042970426,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case '\n' :
            case '\r' :
            case<mask> :
                return true;
            default :
                return false;
        }
    }"
3557,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),894,899,35045,35048,IdentifierMutator-Literal,"'\t'",null,3,0.040649995,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case '\n' :
            case '\r' :
            case<mask> :
                return true;
            default :
                return false;
        }
    }"
3558,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),894,899,35045,35048,IdentifierMutator-Literal,"'\t'",128,4,0.03007783,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case '\n' :
            case '\r' :
            case<mask> :
                return true;
            default :
                return false;
        }
    }"
3559,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),894,900,35075,35078,IdentifierMutator-Literal,true,false,1,0.228241,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case '\n' :
            case '\r' :
            case '\t' :
                return<mask>;
            default :
                return false;
        }
    }"
3560,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),894,900,35075,35078,IdentifierMutator-Literal,true,1,2,3.5760348E-4,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case '\n' :
            case '\r' :
            case '\t' :
                return<mask>;
            default :
                return false;
        }
    }"
3561,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),894,900,35075,35078,IdentifierMutator-Literal,true,0,3,2.4162118E-4,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case '\n' :
            case '\r' :
            case '\t' :
                return<mask>;
            default :
                return false;
        }
    }"
3562,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),894,900,35075,35078,IdentifierMutator-Literal,true,null,4,1.45996E-4,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case '\n' :
            case '\r' :
            case '\t' :
                return<mask>;
            default :
                return false;
        }
    }"
3563,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),894,902,35126,35130,IdentifierMutator-Literal,false,true,1,0.34868783,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case '\n' :
            case '\r' :
            case '\t' :
                return true;
            default :
                return<mask>;
        }
    }"
3564,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),894,902,35126,35130,IdentifierMutator-Literal,false,null,2,4.913496E-4,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case '\n' :
            case '\r' :
            case '\t' :
                return true;
            default :
                return<mask>;
        }
    }"
3565,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),894,902,35126,35130,IdentifierMutator-Literal,false,0,3,1.580537E-4,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case '\n' :
            case '\r' :
            case '\t' :
                return true;
            default :
                return<mask>;
        }
    }"
3566,Base64.java,isWhiteSpace,boolean isWhiteSpace(byte byteToCheck),894,902,35126,35130,IdentifierMutator-Literal,false,undefined,4,1.2972756E-4,<mask>,"boolean isWhiteSpace(byte byteToCheck) {
        switch (byteToCheck) {
            case ' ' :
            case '\n' :
            case '\r' :
            case '\t' :
                return true;
            default :
                return<mask>;
        }
    }"
3567,Base64.java,encodeToString,String encodeToString(byte[] pArray),933,934,36403,36415,MethodCallMutator,newStringUtf8,escape,0,0.32738858,StringUtils.<mask>(encode(pArray)),"String encodeToString(byte[] pArray) {
        return StringUtils.<mask>(encode(pArray));
    }"
3568,Base64.java,encodeToString,String encodeToString(byte[] pArray),933,934,36403,36415,MethodCallMutator,newStringUtf8,format,1,0.12487902,StringUtils.<mask>(encode(pArray)),"String encodeToString(byte[] pArray) {
        return StringUtils.<mask>(encode(pArray));
    }"
3569,Base64.java,encodeToString,String encodeToString(byte[] pArray),933,934,36403,36415,MethodCallMutator,newStringUtf8,str,2,0.06766904,StringUtils.<mask>(encode(pArray)),"String encodeToString(byte[] pArray) {
        return StringUtils.<mask>(encode(pArray));
    }"
3570,Base64.java,encodeToString,String encodeToString(byte[] pArray),933,934,36403,36415,MethodCallMutator,newStringUtf8,string,3,0.051101003,StringUtils.<mask>(encode(pArray)),"String encodeToString(byte[] pArray) {
        return StringUtils.<mask>(encode(pArray));
    }"
3571,Base64.java,encodeToString,String encodeToString(byte[] pArray),933,934,36403,36415,MethodCallMutator,newStringUtf8,strip,4,0.043724347,StringUtils.<mask>(encode(pArray)),"String encodeToString(byte[] pArray) {
        return StringUtils.<mask>(encode(pArray));
    }"
3572,Base64.java,encodeToString,String encodeToString(byte[] pArray),933,934,36417,36422,MethodCallMutator,encode,string,0,0.22253141,<mask>(pArray),"String encodeToString(byte[] pArray) {
        return StringUtils.newStringUtf8(<mask>(pArray));
    }"
3573,Base64.java,encodeToString,String encodeToString(byte[] pArray),933,934,36417,36422,MethodCallMutator,encode,append,1,0.08873156,<mask>(pArray),"String encodeToString(byte[] pArray) {
        return StringUtils.newStringUtf8(<mask>(pArray));
    }"
3574,Base64.java,encodeToString,String encodeToString(byte[] pArray),933,934,36417,36422,MethodCallMutator,encode,format,2,0.07343348,<mask>(pArray),"String encodeToString(byte[] pArray) {
        return StringUtils.newStringUtf8(<mask>(pArray));
    }"
3575,Base64.java,encodeToString,String encodeToString(byte[] pArray),933,934,36417,36422,MethodCallMutator,encode,bytes,3,0.04928849,<mask>(pArray),"String encodeToString(byte[] pArray) {
        return StringUtils.newStringUtf8(<mask>(pArray));
    }"
3576,Base64.java,encodeToString,String encodeToString(byte[] pArray),933,934,36417,36422,MethodCallMutator,encode,code,4,0.03977998,<mask>(pArray),"String encodeToString(byte[] pArray) {
        return StringUtils.newStringUtf8(<mask>(pArray));
    }"
3577,Base64.java,encodeToString,String encodeToString(byte[] pArray),933,934,36424,36429,IdentifierMutator-Variable,pArray,array,0,0.53259575,<mask>,"String encodeToString(byte[] pArray) {
        return StringUtils.newStringUtf8(encode(<mask>));
    }"
3578,Base64.java,encodeToString,String encodeToString(byte[] pArray),933,934,36424,36429,IdentifierMutator-Variable,pArray,Array,1,0.43346334,<mask>,"String encodeToString(byte[] pArray) {
        return StringUtils.newStringUtf8(encode(<mask>));
    }"
3579,Base64.java,encodeToString,String encodeToString(byte[] pArray),933,934,36424,36429,IdentifierMutator-Variable,pArray,arr,2,0.009440454,<mask>,"String encodeToString(byte[] pArray) {
        return StringUtils.newStringUtf8(encode(<mask>));
    }"
3580,Base64.java,encodeToString,String encodeToString(byte[] pArray),933,934,36424,36429,IdentifierMutator-Variable,pArray,p,3,0.0037139037,<mask>,"String encodeToString(byte[] pArray) {
        return StringUtils.newStringUtf8(encode(<mask>));
    }"
3581,Base64.java,encodeToString,String encodeToString(byte[] pArray),933,934,36424,36429,IdentifierMutator-Variable,pArray,[],4,0.0021142324,<mask>,"String encodeToString(byte[] pArray) {
        return StringUtils.newStringUtf8(encode(<mask>));
    }"
3582,Base64.java,encode,byte[] encode(byte[] pArray),944,945,36764,36768,MethodCallMutator,reset,close,0,0.18403377,<mask>(),"byte[] encode(byte[] pArray) {<mask>();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3583,Base64.java,encode,byte[] encode(byte[] pArray),944,945,36764,36768,MethodCallMutator,reset,flush,1,0.17889532,<mask>(),"byte[] encode(byte[] pArray) {<mask>();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3584,Base64.java,encode,byte[] encode(byte[] pArray),944,945,36764,36768,MethodCallMutator,reset,encode,3,0.07837346,<mask>(),"byte[] encode(byte[] pArray) {<mask>();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3585,Base64.java,encode,byte[] encode(byte[] pArray),944,945,36764,36768,MethodCallMutator,reset,init,4,0.04114957,<mask>(),"byte[] encode(byte[] pArray) {<mask>();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3586,Base64.java,encode,byte[] encode(byte[] pArray),944,946,36807,36810,BinaryOperatorMutator,||,|,2,0.0017302204,(pArray == null) <mask> (pArray.length == 0),"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null<mask>pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3587,Base64.java,encode,byte[] encode(byte[] pArray),944,946,36807,36810,BinaryOperatorMutator,||,/,3,0.0012025622,(pArray == null) <mask> (pArray.length == 0),"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null<mask>pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3588,Base64.java,encode,byte[] encode(byte[] pArray),944,946,36807,36810,BinaryOperatorMutator,||,.,4,7.580271E-4,(pArray == null) <mask> (pArray.length == 0),"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null<mask>pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3589,Base64.java,encode,byte[] encode(byte[] pArray),944,946,36799,36802,BinaryOperatorMutator,==,=,2,0.0022956578,pArray <mask> null,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray<mask>null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3590,Base64.java,encode,byte[] encode(byte[] pArray),944,946,36799,36802,BinaryOperatorMutator,==,===,3,7.174533E-4,pArray <mask> null,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray<mask>null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3591,Base64.java,encode,byte[] encode(byte[] pArray),944,946,36799,36802,BinaryOperatorMutator,==,!=,4,2.94983E-4,pArray <mask> null,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray<mask>null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3592,Base64.java,encode,byte[] encode(byte[] pArray),944,946,36793,36798,IdentifierMutator-Variable,pArray,array,0,0.71901965,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (<mask> == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3593,Base64.java,encode,byte[] encode(byte[] pArray),944,946,36793,36798,IdentifierMutator-Variable,pArray,Array,1,0.09658609,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (<mask> == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3594,Base64.java,encode,byte[] encode(byte[] pArray),944,946,36793,36798,IdentifierMutator-Variable,pArray,null,2,0.014638863,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (<mask> == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3595,Base64.java,encode,byte[] encode(byte[] pArray),944,946,36793,36798,IdentifierMutator-Variable,pArray,buffer,3,0.014314994,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (<mask> == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3596,Base64.java,encode,byte[] encode(byte[] pArray),944,946,36793,36798,IdentifierMutator-Variable,pArray,p,4,0.009570836,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (<mask> == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3597,Base64.java,encode,byte[] encode(byte[] pArray),944,946,36803,36806,IdentifierMutator-Literal,null,nil,1,4.71504E-4,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray ==<mask> || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3598,Base64.java,encode,byte[] encode(byte[] pArray),944,946,36803,36806,IdentifierMutator-Literal,null,NULL,2,3.6917403E-4,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray ==<mask> || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3599,Base64.java,encode,byte[] encode(byte[] pArray),944,946,36803,36806,IdentifierMutator-Literal,null,undefined,3,5.5898658E-5,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray ==<mask> || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3600,Base64.java,encode,byte[] encode(byte[] pArray),944,946,36803,36806,IdentifierMutator-Literal,null,this,4,4.4438122E-5,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray ==<mask> || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3601,Base64.java,encode,byte[] encode(byte[] pArray),944,946,36824,36827,BinaryOperatorMutator,==,>,2,0.026826035,pArray.length <mask> 0,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length<mask>0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3602,Base64.java,encode,byte[] encode(byte[] pArray),944,946,36824,36827,BinaryOperatorMutator,==,=,3,0.014689336,pArray.length <mask> 0,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length<mask>0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3603,Base64.java,encode,byte[] encode(byte[] pArray),944,946,36824,36827,BinaryOperatorMutator,==,<=,4,0.010090298,pArray.length <mask> 0,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length<mask>0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3604,Base64.java,encode,byte[] encode(byte[] pArray),944,946,36811,36823,IdentifierMutator-Variable,pArray.length,len,0,0.85593456,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null ||<mask> == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3605,Base64.java,encode,byte[] encode(byte[] pArray),944,946,36811,36823,IdentifierMutator-Variable,pArray.length,length,1,0.039462417,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null ||<mask> == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3606,Base64.java,encode,byte[] encode(byte[] pArray),944,946,36811,36823,IdentifierMutator-Variable,pArray.length,pos,2,0.0181243,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null ||<mask> == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3607,Base64.java,encode,byte[] encode(byte[] pArray),944,946,36811,36823,IdentifierMutator-Variable,pArray.length,size,3,0.010762559,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null ||<mask> == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3608,Base64.java,encode,byte[] encode(byte[] pArray),944,946,36811,36823,IdentifierMutator-Variable,pArray.length,n,4,0.00906403,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null ||<mask> == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3609,Base64.java,encode,byte[] encode(byte[] pArray),944,946,36811,36816,IdentifierMutator-Variable,pArray,array,0,0.75577193,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null ||<mask>.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3610,Base64.java,encode,byte[] encode(byte[] pArray),944,946,36811,36816,IdentifierMutator-Variable,pArray,Array,1,0.076330476,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null ||<mask>.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3611,Base64.java,encode,byte[] encode(byte[] pArray),944,946,36811,36816,IdentifierMutator-Variable,pArray,Array,2,0.05373317,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null ||<mask>.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3612,Base64.java,encode,byte[] encode(byte[] pArray),944,946,36811,36816,IdentifierMutator-Variable,pArray,p,3,0.052107297,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null ||<mask>.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3613,Base64.java,encode,byte[] encode(byte[] pArray),944,946,36811,36816,IdentifierMutator-Variable,pArray,arr,4,0.014707325,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null ||<mask>.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3614,Base64.java,encode,byte[] encode(byte[] pArray),944,946,36818,36823,FieldReferenceMutator,length,size,2,1.1174611E-4,pArray.<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.<mask> == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3615,Base64.java,encode,byte[] encode(byte[] pArray),944,946,36818,36823,FieldReferenceMutator,length,count,3,6.355502E-5,pArray.<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.<mask> == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3616,Base64.java,encode,byte[] encode(byte[] pArray),944,946,36818,36823,FieldReferenceMutator,length,len,4,5.9652735E-5,pArray.<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.<mask> == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3617,Base64.java,encode,byte[] encode(byte[] pArray),944,946,36828,36828,IdentifierMutator-Literal,0,1,1,0.0023754218,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length ==<mask>) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3618,Base64.java,encode,byte[] encode(byte[] pArray),944,946,36828,36828,IdentifierMutator-Literal,0,length,2,4.6956152E-4,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length ==<mask>) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3619,Base64.java,encode,byte[] encode(byte[] pArray),944,946,36828,36828,IdentifierMutator-Literal,0,len,3,4.4311158E-4,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length ==<mask>) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3620,Base64.java,encode,byte[] encode(byte[] pArray),944,946,36828,36828,IdentifierMutator-Literal,0,size,4,3.3578888E-4,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length ==<mask>) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3621,Base64.java,encode,byte[] encode(byte[] pArray),944,947,36852,36857,IdentifierMutator-Variable,pArray,null,0,0.8897896,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return<mask>;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3622,Base64.java,encode,byte[] encode(byte[] pArray),944,947,36852,36857,IdentifierMutator-Variable,pArray,"""""",1,0.034184277,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return<mask>;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3623,Base64.java,encode,byte[] encode(byte[] pArray),944,947,36852,36857,IdentifierMutator-Variable,pArray,[],2,0.008194483,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return<mask>;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3624,Base64.java,encode,byte[] encode(byte[] pArray),944,947,36852,36857,IdentifierMutator-Variable,pArray,false,3,0.007817769,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return<mask>;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3625,Base64.java,encode,byte[] encode(byte[] pArray),944,947,36852,36857,IdentifierMutator-Variable,pArray,"''",4,0.0072672525,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return<mask>;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3626,Base64.java,encode,byte[] encode(byte[] pArray),944,949,36889,36903,MethodCallMutator,getEncodeLength,encode,0,0.7486533,"<mask>(pArray, lineLength, lineSeparator)","byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len =<mask>(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3627,Base64.java,encode,byte[] encode(byte[] pArray),944,949,36889,36903,MethodCallMutator,getEncodeLength,length,1,0.039110266,"<mask>(pArray, lineLength, lineSeparator)","byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len =<mask>(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3628,Base64.java,encode,byte[] encode(byte[] pArray),944,949,36889,36903,MethodCallMutator,getEncodeLength,decode,2,0.026872428,"<mask>(pArray, lineLength, lineSeparator)","byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len =<mask>(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3629,Base64.java,encode,byte[] encode(byte[] pArray),944,949,36889,36903,MethodCallMutator,getEncodeLength,len,3,0.016869586,"<mask>(pArray, lineLength, lineSeparator)","byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len =<mask>(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3630,Base64.java,encode,byte[] encode(byte[] pArray),944,949,36889,36903,MethodCallMutator,getEncodeLength,write,4,0.014989316,"<mask>(pArray, lineLength, lineSeparator)","byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len =<mask>(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3631,Base64.java,encode,byte[] encode(byte[] pArray),944,949,36905,36910,IdentifierMutator-Variable,pArray,buffer,0,0.15763839,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(<mask>, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3632,Base64.java,encode,byte[] encode(byte[] pArray),944,949,36905,36910,IdentifierMutator-Variable,pArray,buf,1,0.03728291,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(<mask>, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3633,Base64.java,encode,byte[] encode(byte[] pArray),944,949,36905,36910,IdentifierMutator-Variable,pArray,string,2,0.031882618,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(<mask>, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3634,Base64.java,encode,byte[] encode(byte[] pArray),944,949,36905,36910,IdentifierMutator-Variable,pArray,output,3,0.030640168,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(<mask>, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3635,Base64.java,encode,byte[] encode(byte[] pArray),944,949,36905,36910,IdentifierMutator-Variable,pArray,input,4,0.028715476,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(<mask>, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3636,Base64.java,encode,byte[] encode(byte[] pArray),944,949,36913,36922,IdentifierMutator-Variable,lineLength,0,0,0.10290702,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray,<mask>, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3637,Base64.java,encode,byte[] encode(byte[] pArray),944,949,36913,36922,IdentifierMutator-Variable,lineLength,encoding,1,0.10258092,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray,<mask>, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3638,Base64.java,encode,byte[] encode(byte[] pArray),944,949,36913,36922,IdentifierMutator-Variable,lineLength,true,2,0.09282646,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray,<mask>, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3639,Base64.java,encode,byte[] encode(byte[] pArray),944,949,36913,36922,IdentifierMutator-Variable,lineLength,pos,3,0.048901323,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray,<mask>, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3640,Base64.java,encode,byte[] encode(byte[] pArray),944,949,36913,36922,IdentifierMutator-Variable,lineLength,false,4,0.0422479,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray,<mask>, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3641,Base64.java,encode,byte[] encode(byte[] pArray),944,949,36913,36922,FieldReferenceMutator,lineLength,0,0,0.10290702,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray,<mask>, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3642,Base64.java,encode,byte[] encode(byte[] pArray),944,949,36913,36922,FieldReferenceMutator,lineLength,encoding,1,0.10258092,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray,<mask>, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3643,Base64.java,encode,byte[] encode(byte[] pArray),944,949,36913,36922,FieldReferenceMutator,lineLength,true,2,0.09282646,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray,<mask>, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3644,Base64.java,encode,byte[] encode(byte[] pArray),944,949,36913,36922,FieldReferenceMutator,lineLength,pos,3,0.048901323,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray,<mask>, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3645,Base64.java,encode,byte[] encode(byte[] pArray),944,949,36913,36922,FieldReferenceMutator,lineLength,false,4,0.0422479,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray,<mask>, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3646,Base64.java,encode,byte[] encode(byte[] pArray),944,949,36925,36937,IdentifierMutator-Variable,lineSeparator,true,0,0.13959107,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength,<mask>);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3647,Base64.java,encode,byte[] encode(byte[] pArray),944,949,36925,36937,IdentifierMutator-Variable,lineSeparator,false,1,0.07535797,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength,<mask>);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3648,Base64.java,encode,byte[] encode(byte[] pArray),944,949,36925,36937,IdentifierMutator-Variable,lineSeparator,encoding,2,0.07353064,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength,<mask>);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3649,Base64.java,encode,byte[] encode(byte[] pArray),944,949,36925,36937,IdentifierMutator-Variable,lineSeparator,0,3,0.051197574,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength,<mask>);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3650,Base64.java,encode,byte[] encode(byte[] pArray),944,949,36925,36937,IdentifierMutator-Variable,lineSeparator,pos,4,0.0312302,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength,<mask>);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3651,Base64.java,encode,byte[] encode(byte[] pArray),944,949,36925,36937,FieldReferenceMutator,lineSeparator,true,0,0.13959107,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength,<mask>);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3652,Base64.java,encode,byte[] encode(byte[] pArray),944,949,36925,36937,FieldReferenceMutator,lineSeparator,false,1,0.07535797,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength,<mask>);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3653,Base64.java,encode,byte[] encode(byte[] pArray),944,949,36925,36937,FieldReferenceMutator,lineSeparator,encoding,2,0.07353064,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength,<mask>);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3654,Base64.java,encode,byte[] encode(byte[] pArray),944,949,36925,36937,FieldReferenceMutator,lineSeparator,0,3,0.051197574,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength,<mask>);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3655,Base64.java,encode,byte[] encode(byte[] pArray),944,949,36925,36937,FieldReferenceMutator,lineSeparator,pos,4,0.0312302,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength,<mask>);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3656,Base64.java,encode,byte[] encode(byte[] pArray),944,950,36971,36979,IdentifierMutator-Variable,((int)(len)),len,0,0.98003525,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[<mask>];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3657,Base64.java,encode,byte[] encode(byte[] pArray),944,950,36971,36979,IdentifierMutator-Variable,((int)(len)),Len,1,0.011936,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[<mask>];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3658,Base64.java,encode,byte[] encode(byte[] pArray),944,950,36971,36979,IdentifierMutator-Variable,((int)(len)),len,2,0.0036742173,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[<mask>];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3659,Base64.java,encode,byte[] encode(byte[] pArray),944,950,36971,36979,IdentifierMutator-Variable,((int)(len)),ln,3,7.3071057E-4,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[<mask>];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3660,Base64.java,encode,byte[] encode(byte[] pArray),944,950,36971,36979,IdentifierMutator-Variable,((int)(len)),0,4,3.0638906E-4,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[<mask>];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3661,Base64.java,encode,byte[] encode(byte[] pArray),944,951,36991,37006,MethodCallMutator,setInitialBuffer,encode,0,0.9292066,"<mask>(buf, 0, buf.length)","byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];<mask>(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3662,Base64.java,encode,byte[] encode(byte[] pArray),944,951,36991,37006,MethodCallMutator,setInitialBuffer,decode,1,0.025281323,"<mask>(buf, 0, buf.length)","byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];<mask>(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3663,Base64.java,encode,byte[] encode(byte[] pArray),944,951,36991,37006,MethodCallMutator,setInitialBuffer,write,2,0.02057634,"<mask>(buf, 0, buf.length)","byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];<mask>(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3664,Base64.java,encode,byte[] encode(byte[] pArray),944,951,36991,37006,MethodCallMutator,setInitialBuffer,append,3,0.003173056,"<mask>(buf, 0, buf.length)","byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];<mask>(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3665,Base64.java,encode,byte[] encode(byte[] pArray),944,951,36991,37006,MethodCallMutator,setInitialBuffer,copy,4,0.0027404733,"<mask>(buf, 0, buf.length)","byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];<mask>(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3666,Base64.java,encode,byte[] encode(byte[] pArray),944,951,37008,37010,IdentifierMutator-Variable,buf,buffer,1,0.056994054,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(<mask>, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3667,Base64.java,encode,byte[] encode(byte[] pArray),944,951,37008,37010,IdentifierMutator-Variable,buf,buff,2,0.0026912163,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(<mask>, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3668,Base64.java,encode,byte[] encode(byte[] pArray),944,951,37008,37010,IdentifierMutator-Variable,buf,uf,4,7.963312E-4,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(<mask>, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3669,Base64.java,encode,byte[] encode(byte[] pArray),944,951,37013,37013,IdentifierMutator-Literal,0,len,1,0.020608135,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf,<mask>, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3670,Base64.java,encode,byte[] encode(byte[] pArray),944,951,37013,37013,IdentifierMutator-Literal,0,pos,2,0.004751892,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf,<mask>, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3671,Base64.java,encode,byte[] encode(byte[] pArray),944,951,37013,37013,IdentifierMutator-Literal,0,1,3,0.0015924738,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf,<mask>, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3672,Base64.java,encode,byte[] encode(byte[] pArray),944,951,37013,37013,IdentifierMutator-Literal,0,start,4,8.2506455E-4,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf,<mask>, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3673,Base64.java,encode,byte[] encode(byte[] pArray),944,951,37016,37025,IdentifierMutator-Variable,buf.length,len,0,0.938327,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0,<mask>);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3674,Base64.java,encode,byte[] encode(byte[] pArray),944,951,37016,37025,IdentifierMutator-Variable,buf.length,0,1,0.04104667,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0,<mask>);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3675,Base64.java,encode,byte[] encode(byte[] pArray),944,951,37016,37025,IdentifierMutator-Variable,buf.length,pos,2,0.0035253768,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0,<mask>);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3676,Base64.java,encode,byte[] encode(byte[] pArray),944,951,37016,37025,IdentifierMutator-Variable,buf.length,1,3,0.0015788804,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0,<mask>);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3677,Base64.java,encode,byte[] encode(byte[] pArray),944,951,37016,37025,IdentifierMutator-Variable,buf.length,buf,4,0.0010132095,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0,<mask>);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3678,Base64.java,encode,byte[] encode(byte[] pArray),944,951,37016,37018,IdentifierMutator-Variable,buf,buffer,1,0.027880393,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0,<mask>.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3679,Base64.java,encode,byte[] encode(byte[] pArray),944,951,37016,37018,IdentifierMutator-Variable,buf,array,3,0.0015741392,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0,<mask>.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3680,Base64.java,encode,byte[] encode(byte[] pArray),944,951,37016,37018,IdentifierMutator-Variable,buf,Buffer,4,6.6383515E-4,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0,<mask>.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3681,Base64.java,encode,byte[] encode(byte[] pArray),944,951,37020,37025,FieldReferenceMutator,length,position,1,1.8526975E-4,buf.<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.<mask>);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3682,Base64.java,encode,byte[] encode(byte[] pArray),944,951,37020,37025,FieldReferenceMutator,length,capacity,2,1.6082704E-4,buf.<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.<mask>);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3683,Base64.java,encode,byte[] encode(byte[] pArray),944,951,37020,37025,FieldReferenceMutator,length,size,3,1.0297545E-4,buf.<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.<mask>);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3684,Base64.java,encode,byte[] encode(byte[] pArray),944,952,37037,37042,MethodCallMutator,encode,decode,1,0.065894336,"<mask>(pArray, 0, pArray.length)","byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);<mask>(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3685,Base64.java,encode,byte[] encode(byte[] pArray),944,952,37037,37042,MethodCallMutator,encode,write,2,0.026327275,"<mask>(pArray, 0, pArray.length)","byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);<mask>(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3686,Base64.java,encode,byte[] encode(byte[] pArray),944,952,37037,37042,MethodCallMutator,encode,append,3,0.0046206755,"<mask>(pArray, 0, pArray.length)","byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);<mask>(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3687,Base64.java,encode,byte[] encode(byte[] pArray),944,952,37037,37042,MethodCallMutator,encode,copy,4,0.0033746345,"<mask>(pArray, 0, pArray.length)","byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);<mask>(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3688,Base64.java,encode,byte[] encode(byte[] pArray),944,952,37044,37049,IdentifierMutator-Variable,pArray,buf,0,0.9947378,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(<mask>, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3689,Base64.java,encode,byte[] encode(byte[] pArray),944,952,37044,37049,IdentifierMutator-Variable,pArray,buff,1,0.0021832928,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(<mask>, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3690,Base64.java,encode,byte[] encode(byte[] pArray),944,952,37044,37049,IdentifierMutator-Variable,pArray,buffer,2,0.0018828341,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(<mask>, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3691,Base64.java,encode,byte[] encode(byte[] pArray),944,952,37044,37049,IdentifierMutator-Variable,pArray,uf,3,3.7178094E-4,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(<mask>, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3692,Base64.java,encode,byte[] encode(byte[] pArray),944,952,37044,37049,IdentifierMutator-Variable,pArray,buf,4,2.1604789E-4,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(<mask>, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3693,Base64.java,encode,byte[] encode(byte[] pArray),944,952,37052,37052,IdentifierMutator-Literal,0,1,1,0.0071544494,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray,<mask>, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3694,Base64.java,encode,byte[] encode(byte[] pArray),944,952,37052,37052,IdentifierMutator-Literal,0,buf,2,0.0047515724,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray,<mask>, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3695,Base64.java,encode,byte[] encode(byte[] pArray),944,952,37052,37052,IdentifierMutator-Literal,0,pos,3,0.0023630587,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray,<mask>, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3696,Base64.java,encode,byte[] encode(byte[] pArray),944,952,37052,37052,IdentifierMutator-Literal,0,2,4,0.0011671345,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray,<mask>, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3697,Base64.java,encode,byte[] encode(byte[] pArray),944,952,37055,37067,IdentifierMutator-Variable,pArray.length,buf,0,0.41556606,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0,<mask>);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3698,Base64.java,encode,byte[] encode(byte[] pArray),944,952,37055,37067,IdentifierMutator-Variable,pArray.length,len,1,0.27318123,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0,<mask>);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3699,Base64.java,encode,byte[] encode(byte[] pArray),944,952,37055,37067,IdentifierMutator-Variable,pArray.length,0,2,0.17921081,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0,<mask>);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3700,Base64.java,encode,byte[] encode(byte[] pArray),944,952,37055,37067,IdentifierMutator-Variable,pArray.length,1,3,0.04875989,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0,<mask>);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3701,Base64.java,encode,byte[] encode(byte[] pArray),944,952,37055,37067,IdentifierMutator-Variable,pArray.length,pos,4,0.01580383,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0,<mask>);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3702,Base64.java,encode,byte[] encode(byte[] pArray),944,952,37055,37060,IdentifierMutator-Variable,pArray,buf,0,0.99164456,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0,<mask>.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3703,Base64.java,encode,byte[] encode(byte[] pArray),944,952,37055,37060,IdentifierMutator-Variable,pArray,buffer,1,0.0043817568,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0,<mask>.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3704,Base64.java,encode,byte[] encode(byte[] pArray),944,952,37055,37060,IdentifierMutator-Variable,pArray,buf,2,0.0017551121,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0,<mask>.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3705,Base64.java,encode,byte[] encode(byte[] pArray),944,952,37055,37060,IdentifierMutator-Variable,pArray,buff,3,3.2631852E-4,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0,<mask>.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3706,Base64.java,encode,byte[] encode(byte[] pArray),944,952,37055,37060,IdentifierMutator-Variable,pArray,doc,4,7.1575E-5,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0,<mask>.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3707,Base64.java,encode,byte[] encode(byte[] pArray),944,952,37062,37067,FieldReferenceMutator,length,position,1,4.843831E-4,pArray.<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.<mask>);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3708,Base64.java,encode,byte[] encode(byte[] pArray),944,952,37062,37067,FieldReferenceMutator,length,size,2,1.9318651E-4,pArray.<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.<mask>);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3709,Base64.java,encode,byte[] encode(byte[] pArray),944,952,37062,37067,FieldReferenceMutator,length,count,3,1.747663E-4,pArray.<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.<mask>);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3710,Base64.java,encode,byte[] encode(byte[] pArray),944,953,37079,37084,MethodCallMutator,encode,decode,1,0.21052146,"<mask>(pArray, 0, -1)","byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);<mask>(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3711,Base64.java,encode,byte[] encode(byte[] pArray),944,953,37079,37084,MethodCallMutator,encode,write,2,0.0580373,"<mask>(pArray, 0, -1)","byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);<mask>(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3712,Base64.java,encode,byte[] encode(byte[] pArray),944,953,37079,37084,MethodCallMutator,encode,end,3,0.026063936,"<mask>(pArray, 0, -1)","byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);<mask>(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3713,Base64.java,encode,byte[] encode(byte[] pArray),944,953,37079,37084,MethodCallMutator,encode,reset,4,0.021791797,"<mask>(pArray, 0, -1)","byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);<mask>(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3714,Base64.java,encode,byte[] encode(byte[] pArray),944,953,37086,37091,IdentifierMutator-Variable,pArray,buf,0,0.96055716,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(<mask>, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3715,Base64.java,encode,byte[] encode(byte[] pArray),944,953,37086,37091,IdentifierMutator-Variable,pArray,buffer,1,0.0221765,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(<mask>, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3716,Base64.java,encode,byte[] encode(byte[] pArray),944,953,37086,37091,IdentifierMutator-Variable,pArray,buff,2,0.003422154,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(<mask>, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3717,Base64.java,encode,byte[] encode(byte[] pArray),944,953,37086,37091,IdentifierMutator-Variable,pArray,buf,3,9.547964E-4,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(<mask>, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3718,Base64.java,encode,byte[] encode(byte[] pArray),944,953,37086,37091,IdentifierMutator-Variable,pArray,uf,4,6.9595134E-4,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(<mask>, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3719,Base64.java,encode,byte[] encode(byte[] pArray),944,953,37094,37094,IdentifierMutator-Literal,0,buf,1,0.18860859,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray,<mask>, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3720,Base64.java,encode,byte[] encode(byte[] pArray),944,953,37094,37094,IdentifierMutator-Literal,0,len,2,0.020645466,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray,<mask>, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3721,Base64.java,encode,byte[] encode(byte[] pArray),944,953,37094,37094,IdentifierMutator-Literal,0,1,3,0.018285898,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray,<mask>, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3722,Base64.java,encode,byte[] encode(byte[] pArray),944,953,37094,37094,IdentifierMutator-Literal,0,pos,4,0.012795732,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray,<mask>, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3723,Base64.java,encode,byte[] encode(byte[] pArray),944,953,37097,37097,UnaryOperatorMutator,-,pos,1,0.061359964,<mask>1,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0,<mask>1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3724,Base64.java,encode,byte[] encode(byte[] pArray),944,953,37097,37097,UnaryOperatorMutator,-,+,2,0.039148774,<mask>1,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0,<mask>1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3725,Base64.java,encode,byte[] encode(byte[] pArray),944,953,37097,37097,UnaryOperatorMutator,-,len,3,0.036212776,<mask>1,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0,<mask>1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3726,Base64.java,encode,byte[] encode(byte[] pArray),944,953,37097,37097,UnaryOperatorMutator,-,buf,4,0.01959352,<mask>1,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0,<mask>1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3727,Base64.java,encode,byte[] encode(byte[] pArray),944,953,37098,37098,IdentifierMutator-Literal,1,len,2,0.15058371,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -<mask>); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3728,Base64.java,encode,byte[] encode(byte[] pArray),944,953,37098,37098,IdentifierMutator-Literal,1,len,3,0.012751501,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -<mask>); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3729,Base64.java,encode,byte[] encode(byte[] pArray),944,953,37098,37098,IdentifierMutator-Literal,1,2,4,0.009430359,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -<mask>); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3730,Base64.java,encode,byte[] encode(byte[] pArray),944,955,37217,37220,BinaryOperatorMutator,!=,==,1,0.21390529,buffer <mask> buf,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer<mask>buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3731,Base64.java,encode,byte[] encode(byte[] pArray),944,955,37217,37220,BinaryOperatorMutator,!=,==,2,0.019278448,buffer <mask> buf,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer<mask>buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3732,Base64.java,encode,byte[] encode(byte[] pArray),944,955,37217,37220,BinaryOperatorMutator,!=,>,3,0.00997514,buffer <mask> buf,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer<mask>buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3733,Base64.java,encode,byte[] encode(byte[] pArray),944,955,37217,37220,BinaryOperatorMutator,!=,<,4,0.009480504,buffer <mask> buf,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer<mask>buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3734,Base64.java,encode,byte[] encode(byte[] pArray),944,955,37211,37216,IdentifierMutator-Variable,buffer,null,0,0.5121809,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (<mask> != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3735,Base64.java,encode,byte[] encode(byte[] pArray),944,955,37211,37216,IdentifierMutator-Variable,buffer,buf,2,0.03223906,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (<mask> != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3736,Base64.java,encode,byte[] encode(byte[] pArray),944,955,37211,37216,IdentifierMutator-Variable,buffer,result,3,0.023289278,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (<mask> != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3737,Base64.java,encode,byte[] encode(byte[] pArray),944,955,37211,37216,IdentifierMutator-Variable,buffer,output,4,0.021177037,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (<mask> != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3738,Base64.java,encode,byte[] encode(byte[] pArray),944,955,37211,37216,FieldReferenceMutator,buffer,null,0,0.5121809,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (<mask> != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3739,Base64.java,encode,byte[] encode(byte[] pArray),944,955,37211,37216,FieldReferenceMutator,buffer,buf,2,0.03223906,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (<mask> != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3740,Base64.java,encode,byte[] encode(byte[] pArray),944,955,37211,37216,FieldReferenceMutator,buffer,result,3,0.023289278,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (<mask> != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3741,Base64.java,encode,byte[] encode(byte[] pArray),944,955,37211,37216,FieldReferenceMutator,buffer,output,4,0.021177037,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (<mask> != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3742,Base64.java,encode,byte[] encode(byte[] pArray),944,955,37221,37223,IdentifierMutator-Variable,buf,null,0,0.9957217,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer !=<mask>) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3743,Base64.java,encode,byte[] encode(byte[] pArray),944,955,37221,37223,IdentifierMutator-Variable,buf,nil,1,0.001192651,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer !=<mask>) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3744,Base64.java,encode,byte[] encode(byte[] pArray),944,955,37221,37223,IdentifierMutator-Variable,buf,undefined,2,5.7657657E-4,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer !=<mask>) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3745,Base64.java,encode,byte[] encode(byte[] pArray),944,955,37221,37223,IdentifierMutator-Variable,buf,NULL,3,4.950443E-4,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer !=<mask>) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3746,Base64.java,encode,byte[] encode(byte[] pArray),944,955,37221,37223,IdentifierMutator-Variable,buf,0,4,4.4660014E-4,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer !=<mask>) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3747,Base64.java,encode,byte[] encode(byte[] pArray),944,956,37240,37250,MethodCallMutator,readResults,encode,0,0.59357977,"<mask>(buf, 0, buf.length)","byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {<mask>(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3748,Base64.java,encode,byte[] encode(byte[] pArray),944,956,37240,37250,MethodCallMutator,readResults,write,1,0.1326764,"<mask>(buf, 0, buf.length)","byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {<mask>(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3749,Base64.java,encode,byte[] encode(byte[] pArray),944,956,37240,37250,MethodCallMutator,readResults,resize,2,0.034464166,"<mask>(buf, 0, buf.length)","byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {<mask>(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3750,Base64.java,encode,byte[] encode(byte[] pArray),944,956,37240,37250,MethodCallMutator,readResults,update,3,0.03120528,"<mask>(buf, 0, buf.length)","byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {<mask>(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3751,Base64.java,encode,byte[] encode(byte[] pArray),944,956,37240,37250,MethodCallMutator,readResults,append,4,0.023523957,"<mask>(buf, 0, buf.length)","byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {<mask>(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3752,Base64.java,encode,byte[] encode(byte[] pArray),944,956,37252,37254,IdentifierMutator-Variable,buf,buffer,0,0.87012833,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(<mask>, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3753,Base64.java,encode,byte[] encode(byte[] pArray),944,956,37252,37254,IdentifierMutator-Variable,buf,buff,2,0.008435173,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(<mask>, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3754,Base64.java,encode,byte[] encode(byte[] pArray),944,956,37252,37254,IdentifierMutator-Variable,buf,Buffer,3,0.0023671323,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(<mask>, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3755,Base64.java,encode,byte[] encode(byte[] pArray),944,956,37252,37254,IdentifierMutator-Variable,buf,result,4,0.0021841053,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(<mask>, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3756,Base64.java,encode,byte[] encode(byte[] pArray),944,956,37257,37257,IdentifierMutator-Literal,0,pos,1,0.09735707,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf,<mask>, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3757,Base64.java,encode,byte[] encode(byte[] pArray),944,956,37257,37257,IdentifierMutator-Literal,0,offset,2,0.004747197,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf,<mask>, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3758,Base64.java,encode,byte[] encode(byte[] pArray),944,956,37257,37257,IdentifierMutator-Literal,0,buf,3,0.0029934542,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf,<mask>, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3759,Base64.java,encode,byte[] encode(byte[] pArray),944,956,37257,37257,IdentifierMutator-Literal,0,false,4,0.002116439,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf,<mask>, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3760,Base64.java,encode,byte[] encode(byte[] pArray),944,956,37260,37269,IdentifierMutator-Variable,buf.length,pos,0,0.64038384,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0,<mask>);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3761,Base64.java,encode,byte[] encode(byte[] pArray),944,956,37260,37269,IdentifierMutator-Variable,buf.length,len,1,0.18239662,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0,<mask>);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3762,Base64.java,encode,byte[] encode(byte[] pArray),944,956,37260,37269,IdentifierMutator-Variable,buf.length,0,2,0.03290623,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0,<mask>);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3763,Base64.java,encode,byte[] encode(byte[] pArray),944,956,37260,37269,IdentifierMutator-Variable,buf.length,true,3,0.016878948,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0,<mask>);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3764,Base64.java,encode,byte[] encode(byte[] pArray),944,956,37260,37269,IdentifierMutator-Variable,buf.length,false,4,0.008555808,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0,<mask>);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3765,Base64.java,encode,byte[] encode(byte[] pArray),944,956,37260,37262,IdentifierMutator-Variable,buf,buffer,1,0.055511158,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0,<mask>.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3766,Base64.java,encode,byte[] encode(byte[] pArray),944,956,37260,37262,IdentifierMutator-Variable,buf,buff,3,0.0010387725,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0,<mask>.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3767,Base64.java,encode,byte[] encode(byte[] pArray),944,956,37260,37262,IdentifierMutator-Variable,buf,result,4,9.929256E-4,<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0,<mask>.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3768,Base64.java,encode,byte[] encode(byte[] pArray),944,956,37264,37269,FieldReferenceMutator,length,position,1,1.218735E-4,buf.<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.<mask>);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3769,Base64.java,encode,byte[] encode(byte[] pArray),944,956,37264,37269,FieldReferenceMutator,length,limit,2,6.5920234E-5,buf.<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.<mask>);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3770,Base64.java,encode,byte[] encode(byte[] pArray),944,956,37264,37269,FieldReferenceMutator,length,size,3,4.357593E-5,buf.<mask>,"byte[] encode(byte[] pArray) {
        reset();        
        if (pArray == null || pArray.length == 0) {
            return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.<mask>);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3771,Base64.java,encode,byte[] encode(byte[] pArray),944,960,37425,37428,BinaryOperatorMutator,&&,||,2,0.04039839,isUrlSafe() <mask> (pos < buf.length),"      return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe()<mask>pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3772,Base64.java,encode,byte[] encode(byte[] pArray),944,960,37425,37428,BinaryOperatorMutator,&&,&,3,0.0094228685,isUrlSafe() <mask> (pos < buf.length),"      return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe()<mask>pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3773,Base64.java,encode,byte[] encode(byte[] pArray),944,960,37425,37428,BinaryOperatorMutator,&&,|,4,0.005010417,isUrlSafe() <mask> (pos < buf.length),"      return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe()<mask>pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3774,Base64.java,encode,byte[] encode(byte[] pArray),944,960,37414,37422,MethodCallMutator,isUrlSafe,valid,0,0.08341828,<mask>(),"          return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (<mask>() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3775,Base64.java,encode,byte[] encode(byte[] pArray),944,960,37414,37422,MethodCallMutator,isUrlSafe,fill,1,0.06756462,<mask>(),"          return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (<mask>() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3776,Base64.java,encode,byte[] encode(byte[] pArray),944,960,37414,37422,MethodCallMutator,isUrlSafe,complete,2,0.056307018,<mask>(),"          return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (<mask>() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3777,Base64.java,encode,byte[] encode(byte[] pArray),944,960,37414,37422,MethodCallMutator,isUrlSafe,pad,3,0.041950103,<mask>(),"          return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (<mask>() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3778,Base64.java,encode,byte[] encode(byte[] pArray),944,960,37414,37422,MethodCallMutator,isUrlSafe,found,4,0.037518505,<mask>(),"          return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (<mask>() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3779,Base64.java,encode,byte[] encode(byte[] pArray),944,960,37432,37434,BinaryOperatorMutator,<,>,2,0.08232825,pos <mask> buf.length,"    return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos<mask>buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3780,Base64.java,encode,byte[] encode(byte[] pArray),944,960,37432,37434,BinaryOperatorMutator,<,==,3,0.069434926,pos <mask> buf.length,"    return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos<mask>buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3781,Base64.java,encode,byte[] encode(byte[] pArray),944,960,37432,37434,BinaryOperatorMutator,<,>=,4,0.034890406,pos <mask> buf.length,"    return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos<mask>buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3782,Base64.java,encode,byte[] encode(byte[] pArray),944,960,37429,37431,IdentifierMutator-Variable,pos,position,1,0.0011137011,<mask>,"     return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() &&<mask> < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3783,Base64.java,encode,byte[] encode(byte[] pArray),944,960,37429,37431,IdentifierMutator-Variable,pos,length,2,6.8538514E-4,<mask>,"     return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() &&<mask> < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3784,Base64.java,encode,byte[] encode(byte[] pArray),944,960,37429,37431,IdentifierMutator-Variable,pos,len,3,6.3545624E-4,<mask>,"     return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() &&<mask> < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3785,Base64.java,encode,byte[] encode(byte[] pArray),944,960,37429,37431,IdentifierMutator-Variable,pos,0,4,6.144849E-4,<mask>,"     return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() &&<mask> < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3786,Base64.java,encode,byte[] encode(byte[] pArray),944,960,37429,37431,FieldReferenceMutator,pos,position,1,0.0011137011,<mask>,"     return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() &&<mask> < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3787,Base64.java,encode,byte[] encode(byte[] pArray),944,960,37429,37431,FieldReferenceMutator,pos,length,2,6.8538514E-4,<mask>,"     return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() &&<mask> < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3788,Base64.java,encode,byte[] encode(byte[] pArray),944,960,37429,37431,FieldReferenceMutator,pos,len,3,6.3545624E-4,<mask>,"     return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() &&<mask> < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3789,Base64.java,encode,byte[] encode(byte[] pArray),944,960,37429,37431,FieldReferenceMutator,pos,0,4,6.144849E-4,<mask>,"     return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() &&<mask> < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3790,Base64.java,encode,byte[] encode(byte[] pArray),944,960,37435,37444,IdentifierMutator-Variable,buf.length,pos,0,0.39003676,<mask>,"   return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos <<mask>) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3791,Base64.java,encode,byte[] encode(byte[] pArray),944,960,37435,37444,IdentifierMutator-Variable,buf.length,limit,1,0.17485829,<mask>,"   return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos <<mask>) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3792,Base64.java,encode,byte[] encode(byte[] pArray),944,960,37435,37444,IdentifierMutator-Variable,buf.length,len,2,0.07201824,<mask>,"   return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos <<mask>) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3793,Base64.java,encode,byte[] encode(byte[] pArray),944,960,37435,37444,IdentifierMutator-Variable,buf.length,0,3,0.07188184,<mask>,"   return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos <<mask>) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3794,Base64.java,encode,byte[] encode(byte[] pArray),944,960,37435,37444,IdentifierMutator-Variable,buf.length,length,4,0.059752215,<mask>,"   return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos <<mask>) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3795,Base64.java,encode,byte[] encode(byte[] pArray),944,960,37435,37437,IdentifierMutator-Variable,buf,buffer,1,0.019129004,<mask>,"   return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos <<mask>.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3796,Base64.java,encode,byte[] encode(byte[] pArray),944,960,37435,37437,IdentifierMutator-Variable,buf,buff,2,5.358572E-4,<mask>,"   return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos <<mask>.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3797,Base64.java,encode,byte[] encode(byte[] pArray),944,960,37435,37437,IdentifierMutator-Variable,buf,bytes,4,3.5769597E-4,<mask>,"   return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos <<mask>.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3798,Base64.java,encode,byte[] encode(byte[] pArray),944,960,37439,37444,FieldReferenceMutator,length,position,1,1.2339954E-4,buf.<mask>," return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.<mask>) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3799,Base64.java,encode,byte[] encode(byte[] pArray),944,960,37439,37444,FieldReferenceMutator,length,size,3,5.3257227E-5,buf.<mask>," return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.<mask>) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3800,Base64.java,encode,byte[] encode(byte[] pArray),944,960,37439,37444,FieldReferenceMutator,length,len,4,1.8789742E-5,buf.<mask>," return pArray;
        }
        long len = getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.<mask>) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3801,Base64.java,encode,byte[] encode(byte[] pArray),944,961,37490,37492,IdentifierMutator-Variable,pos,len,1,0.0636243,<mask>," getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[<mask>];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3802,Base64.java,encode,byte[] encode(byte[] pArray),944,961,37490,37492,IdentifierMutator-Variable,pos,Pos,3,0.0085509075,<mask>," getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[<mask>];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3803,Base64.java,encode,byte[] encode(byte[] pArray),944,961,37490,37492,IdentifierMutator-Variable,pos,36,4,0.00836993,<mask>," getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[<mask>];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3804,Base64.java,encode,byte[] encode(byte[] pArray),944,961,37490,37492,FieldReferenceMutator,pos,len,1,0.0636243,<mask>," getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[<mask>];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3805,Base64.java,encode,byte[] encode(byte[] pArray),944,961,37490,37492,FieldReferenceMutator,pos,Pos,3,0.0085509075,<mask>," getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[<mask>];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3806,Base64.java,encode,byte[] encode(byte[] pArray),944,961,37490,37492,FieldReferenceMutator,pos,36,4,0.00836993,<mask>," getEncodeLength(pArray, lineLength, lineSeparator);
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[<mask>];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3807,Base64.java,encode,byte[] encode(byte[] pArray),944,962,37515,37523,MethodCallMutator,arraycopy,copy,0,0.9945293,"System.<mask>(buf, 0, smallerBuf, 0, pos)","
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.<mask>(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3808,Base64.java,encode,byte[] encode(byte[] pArray),944,962,37515,37523,MethodCallMutator,arraycopy,printf,1,0.0010614535,"System.<mask>(buf, 0, smallerBuf, 0, pos)","
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.<mask>(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3809,Base64.java,encode,byte[] encode(byte[] pArray),944,962,37515,37523,MethodCallMutator,arraycopy,bytes,2,7.698833E-4,"System.<mask>(buf, 0, smallerBuf, 0, pos)","
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.<mask>(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3810,Base64.java,encode,byte[] encode(byte[] pArray),944,962,37515,37523,MethodCallMutator,arraycopy,fill,3,4.7762858E-4,"System.<mask>(buf, 0, smallerBuf, 0, pos)","
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.<mask>(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3811,Base64.java,encode,byte[] encode(byte[] pArray),944,962,37515,37523,MethodCallMutator,arraycopy,select,4,4.285479E-4,"System.<mask>(buf, 0, smallerBuf, 0, pos)","
        byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.<mask>(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3812,Base64.java,encode,byte[] encode(byte[] pArray),944,962,37525,37527,IdentifierMutator-Variable,buf,buffer,1,0.03447243,<mask>,"      byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(<mask>, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3813,Base64.java,encode,byte[] encode(byte[] pArray),944,962,37525,37527,IdentifierMutator-Variable,buf,buff,2,0.005214485,<mask>,"      byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(<mask>, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3814,Base64.java,encode,byte[] encode(byte[] pArray),944,962,37525,37527,IdentifierMutator-Variable,buf,uf,4,6.4921775E-4,<mask>,"      byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(<mask>, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3815,Base64.java,encode,byte[] encode(byte[] pArray),944,962,37530,37530,IdentifierMutator-Literal,0,pos,1,0.0475297,<mask>,"    byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf,<mask>, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3816,Base64.java,encode,byte[] encode(byte[] pArray),944,962,37530,37530,IdentifierMutator-Literal,0,1,2,0.0016725685,<mask>,"    byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf,<mask>, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3817,Base64.java,encode,byte[] encode(byte[] pArray),944,962,37530,37530,IdentifierMutator-Literal,0,offset,3,8.7842956E-4,<mask>,"    byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf,<mask>, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3818,Base64.java,encode,byte[] encode(byte[] pArray),944,962,37530,37530,IdentifierMutator-Literal,0,position,4,6.6203217E-4,<mask>,"    byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf,<mask>, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3819,Base64.java,encode,byte[] encode(byte[] pArray),944,962,37533,37542,IdentifierMutator-Variable,smallerBuf,buf,0,0.9738713,<mask>,"  byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0,<mask>, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3820,Base64.java,encode,byte[] encode(byte[] pArray),944,962,37533,37542,IdentifierMutator-Variable,smallerBuf,buffer,1,0.015700055,<mask>,"  byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0,<mask>, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3821,Base64.java,encode,byte[] encode(byte[] pArray),944,962,37533,37542,IdentifierMutator-Variable,smallerBuf,tmp,2,0.0018027059,<mask>,"  byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0,<mask>, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3822,Base64.java,encode,byte[] encode(byte[] pArray),944,962,37533,37542,IdentifierMutator-Variable,smallerBuf,buf,3,7.042586E-4,<mask>,"  byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0,<mask>, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3823,Base64.java,encode,byte[] encode(byte[] pArray),944,962,37533,37542,IdentifierMutator-Variable,smallerBuf,buff,4,5.279646E-4,<mask>,"  byte[] buf = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0,<mask>, 0, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3824,Base64.java,encode,byte[] encode(byte[] pArray),944,962,37545,37545,IdentifierMutator-Literal,0,pos,1,0.014930364,<mask>," = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf,<mask>, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3825,Base64.java,encode,byte[] encode(byte[] pArray),944,962,37545,37545,IdentifierMutator-Literal,0,1,2,0.002016201,<mask>," = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf,<mask>, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3826,Base64.java,encode,byte[] encode(byte[] pArray),944,962,37545,37545,IdentifierMutator-Literal,0,offset,3,0.0017210206,<mask>," = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf,<mask>, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3827,Base64.java,encode,byte[] encode(byte[] pArray),944,962,37545,37545,IdentifierMutator-Literal,0,start,4,0.0011133956,<mask>," = new byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf,<mask>, pos);
            buf = smallerBuf;
        }
        return buf;        
    }"
3828,Base64.java,encode,byte[] encode(byte[] pArray),944,962,37548,37550,IdentifierMutator-Variable,pos,len,2,0.0027678926,<mask>," byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0,<mask>);
            buf = smallerBuf;
        }
        return buf;        
    }"
3829,Base64.java,encode,byte[] encode(byte[] pArray),944,962,37548,37550,IdentifierMutator-Variable,pos,position,3,6.8004883E-4,<mask>," byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0,<mask>);
            buf = smallerBuf;
        }
        return buf;        
    }"
3830,Base64.java,encode,byte[] encode(byte[] pArray),944,962,37548,37550,IdentifierMutator-Variable,pos,buf,4,4.821293E-4,<mask>," byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0,<mask>);
            buf = smallerBuf;
        }
        return buf;        
    }"
3831,Base64.java,encode,byte[] encode(byte[] pArray),944,962,37548,37550,FieldReferenceMutator,pos,len,2,0.0027678926,<mask>," byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0,<mask>);
            buf = smallerBuf;
        }
        return buf;        
    }"
3832,Base64.java,encode,byte[] encode(byte[] pArray),944,962,37548,37550,FieldReferenceMutator,pos,position,3,6.8004883E-4,<mask>," byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0,<mask>);
            buf = smallerBuf;
        }
        return buf;        
    }"
3833,Base64.java,encode,byte[] encode(byte[] pArray),944,962,37548,37550,FieldReferenceMutator,pos,buf,4,4.821293E-4,<mask>," byte[(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0,<mask>);
            buf = smallerBuf;
        }
        return buf;        
    }"
3834,Base64.java,encode,byte[] encode(byte[] pArray),944,963,37569,37569,AssignmentMutator,buf=smallerBuf,^,0,0.22511418,buf <mask>= smallerBuf," setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf<mask>= smallerBuf;
        }
        return buf;        
    }"
3835,Base64.java,encode,byte[] encode(byte[] pArray),944,963,37569,37569,AssignmentMutator,buf=smallerBuf,|,1,0.21868436,buf <mask>= smallerBuf," setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf<mask>= smallerBuf;
        }
        return buf;        
    }"
3836,Base64.java,encode,byte[] encode(byte[] pArray),944,963,37569,37569,AssignmentMutator,buf=smallerBuf,[],2,0.20682831,buf <mask>= smallerBuf," setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf<mask>= smallerBuf;
        }
        return buf;        
    }"
3837,Base64.java,encode,byte[] encode(byte[] pArray),944,963,37569,37569,AssignmentMutator,buf=smallerBuf,.,3,0.10443374,buf <mask>= smallerBuf," setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf<mask>= smallerBuf;
        }
        return buf;        
    }"
3838,Base64.java,encode,byte[] encode(byte[] pArray),944,963,37569,37569,AssignmentMutator,buf=smallerBuf,*,4,0.066237435,buf <mask>= smallerBuf," setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf<mask>= smallerBuf;
        }
        return buf;        
    }"
3839,Base64.java,encode,byte[] encode(byte[] pArray),944,963,37566,37568,IdentifierMutator-Variable,buf,buffer,1,0.019510556,<mask>,"(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);<mask> = smallerBuf;
        }
        return buf;        
    }"
3840,Base64.java,encode,byte[] encode(byte[] pArray),944,963,37566,37568,IdentifierMutator-Variable,buf,pos,3,8.7812694E-4,<mask>,"(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);<mask> = smallerBuf;
        }
        return buf;        
    }"
3841,Base64.java,encode,byte[] encode(byte[] pArray),944,963,37566,37568,IdentifierMutator-Variable,buf,buff,4,6.554376E-4,<mask>,"(int) len];
        setInitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);<mask> = smallerBuf;
        }
        return buf;        
    }"
3842,Base64.java,encode,byte[] encode(byte[] pArray),944,963,37572,37581,IdentifierMutator-Variable,smallerBuf,null,0,0.64716446,<mask>,"InitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf =<mask>;
        }
        return buf;        
    }"
3843,Base64.java,encode,byte[] encode(byte[] pArray),944,963,37572,37581,IdentifierMutator-Variable,smallerBuf,tmp,1,0.04206172,<mask>,"InitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf =<mask>;
        }
        return buf;        
    }"
3844,Base64.java,encode,byte[] encode(byte[] pArray),944,963,37572,37581,IdentifierMutator-Variable,smallerBuf,"""""",2,0.036717545,<mask>,"InitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf =<mask>;
        }
        return buf;        
    }"
3845,Base64.java,encode,byte[] encode(byte[] pArray),944,963,37572,37581,IdentifierMutator-Variable,smallerBuf,"''",3,0.030381972,<mask>,"InitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf =<mask>;
        }
        return buf;        
    }"
3846,Base64.java,encode,byte[] encode(byte[] pArray),944,963,37572,37581,IdentifierMutator-Variable,smallerBuf,undefined,4,0.029968875,<mask>,"InitialBuffer(buf, 0, buf.length);
        encode(pArray, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf =<mask>;
        }
        return buf;        
    }"
3847,Base64.java,encode,byte[] encode(byte[] pArray),944,965,37609,37611,IdentifierMutator-Variable,buf,null,1,0.018238561,<mask>,"Array, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return<mask>;        
    }"
3848,Base64.java,encode,byte[] encode(byte[] pArray),944,965,37609,37611,IdentifierMutator-Variable,buf,buffer,2,0.014618746,<mask>,"Array, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return<mask>;        
    }"
3849,Base64.java,encode,byte[] encode(byte[] pArray),944,965,37609,37611,IdentifierMutator-Variable,buf,true,3,0.012997434,<mask>,"Array, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return<mask>;        
    }"
3850,Base64.java,encode,byte[] encode(byte[] pArray),944,965,37609,37611,IdentifierMutator-Variable,buf,pos,4,0.010081948,<mask>,"Array, 0, pArray.length);
        encode(pArray, 0, -1); // Notify encoder of EOF.
        // Encoder might have resized, even though it was unnecessary.
        if (buffer != buf) {
            readResults(buf, 0, buf.length);
        }
        // In URL-SAFE mode we skip the padding characters, so sometimes our
        // final length is a bit smaller.
        if (isUrlSafe() && pos < buf.length) {
            byte[] smallerBuf = new byte[pos];
            System.arraycopy(buf, 0, smallerBuf, 0, pos);
            buf = smallerBuf;
        }
        return<mask>;        
    }"
3851,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,981,38359,38359,AssignmentMutator,chunkSize=(chunkSize/4)*4,*,0,0.757699,chunkSize <mask>= (chunkSize / 4) * 4,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize<mask>= (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3852,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,981,38359,38359,AssignmentMutator,chunkSize=(chunkSize/4)*4,/,1,0.084082216,chunkSize <mask>= (chunkSize / 4) * 4,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize<mask>= (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3853,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,981,38359,38359,AssignmentMutator,chunkSize=(chunkSize/4)*4,//,2,0.03792095,chunkSize <mask>= (chunkSize / 4) * 4,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize<mask>= (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3854,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,981,38359,38359,AssignmentMutator,chunkSize=(chunkSize/4)*4,|,3,0.025838248,chunkSize <mask>= (chunkSize / 4) * 4,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize<mask>= (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3855,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,981,38359,38359,AssignmentMutator,chunkSize=(chunkSize/4)*4,^,4,0.01236561,chunkSize <mask>= (chunkSize / 4) * 4,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize<mask>= (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3856,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,981,38350,38358,IdentifierMutator-Variable,chunkSize,len,0,0.28523907,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.<mask> = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3857,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,981,38350,38358,IdentifierMutator-Variable,chunkSize,int,1,0.11599006,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.<mask> = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3858,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,981,38350,38358,IdentifierMutator-Variable,chunkSize,len,2,0.054348,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.<mask> = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3859,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,981,38350,38358,IdentifierMutator-Variable,chunkSize,div,3,0.04248994,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.<mask> = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3860,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,981,38350,38358,IdentifierMutator-Variable,chunkSize,//,4,0.03864612,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.<mask> = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3861,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,981,38377,38379,BinaryOperatorMutator,*,/,2,0.095027745,(chunkSize / 4) <mask> 4,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4)<mask>4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3862,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,981,38377,38379,BinaryOperatorMutator,*,/,3,0.04321274,(chunkSize / 4) <mask> 4,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4)<mask>4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3863,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,981,38377,38379,BinaryOperatorMutator,*,%,4,0.04270596,(chunkSize / 4) <mask> 4,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4)<mask>4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3864,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,981,38372,38374,BinaryOperatorMutator,/,*,1,0.08277949,chunkSize <mask> 4,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize<mask>4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3865,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,981,38372,38374,BinaryOperatorMutator,/,*,3,0.03368062,chunkSize <mask> 4,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize<mask>4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3866,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,981,38372,38374,BinaryOperatorMutator,/,)/,4,0.019451067,chunkSize <mask> 4,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize<mask>4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3867,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,981,38363,38371,IdentifierMutator-Variable,chunkSize,4,0,0.15232132,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (<mask> / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3868,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,981,38363,38371,IdentifierMutator-Variable,chunkSize,3,1,0.12016192,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (<mask> / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3869,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,981,38363,38371,IdentifierMutator-Variable,chunkSize,1,2,0.05391293,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (<mask> / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3870,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,981,38363,38371,IdentifierMutator-Variable,chunkSize,bytes,3,0.05169963,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (<mask> / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3871,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,981,38363,38371,IdentifierMutator-Variable,chunkSize,32,4,0.04886875,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (<mask> / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3872,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,981,38375,38375,IdentifierMutator-Literal,4,3,1,0.30965114,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize /<mask>) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3873,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,981,38375,38375,IdentifierMutator-Literal,4,2,2,0.08291702,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize /<mask>) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3874,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,981,38375,38375,IdentifierMutator-Literal,4,8,3,0.019172817,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize /<mask>) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3875,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,981,38375,38375,IdentifierMutator-Literal,4,5,4,0.010471348,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize /<mask>) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3876,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,981,38380,38380,IdentifierMutator-Literal,4,3,1,0.26828933,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) *<mask>;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3877,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,981,38380,38380,IdentifierMutator-Literal,4,2,2,0.09560742,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) *<mask>;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3878,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,981,38380,38380,IdentifierMutator-Literal,4,8,3,0.016020432,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) *<mask>;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3879,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,981,38380,38380,IdentifierMutator-Literal,4,5,4,0.0140400315,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) *<mask>;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3880,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,983,38422,38424,BinaryOperatorMutator,/,*,0,0.4006437,(pArray.length * 4) <mask> 3,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4)<mask>3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3881,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,983,38422,38424,BinaryOperatorMutator,/,*,1,0.20103638,(pArray.length * 4) <mask> 3,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4)<mask>3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3882,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,983,38422,38424,BinaryOperatorMutator,/,**,4,0.031025715,(pArray.length * 4) <mask> 3,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4)<mask>3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3883,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,983,38417,38419,BinaryOperatorMutator,*,/,1,0.25892794,pArray.length <mask> 4,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length<mask>4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3884,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,983,38417,38419,BinaryOperatorMutator,*,**,3,0.030127496,pArray.length <mask> 4,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length<mask>4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3885,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,983,38417,38419,BinaryOperatorMutator,*,-,4,0.012048614,pArray.length <mask> 4,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length<mask>4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3886,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,983,38404,38416,IdentifierMutator-Variable,pArray.length,len,0,0.33022672,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (<mask> * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3887,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,983,38404,38416,IdentifierMutator-Variable,pArray.length,4,1,0.09437993,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (<mask> * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3888,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,983,38404,38416,IdentifierMutator-Variable,pArray.length,length,2,0.03643782,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (<mask> * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3889,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,983,38404,38416,IdentifierMutator-Variable,pArray.length,32,3,0.033453718,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (<mask> * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3890,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,983,38404,38416,IdentifierMutator-Variable,pArray.length,16,4,0.032144215,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (<mask> * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3891,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,983,38404,38409,IdentifierMutator-Variable,pArray,Array,0,0.6888457,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (<mask>.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3892,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,983,38404,38409,IdentifierMutator-Variable,pArray,array,1,0.27955845,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (<mask>.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3893,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,983,38404,38409,IdentifierMutator-Variable,pArray,buffer,2,0.0035116186,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (<mask>.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3894,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,983,38404,38409,IdentifierMutator-Variable,pArray,this,3,0.002345703,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (<mask>.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3895,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,983,38404,38409,IdentifierMutator-Variable,pArray,data,4,0.0019203473,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (<mask>.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3896,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,983,38411,38416,FieldReferenceMutator,length,size,1,2.642277E-4,pArray.<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.<mask> * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3897,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,983,38411,38416,FieldReferenceMutator,length,len,3,1.5998367E-4,pArray.<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.<mask> * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3898,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,983,38411,38416,FieldReferenceMutator,length,Length,4,4.6745114E-5,pArray.<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.<mask> * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3899,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,983,38420,38420,IdentifierMutator-Literal,4,3,1,0.35696718,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length *<mask>) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3900,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,983,38420,38420,IdentifierMutator-Literal,4,2,2,0.085122965,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length *<mask>) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3901,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,983,38420,38420,IdentifierMutator-Literal,4,5,3,0.008801148,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length *<mask>) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3902,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,983,38420,38420,IdentifierMutator-Literal,4,8,4,0.0048501487,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length *<mask>) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3903,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,983,38425,38425,IdentifierMutator-Literal,3,4,0,0.9792214,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) /<mask>;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3904,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,983,38425,38425,IdentifierMutator-Literal,3,8,1,0.004820542,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) /<mask>;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3905,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,983,38425,38425,IdentifierMutator-Literal,3,2,2,0.004698203,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) /<mask>;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3906,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,983,38425,38425,IdentifierMutator-Literal,3,5,4,0.0013046103,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) /<mask>;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3907,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,984,38450,38452,BinaryOperatorMutator,%,/,2,0.044680826,len <mask> 4,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len<mask>4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3908,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,984,38450,38452,BinaryOperatorMutator,%,*,3,0.013669026,len <mask> 4,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len<mask>4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3909,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,984,38450,38452,BinaryOperatorMutator,%,/,4,0.003808918,len <mask> 4,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len<mask>4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3910,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,984,38447,38449,IdentifierMutator-Variable,len,length,2,1.7645262E-4,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod =<mask> % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3911,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,984,38447,38449,IdentifierMutator-Variable,len,Len,3,1.1776573E-4,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod =<mask> % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3912,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,984,38447,38449,IdentifierMutator-Variable,len,0,4,4.061957E-5,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod =<mask> % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3913,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,984,38453,38453,IdentifierMutator-Literal,4,3,1,0.093714364,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len %<mask>;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3914,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,984,38453,38453,IdentifierMutator-Literal,4,2,2,0.02227574,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len %<mask>;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3915,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,984,38453,38453,IdentifierMutator-Literal,4,32,3,0.014692254,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len %<mask>;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3916,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,984,38453,38453,IdentifierMutator-Literal,4,8,4,0.009212671,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len %<mask>;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3917,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,985,38471,38474,BinaryOperatorMutator,!=,==,0,0.40180746,mod <mask> 0,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod<mask>0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3918,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,985,38471,38474,BinaryOperatorMutator,!=,>,1,0.31130987,mod <mask> 0,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod<mask>0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3919,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,985,38471,38474,BinaryOperatorMutator,!=,>,2,0.16050862,mod <mask> 0,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod<mask>0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3920,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,985,38471,38474,BinaryOperatorMutator,!=,<,4,0.02190726,mod <mask> 0,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod<mask>0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3921,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,985,38468,38470,IdentifierMutator-Variable,mod,Mod,2,1.6270451E-4,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (<mask> != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3922,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,985,38468,38470,IdentifierMutator-Variable,mod,MOD,3,1.3211368E-4,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (<mask> != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3923,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,985,38468,38470,IdentifierMutator-Variable,mod,div,4,1.2680917E-4,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (<mask> != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3924,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,985,38475,38475,IdentifierMutator-Literal,0,len,1,0.03223993,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod !=<mask>) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3925,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,985,38475,38475,IdentifierMutator-Literal,0,1,2,0.011239246,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod !=<mask>) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3926,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,985,38475,38475,IdentifierMutator-Literal,0,4,3,0.008156157,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod !=<mask>) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3927,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,985,38475,38475,IdentifierMutator-Literal,0,mod,4,0.004971297,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod !=<mask>) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3928,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,986,38495,38495,AssignmentMutator,len+=4-mod,*,0,0.6208573,len <mask>= 4 - mod,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len<mask>+= 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3929,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,986,38495,38495,AssignmentMutator,len+=4-mod,/,1,0.20294932,len <mask>= 4 - mod,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len<mask>+= 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3930,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,986,38495,38495,AssignmentMutator,len+=4-mod,//,2,0.043565005,len <mask>= 4 - mod,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len<mask>+= 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3931,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,986,38495,38495,AssignmentMutator,len+=4-mod,|,3,0.028616333,len <mask>= 4 - mod,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len<mask>+= 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3932,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,986,38495,38495,AssignmentMutator,len+=4-mod,%,4,0.016350625,len <mask>= 4 - mod,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len<mask>+= 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3933,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,986,38492,38494,IdentifierMutator-Variable,len,Len,2,0.003104103,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {<mask> += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3934,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,986,38492,38494,IdentifierMutator-Variable,len,length,3,0.0010736735,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {<mask> += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3935,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,986,38492,38494,IdentifierMutator-Variable,len,err,4,7.8696647E-4,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {<mask> += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3936,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,986,38500,38502,BinaryOperatorMutator,-,*,0,0.9141032,4 <mask> mod,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4<mask>mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3937,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,986,38500,38502,BinaryOperatorMutator,-,*,1,0.028346602,4 <mask> mod,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4<mask>mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3938,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,986,38500,38502,BinaryOperatorMutator,-,**,3,0.014989038,4 <mask> mod,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4<mask>mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3939,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,986,38500,38502,BinaryOperatorMutator,-,+,4,0.004105301,4 <mask> mod,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4<mask>mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3940,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,986,38499,38499,IdentifierMutator-Literal,4,32,1,0.08176036,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len +=<mask> - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3941,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,986,38499,38499,IdentifierMutator-Literal,4,len,2,0.05865364,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len +=<mask> - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3942,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,986,38499,38499,IdentifierMutator-Literal,4,64,3,0.03778266,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len +=<mask> - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3943,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,986,38499,38499,IdentifierMutator-Literal,4,8,4,0.02173213,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len +=<mask> - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3944,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,986,38503,38505,IdentifierMutator-Variable,mod,Mod,1,7.1611453E-4,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 -<mask>;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3945,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,986,38503,38505,IdentifierMutator-Variable,mod,1,2,5.1725365E-4,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 -<mask>;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3946,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,986,38503,38505,IdentifierMutator-Variable,mod,div,3,4.6540948E-4,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 -<mask>;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3947,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,986,38503,38505,IdentifierMutator-Variable,mod,dec,4,4.5103315E-4,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 -<mask>;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3948,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,988,38539,38541,BinaryOperatorMutator,>,==,0,0.42665642,chunkSize <mask> 0,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize<mask>0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3949,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,988,38539,38541,BinaryOperatorMutator,>,!=,3,0.02422497,chunkSize <mask> 0,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize<mask>0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3950,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,988,38539,38541,BinaryOperatorMutator,>,==,4,0.016458822,chunkSize <mask> 0,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize<mask>0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3951,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,988,38530,38538,IdentifierMutator-Variable,chunkSize,len,0,0.97435886,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (<mask> > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3952,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,988,38530,38538,IdentifierMutator-Variable,chunkSize,length,1,0.002224858,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (<mask> > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3953,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,988,38530,38538,IdentifierMutator-Variable,chunkSize,Len,2,0.0020340185,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (<mask> > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3954,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,988,38530,38538,IdentifierMutator-Variable,chunkSize,mod,3,0.0010735629,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (<mask> > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3955,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,988,38530,38538,IdentifierMutator-Variable,chunkSize,len,4,6.814558E-4,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (<mask> > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3956,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,988,38542,38542,IdentifierMutator-Literal,0,1,1,0.106186375,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize ><mask>) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3957,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,988,38542,38542,IdentifierMutator-Literal,0,4,2,0.07249552,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize ><mask>) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3958,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,988,38542,38542,IdentifierMutator-Literal,0,2,3,0.028006159,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize ><mask>) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3959,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,988,38542,38542,IdentifierMutator-Literal,0,3,4,0.022125917,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize ><mask>) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3960,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,989,38603,38606,BinaryOperatorMutator,==,!=,1,0.117873356,(len % chunkSize) <mask> 0,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize<mask>0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3961,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,989,38603,38606,BinaryOperatorMutator,==,=,3,0.021738809,(len % chunkSize) <mask> 0,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize<mask>0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3962,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,989,38603,38606,BinaryOperatorMutator,==,>,4,0.017359745,(len % chunkSize) <mask> 0,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize<mask>0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3963,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,989,38591,38593,BinaryOperatorMutator,%,/,2,0.1369017,len <mask> chunkSize,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len<mask>chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3964,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,989,38591,38593,BinaryOperatorMutator,%,-$,3,0.004605716,len <mask> chunkSize,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len<mask>chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3965,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,989,38591,38593,BinaryOperatorMutator,%,*,4,0.0044896216,len <mask> chunkSize,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len<mask>chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3966,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,989,38588,38590,IdentifierMutator-Variable,len,length,2,8.675184E-4,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly =<mask> % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3967,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,989,38588,38590,IdentifierMutator-Variable,len,0,3,1.0422285E-4,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly =<mask> % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3968,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,989,38588,38590,IdentifierMutator-Variable,len,Len,4,8.851278E-5,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly =<mask> % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3969,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,989,38594,38602,IdentifierMutator-Variable,chunkSize,4,0,0.88476956,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len %<mask> == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3970,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,989,38594,38602,IdentifierMutator-Variable,chunkSize,3,1,0.032893747,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len %<mask> == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3971,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,989,38594,38602,IdentifierMutator-Variable,chunkSize,2,2,0.031356677,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len %<mask> == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3972,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,989,38594,38602,IdentifierMutator-Variable,chunkSize,8,3,0.0075453436,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len %<mask> == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3973,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,989,38594,38602,IdentifierMutator-Variable,chunkSize,5,4,0.005714381,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len %<mask> == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3974,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,989,38607,38607,IdentifierMutator-Literal,0,1,1,0.021548418,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize ==<mask>;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3975,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,989,38607,38607,IdentifierMutator-Literal,0,2,2,0.0014325888,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize ==<mask>;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3976,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,989,38607,38607,IdentifierMutator-Literal,0,4,3,6.348271E-4,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize ==<mask>;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3977,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,989,38607,38607,IdentifierMutator-Literal,0,3,4,5.438567E-4,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize ==<mask>;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3978,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,990,38625,38625,AssignmentMutator,len+=(len/chunkSize)*chunkSeparator.length,*,0,0.38173753,len <mask>= (len / chunkSize) * chunkSeparator.length,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len<mask>+= (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3979,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,990,38625,38625,AssignmentMutator,len+=(len/chunkSize)*chunkSeparator.length,//,1,0.07163011,len <mask>= (len / chunkSize) * chunkSeparator.length,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len<mask>+= (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3980,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,990,38625,38625,AssignmentMutator,len+=(len/chunkSize)*chunkSeparator.length,,2,0.05592861,len <mask>= (len / chunkSize) * chunkSeparator.length,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len<mask>+= (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3981,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,990,38625,38625,AssignmentMutator,len+=(len/chunkSize)*chunkSeparator.length,*,3,0.040907517,len <mask>= (len / chunkSize) * chunkSeparator.length,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len<mask>+= (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3982,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,990,38625,38625,AssignmentMutator,len+=(len/chunkSize)*chunkSeparator.length,+,4,0.039499134,len <mask>= (len / chunkSize) * chunkSeparator.length,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len<mask>+= (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3983,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,990,38622,38624,IdentifierMutator-Variable,len,//,1,0.17717728,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;<mask> += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3984,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,990,38622,38624,IdentifierMutator-Variable,len,,3,0.0069302907,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;<mask> += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3985,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,990,38622,38624,IdentifierMutator-Variable,len,pos,4,0.0057359356,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;<mask> += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3986,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,990,38646,38648,BinaryOperatorMutator,*,+,2,0.019141003,(len / chunkSize) <mask> chunkSeparator.length,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize)<mask>chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3987,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,990,38646,38648,BinaryOperatorMutator,*,/,3,0.017518666,(len / chunkSize) <mask> chunkSeparator.length,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize)<mask>chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3988,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,990,38646,38648,BinaryOperatorMutator,*,^,4,0.010515787,(len / chunkSize) <mask> chunkSeparator.length,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize)<mask>chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3989,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,990,38633,38635,BinaryOperatorMutator,/,)/,1,0.07492397,len <mask> chunkSize,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len<mask>chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3990,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,990,38633,38635,BinaryOperatorMutator,/,%,2,0.055136304,len <mask> chunkSize,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len<mask>chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3991,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,990,38633,38635,BinaryOperatorMutator,/,*,4,0.04294577,len <mask> chunkSize,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len<mask>chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3992,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,990,38630,38632,IdentifierMutator-Variable,len,Len,2,6.170651E-4,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (<mask> / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3993,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,990,38630,38632,IdentifierMutator-Variable,len,fin,3,8.2147235E-5,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (<mask> / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3994,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,990,38630,38632,IdentifierMutator-Variable,len,0,4,7.993763E-5,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (<mask> / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3995,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,990,38636,38644,IdentifierMutator-Variable,chunkSize,4,0,0.80962336,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len /<mask>) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3996,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,990,38636,38644,IdentifierMutator-Variable,chunkSize,3,1,0.08805891,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len /<mask>) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3997,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,990,38636,38644,IdentifierMutator-Variable,chunkSize,2,2,0.055543303,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len /<mask>) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3998,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,990,38636,38644,IdentifierMutator-Variable,chunkSize,8,3,0.006437249,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len /<mask>) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
3999,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,990,38636,38644,IdentifierMutator-Variable,chunkSize,chunk,4,0.003611176,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len /<mask>) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
4000,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,990,38649,38669,IdentifierMutator-Variable,chunkSeparator.length,4,0,0.76078147,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) *<mask>;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
4001,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,990,38649,38669,IdentifierMutator-Variable,chunkSeparator.length,3,1,0.06535143,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) *<mask>;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
4002,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,990,38649,38669,IdentifierMutator-Variable,chunkSeparator.length,2,2,0.057437994,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) *<mask>;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
4003,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,990,38649,38669,IdentifierMutator-Variable,chunkSeparator.length,mod,3,0.017319407,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) *<mask>;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
4004,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,990,38649,38669,IdentifierMutator-Variable,chunkSeparator.length,8,4,0.012866691,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) *<mask>;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
4005,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,990,38649,38662,IdentifierMutator-Variable,chunkSeparator,array,0,0.38937578,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) *<mask>.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
4006,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,990,38649,38662,IdentifierMutator-Variable,chunkSeparator,arr,1,0.10213026,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) *<mask>.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
4007,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,990,38649,38662,IdentifierMutator-Variable,chunkSeparator,Array,2,0.08558387,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) *<mask>.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
4008,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,990,38649,38662,IdentifierMutator-Variable,chunkSeparator,buffer,3,0.04623182,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) *<mask>.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
4009,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,990,38649,38662,IdentifierMutator-Variable,chunkSeparator,Array,4,0.029352197,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) *<mask>.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
4010,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,990,38664,38669,FieldReferenceMutator,length,len,1,0.0011182418,chunkSeparator.<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.<mask>;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
4011,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,990,38664,38669,FieldReferenceMutator,length,width,2,1.1393922E-4,chunkSeparator.<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.<mask>;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
4012,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,990,38664,38669,FieldReferenceMutator,length,size,3,9.849639E-5,chunkSeparator.<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.<mask>;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
4013,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,990,38664,38669,FieldReferenceMutator,length,count,4,5.8391033E-5,chunkSeparator.<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.<mask>;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
4014,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,991,38688,38688,UnaryOperatorMutator,!,--,2,0.009289978,<mask>lenChunksPerfectly,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (<mask>lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
4015,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,991,38688,38688,UnaryOperatorMutator,!,...,3,0.006332605,<mask>lenChunksPerfectly,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (<mask>lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
4016,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,991,38688,38688,UnaryOperatorMutator,!,!!,4,0.002312401,<mask>lenChunksPerfectly,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (<mask>lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
4017,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,991,38689,38706,IdentifierMutator-Variable,lenChunksPerfectly,broken,0,0.05640271,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!<mask>) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
4018,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,991,38689,38706,IdentifierMutator-Variable,lenChunksPerfectly,break,1,0.047219757,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!<mask>) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
4019,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,991,38689,38706,IdentifierMutator-Variable,lenChunksPerfectly,reverse,2,0.03924868,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!<mask>) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
4020,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,991,38689,38706,IdentifierMutator-Variable,lenChunksPerfectly,fast,3,0.03328369,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!<mask>) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
4021,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,991,38689,38706,IdentifierMutator-Variable,lenChunksPerfectly,slow,4,0.029463543,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!<mask>) {
                len += chunkSeparator.length;
            }
        }
        return len;
    }"
4022,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,992,38730,38730,AssignmentMutator,len+=chunkSeparator.length,*,0,0.82963556,len <mask>= chunkSeparator.length,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len<mask>+= chunkSeparator.length;
            }
        }
        return len;
    }"
4023,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,992,38730,38730,AssignmentMutator,len+=chunkSeparator.length,/,1,0.10925856,len <mask>= chunkSeparator.length,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len<mask>+= chunkSeparator.length;
            }
        }
        return len;
    }"
4024,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,992,38730,38730,AssignmentMutator,len+=chunkSeparator.length,//,2,0.018342782,len <mask>= chunkSeparator.length,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len<mask>+= chunkSeparator.length;
            }
        }
        return len;
    }"
4025,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,992,38730,38730,AssignmentMutator,len+=chunkSeparator.length,|,3,0.009996202,len <mask>= chunkSeparator.length,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len<mask>+= chunkSeparator.length;
            }
        }
        return len;
    }"
4026,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,992,38730,38730,AssignmentMutator,len+=chunkSeparator.length,*,4,0.0037754227,len <mask>= chunkSeparator.length,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len<mask>+= chunkSeparator.length;
            }
        }
        return len;
    }"
4027,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,992,38727,38729,IdentifierMutator-Variable,len,Len,2,0.0014724658,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {<mask> += chunkSeparator.length;
            }
        }
        return len;
    }"
4028,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,992,38727,38729,IdentifierMutator-Variable,len,str,3,8.6564856E-4,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {<mask> += chunkSeparator.length;
            }
        }
        return len;
    }"
4029,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,992,38727,38729,IdentifierMutator-Variable,len,length,4,7.715416E-4,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {<mask> += chunkSeparator.length;
            }
        }
        return len;
    }"
4030,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,992,38734,38754,IdentifierMutator-Variable,chunkSeparator.length,mod,0,0.5163985,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len +=<mask>;
            }
        }
        return len;
    }"
4031,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,992,38734,38754,IdentifierMutator-Variable,chunkSeparator.length,1,1,0.20487992,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len +=<mask>;
            }
        }
        return len;
    }"
4032,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,992,38734,38754,IdentifierMutator-Variable,chunkSeparator.length,4,2,0.064282306,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len +=<mask>;
            }
        }
        return len;
    }"
4033,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,992,38734,38754,IdentifierMutator-Variable,chunkSeparator.length,3,3,0.03824685,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len +=<mask>;
            }
        }
        return len;
    }"
4034,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,992,38734,38754,IdentifierMutator-Variable,chunkSeparator.length,2,4,0.028362343,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len +=<mask>;
            }
        }
        return len;
    }"
4035,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,992,38734,38747,IdentifierMutator-Variable,chunkSeparator,array,0,0.21368952,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len +=<mask>.length;
            }
        }
        return len;
    }"
4036,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,992,38734,38747,IdentifierMutator-Variable,chunkSeparator,buffer,1,0.11163643,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len +=<mask>.length;
            }
        }
        return len;
    }"
4037,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,992,38734,38747,IdentifierMutator-Variable,chunkSeparator,arr,2,0.06837422,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len +=<mask>.length;
            }
        }
        return len;
    }"
4038,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,992,38734,38747,IdentifierMutator-Variable,chunkSeparator,buf,3,0.045161966,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len +=<mask>.length;
            }
        }
        return len;
    }"
4039,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,992,38734,38747,IdentifierMutator-Variable,chunkSeparator,Array,4,0.038819157,<mask>,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len +=<mask>.length;
            }
        }
        return len;
    }"
4040,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,992,38749,38754,FieldReferenceMutator,length,len,1,4.7619356E-4,chunkSeparator.<mask>,"codeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.<mask>;
            }
        }
        return len;
    }"
4041,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,992,38749,38754,FieldReferenceMutator,length,width,2,6.557313E-5,chunkSeparator.<mask>,"codeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.<mask>;
            }
        }
        return len;
    }"
4042,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,992,38749,38754,FieldReferenceMutator,length,size,4,3.7971742E-5,chunkSeparator.<mask>,"codeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
        // base64 always encodes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.<mask>;
            }
        }
        return len;
    }"
4043,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,995,38796,38798,IdentifierMutator-Variable,len,0,1,0.031097928,<mask>,"odes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return<mask>;
    }"
4044,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,995,38796,38798,IdentifierMutator-Variable,len,true,2,0.016361566,<mask>,"odes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return<mask>;
    }"
4045,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,995,38796,38798,IdentifierMutator-Variable,len,ret,3,0.014006297,<mask>,"odes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return<mask>;
    }"
4046,Base64.java,getEncodeLength,"long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator)",979,995,38796,38798,IdentifierMutator-Variable,len,"''",4,0.009495319,<mask>,"odes to multiples of 4.
        chunkSize = (chunkSize / 4) * 4;

        long len = (pArray.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0) {
            len += 4 - mod;
        }
        if (chunkSize > 0) {
            boolean lenChunksPerfectly = len % chunkSize == 0;
            len += (len / chunkSize) * chunkSeparator.length;
            if (!lenChunksPerfectly) {
                len += chunkSeparator.length;
            }
        }
        return<mask>;
    }"
4047,Base64.java,decodeInteger,BigInteger decodeInteger(byte[] pArray),1007,1008,39209,39209,IdentifierMutator-Literal,1,base,0,0.0871249,<mask>,"BigInteger decodeInteger(byte[] pArray) {
        return new BigInteger(<mask>, decodeBase64(pArray));
    }"
4048,Base64.java,decodeInteger,BigInteger decodeInteger(byte[] pArray),1007,1008,39209,39209,IdentifierMutator-Literal,1,1024,1,0.08487986,<mask>,"BigInteger decodeInteger(byte[] pArray) {
        return new BigInteger(<mask>, decodeBase64(pArray));
    }"
4049,Base64.java,decodeInteger,BigInteger decodeInteger(byte[] pArray),1007,1008,39209,39209,IdentifierMutator-Literal,1,0,2,0.07982505,<mask>,"BigInteger decodeInteger(byte[] pArray) {
        return new BigInteger(<mask>, decodeBase64(pArray));
    }"
4050,Base64.java,decodeInteger,BigInteger decodeInteger(byte[] pArray),1007,1008,39209,39209,IdentifierMutator-Literal,1,10,4,0.0697782,<mask>,"BigInteger decodeInteger(byte[] pArray) {
        return new BigInteger(<mask>, decodeBase64(pArray));
    }"
4051,Base64.java,decodeInteger,BigInteger decodeInteger(byte[] pArray),1007,1008,39212,39223,MethodCallMutator,decodeBase64,decode,0,0.9825644,<mask>(pArray),"BigInteger decodeInteger(byte[] pArray) {
        return new BigInteger(1,<mask>(pArray));
    }"
4052,Base64.java,decodeInteger,BigInteger decodeInteger(byte[] pArray),1007,1008,39212,39223,MethodCallMutator,decodeBase64,encode,1,0.00430283,<mask>(pArray),"BigInteger decodeInteger(byte[] pArray) {
        return new BigInteger(1,<mask>(pArray));
    }"
4053,Base64.java,decodeInteger,BigInteger decodeInteger(byte[] pArray),1007,1008,39212,39223,MethodCallMutator,decodeBase64,dec,2,0.0021592102,<mask>(pArray),"BigInteger decodeInteger(byte[] pArray) {
        return new BigInteger(1,<mask>(pArray));
    }"
4054,Base64.java,decodeInteger,BigInteger decodeInteger(byte[] pArray),1007,1008,39212,39223,MethodCallMutator,decodeBase64,reverse,3,0.0016701736,<mask>(pArray),"BigInteger decodeInteger(byte[] pArray) {
        return new BigInteger(1,<mask>(pArray));
    }"
4055,Base64.java,decodeInteger,BigInteger decodeInteger(byte[] pArray),1007,1008,39212,39223,MethodCallMutator,decodeBase64,decrypt,4,9.45154E-4,<mask>(pArray),"BigInteger decodeInteger(byte[] pArray) {
        return new BigInteger(1,<mask>(pArray));
    }"
4056,Base64.java,decodeInteger,BigInteger decodeInteger(byte[] pArray),1007,1008,39225,39230,IdentifierMutator-Variable,pArray,array,0,0.55204374,<mask>,"BigInteger decodeInteger(byte[] pArray) {
        return new BigInteger(1, decodeBase64(<mask>));
    }"
4057,Base64.java,decodeInteger,BigInteger decodeInteger(byte[] pArray),1007,1008,39225,39230,IdentifierMutator-Variable,pArray,Array,1,0.36896852,<mask>,"BigInteger decodeInteger(byte[] pArray) {
        return new BigInteger(1, decodeBase64(<mask>));
    }"
4058,Base64.java,decodeInteger,BigInteger decodeInteger(byte[] pArray),1007,1008,39225,39230,IdentifierMutator-Variable,pArray,p,2,0.019651005,<mask>,"BigInteger decodeInteger(byte[] pArray) {
        return new BigInteger(1, decodeBase64(<mask>));
    }"
4059,Base64.java,decodeInteger,BigInteger decodeInteger(byte[] pArray),1007,1008,39225,39230,IdentifierMutator-Variable,pArray,arr,3,0.012463191,<mask>,"BigInteger decodeInteger(byte[] pArray) {
        return new BigInteger(1, decodeBase64(<mask>));
    }"
4060,Base64.java,decodeInteger,BigInteger decodeInteger(byte[] pArray),1007,1008,39225,39230,IdentifierMutator-Variable,pArray,buffer,4,0.0044633653,<mask>,"BigInteger decodeInteger(byte[] pArray) {
        return new BigInteger(1, decodeBase64(<mask>));
    }"
4061,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1021,1022,39652,39655,BinaryOperatorMutator,==,=,2,0.030335454,bigInt <mask> null,"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt<mask>null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(bigInt), false);
    }"
4062,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1021,1022,39652,39655,BinaryOperatorMutator,==,||,3,0.0037420779,bigInt <mask> null,"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt<mask>null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(bigInt), false);
    }"
4063,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1021,1022,39652,39655,BinaryOperatorMutator,==,_,4,9.858963E-4,bigInt <mask> null,"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt<mask>null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(bigInt), false);
    }"
4064,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1021,1022,39646,39651,IdentifierMutator-Variable,bigInt,Parameter,0,0.11120432,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (<mask> == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(bigInt), false);
    }"
4065,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1021,1022,39646,39651,IdentifierMutator-Variable,bigInt,arg,1,0.093337074,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (<mask> == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(bigInt), false);
    }"
4066,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1021,1022,39646,39651,IdentifierMutator-Variable,bigInt,int,2,0.09172699,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (<mask> == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(bigInt), false);
    }"
4067,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1021,1022,39646,39651,IdentifierMutator-Variable,bigInt,params,3,0.0786028,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (<mask> == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(bigInt), false);
    }"
4068,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1021,1022,39646,39651,IdentifierMutator-Variable,bigInt,param,4,0.066067465,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (<mask> == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(bigInt), false);
    }"
4069,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1021,1022,39656,39659,IdentifierMutator-Literal,null,NULL,1,7.713278E-4,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt ==<mask>) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(bigInt), false);
    }"
4070,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1021,1022,39656,39659,IdentifierMutator-Literal,null,0,2,2.384645E-4,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt ==<mask>) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(bigInt), false);
    }"
4071,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1021,1022,39656,39659,IdentifierMutator-Literal,null,this,3,5.929655E-5,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt ==<mask>) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(bigInt), false);
    }"
4072,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1021,1022,39656,39659,IdentifierMutator-Literal,null,nil,4,3.7733767E-5,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt ==<mask>) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(bigInt), false);
    }"
4073,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1021,1023,39707,39748,IdentifierMutator-Literal,"""encodeIntegercalledwithnullparameter""",null,0,0.6568566,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(<mask>);
        }
        return encodeBase64(toIntegerBytes(bigInt), false);
    }"
4074,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1021,1023,39707,39748,IdentifierMutator-Literal,"""encodeIntegercalledwithnullparameter""",this,1,0.10882717,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(<mask>);
        }
        return encodeBase64(toIntegerBytes(bigInt), false);
    }"
4075,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1021,1023,39707,39748,IdentifierMutator-Literal,"""encodeIntegercalledwithnullparameter""",int,2,0.040326968,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(<mask>);
        }
        return encodeBase64(toIntegerBytes(bigInt), false);
    }"
4076,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1021,1023,39707,39748,IdentifierMutator-Literal,"""encodeIntegercalledwithnullparameter""",string,3,0.0266979,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(<mask>);
        }
        return encodeBase64(toIntegerBytes(bigInt), false);
    }"
4077,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1021,1023,39707,39748,IdentifierMutator-Literal,"""encodeIntegercalledwithnullparameter""",0,4,0.015059375,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(<mask>);
        }
        return encodeBase64(toIntegerBytes(bigInt), false);
    }"
4078,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1021,1025,39777,39788,MethodCallMutator,encodeBase64,encode,0,0.9373801,"<mask>(toIntegerBytes(bigInt), false)","byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return<mask>(toIntegerBytes(bigInt), false);
    }"
4079,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1021,1025,39777,39788,MethodCallMutator,encodeBase64,decode,1,0.023692034,"<mask>(toIntegerBytes(bigInt), false)","byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return<mask>(toIntegerBytes(bigInt), false);
    }"
4080,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1021,1025,39777,39788,MethodCallMutator,encodeBase64,append,2,0.009296445,"<mask>(toIntegerBytes(bigInt), false)","byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return<mask>(toIntegerBytes(bigInt), false);
    }"
4081,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1021,1025,39777,39788,MethodCallMutator,encodeBase64,write,3,0.007480262,"<mask>(toIntegerBytes(bigInt), false)","byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return<mask>(toIntegerBytes(bigInt), false);
    }"
4082,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1021,1025,39777,39788,MethodCallMutator,encodeBase64,pack,4,0.003138791,"<mask>(toIntegerBytes(bigInt), false)","byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return<mask>(toIntegerBytes(bigInt), false);
    }"
4083,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1021,1025,39790,39803,MethodCallMutator,toIntegerBytes,bytes,0,0.44908607,<mask>(bigInt),"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(<mask>(bigInt), false);
    }"
4084,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1021,1025,39790,39803,MethodCallMutator,toIntegerBytes,bits,1,0.0917492,<mask>(bigInt),"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(<mask>(bigInt), false);
    }"
4085,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1021,1025,39790,39803,MethodCallMutator,toIntegerBytes,format,2,0.054781564,<mask>(bigInt),"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(<mask>(bigInt), false);
    }"
4086,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1021,1025,39790,39803,MethodCallMutator,toIntegerBytes,string,3,0.04108071,<mask>(bigInt),"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(<mask>(bigInt), false);
    }"
4087,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1021,1025,39790,39803,MethodCallMutator,toIntegerBytes,wrap,4,0.038791526,<mask>(bigInt),"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(<mask>(bigInt), false);
    }"
4088,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1021,1025,39805,39810,IdentifierMutator-Variable,bigInt,int,0,0.6725798,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(<mask>), false);
    }"
4089,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1021,1025,39805,39810,IdentifierMutator-Variable,bigInt,Integer,1,0.0748183,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(<mask>), false);
    }"
4090,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1021,1025,39805,39810,IdentifierMutator-Variable,bigInt,integer,2,0.06649796,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(<mask>), false);
    }"
4091,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1021,1025,39805,39810,IdentifierMutator-Variable,bigInt,i,3,0.012533095,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(<mask>), false);
    }"
4092,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1021,1025,39805,39810,IdentifierMutator-Variable,bigInt,in,4,0.011997879,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(<mask>), false);
    }"
4093,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1021,1025,39814,39818,IdentifierMutator-Literal,false,true,0,0.27569658,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(bigInt),<mask>);
    }"
4094,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1021,1025,39814,39818,IdentifierMutator-Literal,false,encoding,1,0.25120947,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(bigInt),<mask>);
    }"
4095,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1021,1025,39814,39818,IdentifierMutator-Literal,false,null,3,0.03534399,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(bigInt),<mask>);
    }"
4096,Base64.java,encodeInteger,byte[] encodeInteger(BigInteger bigInt),1021,1025,39814,39818,IdentifierMutator-Literal,false,codec,4,0.021135336,<mask>,"byte[] encodeInteger(BigInteger bigInt) {
        if (bigInt == null) {
            throw new NullPointerException(""encodeInteger called with null parameter"");
        }
        return encodeBase64(toIntegerBytes(bigInt),<mask>);
    }"
4097,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1036,40175,40183,MethodCallMutator,bitLength,length,0,0.48251987,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.<mask>();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4098,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1036,40175,40183,MethodCallMutator,bitLength,bits,1,0.38687202,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.<mask>();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4099,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1036,40175,40183,MethodCallMutator,bitLength,size,2,0.07385074,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.<mask>();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4100,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1036,40175,40183,MethodCallMutator,bitLength,value,3,0.0109686665,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.<mask>();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4101,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1036,40175,40183,MethodCallMutator,bitLength,len,4,0.0062536923,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.<mask>();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4102,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1036,40168,40173,IdentifierMutator-Variable,bigInt,int,0,0.18107656,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen =<mask>.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4103,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1036,40168,40173,IdentifierMutator-Variable,bigInt,big,1,0.12825333,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen =<mask>.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4104,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1036,40168,40173,IdentifierMutator-Variable,bigInt,this,2,0.12717226,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen =<mask>.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4105,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1036,40168,40173,IdentifierMutator-Variable,bigInt,Integer,3,0.09035175,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen =<mask>.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4106,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1036,40168,40173,IdentifierMutator-Variable,bigInt,Int,4,0.04822755,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen =<mask>.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4107,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1038,40226,40226,AssignmentMutator,bitlen=((bitlen+7)>>3)<<3,|,0,0.43720365,bitlen <mask>= ((bitlen + 7) >> 3) << 3,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen<mask>= ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4108,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1038,40226,40226,AssignmentMutator,bitlen=((bitlen+7)>>3)<<3,^,1,0.18715443,bitlen <mask>= ((bitlen + 7) >> 3) << 3,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen<mask>= ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4109,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1038,40226,40226,AssignmentMutator,bitlen=((bitlen+7)>>3)<<3,*,2,0.10112992,bitlen <mask>= ((bitlen + 7) >> 3) << 3,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen<mask>= ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4110,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1038,40226,40226,AssignmentMutator,bitlen=((bitlen+7)>>3)<<3,/,3,0.088297136,bitlen <mask>= ((bitlen + 7) >> 3) << 3,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen<mask>= ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4111,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1038,40226,40226,AssignmentMutator,bitlen=((bitlen+7)>>3)<<3,//,4,0.049632814,bitlen <mask>= ((bitlen + 7) >> 3) << 3,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen<mask>= ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4112,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1038,40220,40225,IdentifierMutator-Variable,bitlen,bits,0,0.08313724,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen<mask> = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4113,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1038,40220,40225,IdentifierMutator-Variable,bitlen,len,1,0.059650324,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen<mask> = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4114,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1038,40220,40225,IdentifierMutator-Variable,bitlen,int,2,0.04552535,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen<mask> = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4115,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1038,40220,40225,IdentifierMutator-Variable,bitlen,to,3,0.041318376,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen<mask> = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4116,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1038,40220,40225,IdentifierMutator-Variable,bitlen,*,4,0.02975418,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen<mask> = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4117,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1038,40248,40251,BinaryOperatorMutator,<<,&,1,0.19580212,((bitlen + 7) >> 3) <mask> 3,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3)<mask>3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4118,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1038,40248,40251,BinaryOperatorMutator,<<,^,2,0.1060897,((bitlen + 7) >> 3) <mask> 3,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3)<mask>3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4119,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1038,40248,40251,BinaryOperatorMutator,<<,*,3,0.09870726,((bitlen + 7) >> 3) <mask> 3,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3)<mask>3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4120,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1038,40242,40245,BinaryOperatorMutator,>>,>>>,1,0.14948852,(bitlen + 7) <mask> 3,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7)<mask>3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4121,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1038,40242,40245,BinaryOperatorMutator,>>,<<,2,0.11032278,(bitlen + 7) <mask> 3,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7)<mask>3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4122,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1038,40242,40245,BinaryOperatorMutator,>>,*,4,0.08248834,(bitlen + 7) <mask> 3,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7)<mask>3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4123,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1038,40237,40239,BinaryOperatorMutator,+,/,0,0.18338405,bitlen <mask> 7,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen<mask>7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4124,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1038,40237,40239,BinaryOperatorMutator,+,>>>,2,0.120289825,bitlen <mask> 7,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen<mask>7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4125,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1038,40237,40239,BinaryOperatorMutator,+,%,3,0.09331382,bitlen <mask> 7,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen<mask>7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4126,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1038,40237,40239,BinaryOperatorMutator,+,/,4,0.068242244,bitlen <mask> 7,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen<mask>7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4127,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1038,40231,40236,IdentifierMutator-Variable,bitlen,8,0,0.27621976,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((<mask> + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4128,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1038,40231,40236,IdentifierMutator-Variable,bitlen,len,1,0.12567848,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((<mask> + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4129,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1038,40231,40236,IdentifierMutator-Variable,bitlen,7,2,0.07215883,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((<mask> + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4130,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1038,40231,40236,IdentifierMutator-Variable,bitlen,1,3,0.057754982,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((<mask> + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4131,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1038,40231,40236,IdentifierMutator-Variable,bitlen,16,4,0.03745065,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((<mask> + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4132,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1038,40240,40240,IdentifierMutator-Literal,7,1,0,0.5781683,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen +<mask>) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4133,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1038,40240,40240,IdentifierMutator-Literal,7,8,2,0.049941115,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen +<mask>) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4134,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1038,40240,40240,IdentifierMutator-Literal,7,3,3,0.03981444,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen +<mask>) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4135,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1038,40240,40240,IdentifierMutator-Literal,7,4,4,0.035863984,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen +<mask>) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4136,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1038,40246,40246,IdentifierMutator-Literal,3,6,1,0.07721478,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >><mask>) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4137,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1038,40246,40246,IdentifierMutator-Literal,3,1,2,0.07711057,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >><mask>) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4138,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1038,40246,40246,IdentifierMutator-Literal,3,2,3,0.07223876,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >><mask>) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4139,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1038,40246,40246,IdentifierMutator-Literal,3,4,4,0.0714804,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >><mask>) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4140,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1038,40252,40252,IdentifierMutator-Literal,3,1,1,0.0855002,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) <<<mask>;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4141,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1038,40252,40252,IdentifierMutator-Literal,3,7,2,0.06189106,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) <<<mask>;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4142,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1038,40252,40252,IdentifierMutator-Literal,3,4,3,0.060085412,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) <<<mask>;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4143,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1038,40252,40252,IdentifierMutator-Literal,3,2,4,0.051770635,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) <<<mask>;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4144,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1039,40288,40298,MethodCallMutator,toByteArray,bytes,0,0.9154517,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.<mask>();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4145,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1039,40288,40298,MethodCallMutator,toByteArray,bits,1,0.019694937,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.<mask>();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4146,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1039,40288,40298,MethodCallMutator,toByteArray,Bytes,2,0.012274291,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.<mask>();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4147,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1039,40288,40298,MethodCallMutator,toByteArray,bin,3,0.008588914,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.<mask>();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4148,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1039,40288,40298,MethodCallMutator,toByteArray,value,4,0.007243815,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.<mask>();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4149,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1039,40281,40286,IdentifierMutator-Variable,bigInt,big,0,0.19933367,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes =<mask>.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4150,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1039,40281,40286,IdentifierMutator-Variable,bigInt,input,1,0.06758484,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes =<mask>.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4151,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1039,40281,40286,IdentifierMutator-Variable,bigInt,bytes,2,0.059770394,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes =<mask>.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4152,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1039,40281,40286,IdentifierMutator-Variable,bigInt,this,3,0.057770573,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes =<mask>.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4153,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1039,40281,40286,IdentifierMutator-Variable,bigInt,bits,4,0.051053487,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes =<mask>.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4154,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1041,40347,40350,BinaryOperatorMutator,&&,&,2,0.031849235,((bigInt.bitLength() % 8) != 0) <mask> (((bigInt.bitLength() / 8) + 1) == (bitlen / 8)),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0)<mask>(((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4155,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1041,40347,40350,BinaryOperatorMutator,&&,&,3,0.01671658,((bigInt.bitLength() % 8) != 0) <mask> (((bigInt.bitLength() / 8) + 1) == (bitlen / 8)),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0)<mask>(((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4156,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1041,40347,40350,BinaryOperatorMutator,&&,//,4,0.0063783694,((bigInt.bitLength() % 8) != 0) <mask> (((bigInt.bitLength() / 8) + 1) == (bitlen / 8)),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0)<mask>(((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4157,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1041,40341,40344,BinaryOperatorMutator,!=,==,0,0.77037054,(bigInt.bitLength() % 8) <mask> 0,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8)<mask>0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4158,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1041,40341,40344,BinaryOperatorMutator,!=,==,1,0.12744549,(bigInt.bitLength() % 8) <mask> 0,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8)<mask>0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4159,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1041,40341,40344,BinaryOperatorMutator,!=,>,2,0.05485525,(bigInt.bitLength() % 8) <mask> 0,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8)<mask>0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4160,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1041,40341,40344,BinaryOperatorMutator,!=,>,4,0.015251417,(bigInt.bitLength() % 8) <mask> 0,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8)<mask>0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4161,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1041,40336,40338,BinaryOperatorMutator,%,/,0,0.5188738,bigInt.bitLength() <mask> 8,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength()<mask>8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4162,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1041,40336,40338,BinaryOperatorMutator,%,/,2,0.16815417,bigInt.bitLength() <mask> 8,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength()<mask>8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4163,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1041,40336,40338,BinaryOperatorMutator,%,)/,4,0.012889168,bigInt.bitLength() <mask> 8,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength()<mask>8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4164,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1041,40325,40333,MethodCallMutator,bitLength,length,0,0.9163653,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.<mask>() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4165,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1041,40325,40333,MethodCallMutator,bitLength,bits,1,0.051798075,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.<mask>() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4166,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1041,40325,40333,MethodCallMutator,bitLength,Length,2,0.009550717,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.<mask>() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4167,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1041,40325,40333,MethodCallMutator,bitLength,bit,3,0.004910234,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.<mask>() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4168,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1041,40325,40333,MethodCallMutator,bitLength,value,4,0.0023052199,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.<mask>() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4169,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1041,40318,40323,IdentifierMutator-Variable,bigInt,int,0,0.746823,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((<mask>.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4170,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1041,40318,40323,IdentifierMutator-Variable,bigInt,Int,1,0.1649221,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((<mask>.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4171,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1041,40318,40323,IdentifierMutator-Variable,bigInt,Integer,2,0.0139945075,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((<mask>.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4172,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1041,40318,40323,IdentifierMutator-Variable,bigInt,big,3,0.013856921,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((<mask>.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4173,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1041,40318,40323,IdentifierMutator-Variable,bigInt,long,4,0.006214563,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((<mask>.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4174,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1041,40339,40339,IdentifierMutator-Literal,8,7,1,0.005530607,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() %<mask>) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4175,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1041,40339,40339,IdentifierMutator-Literal,8,2,2,9.932129E-4,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() %<mask>) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4176,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1041,40339,40339,IdentifierMutator-Literal,8,4,3,9.187786E-4,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() %<mask>) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4177,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1041,40339,40339,IdentifierMutator-Literal,8,16,4,8.816952E-4,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() %<mask>) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4178,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1041,40345,40345,IdentifierMutator-Literal,0,1,1,0.01637059,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) !=<mask>) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4179,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1041,40345,40345,IdentifierMutator-Literal,0,8,2,0.0014612796,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) !=<mask>) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4180,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1041,40345,40345,IdentifierMutator-Literal,0,7,3,9.844551E-4,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) !=<mask>) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4181,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1041,40345,40345,IdentifierMutator-Literal,0,2,4,5.684401E-4,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) !=<mask>) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4182,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1041,40382,40385,BinaryOperatorMutator,==,<,0,0.33627945,((bigInt.bitLength() / 8) + 1) <mask> (bitlen / 8),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1)<mask>(bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4183,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1041,40382,40385,BinaryOperatorMutator,==,<=,3,0.07669811,((bigInt.bitLength() / 8) + 1) <mask> (bitlen / 8),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1)<mask>(bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4184,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1041,40382,40385,BinaryOperatorMutator,==,>,4,0.07506787,((bigInt.bitLength() / 8) + 1) <mask> (bitlen / 8),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1)<mask>(bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4185,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1041,40377,40379,BinaryOperatorMutator,+,-,0,0.4067248,(bigInt.bitLength() / 8) <mask> 1,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8)<mask>1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4186,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1041,40377,40379,BinaryOperatorMutator,+,-,2,0.09282907,(bigInt.bitLength() / 8) <mask> 1,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8)<mask>1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4187,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1041,40377,40379,BinaryOperatorMutator,+,**,4,0.021640921,(bigInt.bitLength() / 8) <mask> 1,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8)<mask>1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4188,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1041,40372,40374,BinaryOperatorMutator,/,%,0,0.5219178,bigInt.bitLength() <mask> 8,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength()<mask>8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4189,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1041,40372,40374,BinaryOperatorMutator,/,//,3,0.044786364,bigInt.bitLength() <mask> 8,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength()<mask>8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4190,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1041,40372,40374,BinaryOperatorMutator,/,%,4,0.0199752,bigInt.bitLength() <mask> 8,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength()<mask>8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4191,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1041,40361,40369,MethodCallMutator,bitLength,bits,0,0.51306206,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.<mask>() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4192,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1041,40361,40369,MethodCallMutator,bitLength,length,1,0.34586373,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.<mask>() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4193,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1041,40361,40369,MethodCallMutator,bitLength,size,2,0.038241714,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.<mask>() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4194,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1041,40361,40369,MethodCallMutator,bitLength,value,3,0.02103165,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.<mask>() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4195,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1041,40361,40369,MethodCallMutator,bitLength,bytes,4,0.012758481,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.<mask>() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4196,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1041,40354,40359,IdentifierMutator-Variable,bigInt,int,0,0.6868534,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((<mask>.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4197,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1041,40354,40359,IdentifierMutator-Variable,bigInt,Int,1,0.17645743,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((<mask>.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4198,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1041,40354,40359,IdentifierMutator-Variable,bigInt,big,2,0.022624277,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((<mask>.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4199,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1041,40354,40359,IdentifierMutator-Variable,bigInt,Integer,3,0.011915404,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((<mask>.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4200,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1041,40354,40359,IdentifierMutator-Variable,bigInt,long,4,0.011535025,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((<mask>.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4201,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1041,40375,40375,IdentifierMutator-Literal,8,7,1,0.0014157639,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() /<mask>) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4202,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1041,40375,40375,IdentifierMutator-Literal,8,2,2,3.993033E-4,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() /<mask>) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4203,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1041,40375,40375,IdentifierMutator-Literal,8,4,4,2.617816E-4,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() /<mask>) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4204,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1041,40380,40380,IdentifierMutator-Literal,1,7,0,0.53698957,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) +<mask>) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4205,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1041,40380,40380,IdentifierMutator-Literal,1,8,2,0.04494058,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) +<mask>) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4206,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1041,40380,40380,IdentifierMutator-Literal,1,6,3,0.021930046,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) +<mask>) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4207,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1041,40380,40380,IdentifierMutator-Literal,1,3,4,0.013008297,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) +<mask>) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4208,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1041,40393,40395,BinaryOperatorMutator,/,%,1,0.08506532,bitlen <mask> 8,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen<mask>8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4209,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1041,40393,40395,BinaryOperatorMutator,/,%,3,0.050874334,bitlen <mask> 8,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen<mask>8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4210,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1041,40393,40395,BinaryOperatorMutator,/,)/,4,0.029188493,bitlen <mask> 8,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen<mask>8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4211,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1041,40387,40392,IdentifierMutator-Variable,bitlen,len,0,0.7807609,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (<mask> / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4212,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1041,40387,40392,IdentifierMutator-Variable,bitlen,8,1,0.037611578,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (<mask> / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4213,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1041,40387,40392,IdentifierMutator-Variable,bitlen,1,2,0.020053845,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (<mask> / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4214,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1041,40387,40392,IdentifierMutator-Variable,bitlen,length,3,0.01008563,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (<mask> / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4215,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1041,40387,40392,IdentifierMutator-Variable,bitlen,255,4,0.008992478,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (<mask> / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4216,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1041,40396,40396,IdentifierMutator-Literal,8,7,1,0.0122226635,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen /<mask>))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4217,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1041,40396,40396,IdentifierMutator-Literal,8,2,2,0.011287117,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen /<mask>))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4218,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1041,40396,40396,IdentifierMutator-Literal,8,4,3,0.005160084,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen /<mask>))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4219,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1041,40396,40396,IdentifierMutator-Literal,8,6,4,0.002372981,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen /<mask>))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4220,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1042,40422,40429,IdentifierMutator-Variable,bigBytes,null,0,0.8249167,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return<mask>;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4221,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1042,40422,40429,IdentifierMutator-Variable,bigBytes,bytes,1,0.041228767,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return<mask>;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4222,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1042,40422,40429,IdentifierMutator-Variable,bigBytes,"""""",2,0.024125043,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return<mask>;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4223,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1042,40422,40429,IdentifierMutator-Variable,bigBytes,0,3,0.018363696,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return<mask>;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4224,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1042,40422,40429,IdentifierMutator-Variable,bigBytes,false,4,0.009283522,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return<mask>;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4225,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1045,40526,40526,IdentifierMutator-Literal,0,1,1,0.021016305,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc =<mask>;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4226,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1045,40526,40526,IdentifierMutator-Literal,0,2,2,0.0048450893,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc =<mask>;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4227,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1045,40526,40526,IdentifierMutator-Literal,0,8,3,0.0010382727,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc =<mask>;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4228,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1045,40526,40526,IdentifierMutator-Literal,0,3,4,8.4656867E-4,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc =<mask>;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4229,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1046,40547,40561,IdentifierMutator-Variable,bigBytes.length,0,0,0.30062032,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len =<mask>;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4230,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1046,40547,40561,IdentifierMutator-Variable,bigBytes.length,8,1,0.19684462,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len =<mask>;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4231,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1046,40547,40561,IdentifierMutator-Variable,bigBytes.length,1,2,0.16209225,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len =<mask>;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4232,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1046,40547,40561,IdentifierMutator-Variable,bigBytes.length,7,3,0.038919616,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len =<mask>;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4233,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1046,40547,40561,IdentifierMutator-Variable,bigBytes.length,2,4,0.036710225,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len =<mask>;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4234,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1046,40547,40554,IdentifierMutator-Variable,bigBytes,bytes,0,0.37873113,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len =<mask>.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4235,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1046,40547,40554,IdentifierMutator-Variable,bigBytes,src,1,0.16859323,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len =<mask>.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4236,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1046,40547,40554,IdentifierMutator-Variable,bigBytes,bits,2,0.07624572,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len =<mask>.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4237,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1046,40547,40554,IdentifierMutator-Variable,bigBytes,data,3,0.037784383,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len =<mask>.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4238,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1046,40547,40554,IdentifierMutator-Variable,bigBytes,arr,4,0.034755036,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len =<mask>.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4239,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1046,40556,40561,FieldReferenceMutator,length,size,1,0.006459289,bigBytes.<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.<mask>;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4240,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1046,40556,40561,FieldReferenceMutator,length,len,2,0.0028275007,bigBytes.<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.<mask>;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4241,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1046,40556,40561,FieldReferenceMutator,length,Length,4,1.4477444E-4,bigBytes.<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.<mask>;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4242,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1049,40673,40676,BinaryOperatorMutator,==,!=,1,0.050353006,(bigInt.bitLength() % 8) <mask> 0,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8)<mask>0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4243,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1049,40673,40676,BinaryOperatorMutator,==,>,2,0.022252146,(bigInt.bitLength() % 8) <mask> 0,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8)<mask>0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4244,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1049,40673,40676,BinaryOperatorMutator,==,=,4,0.004793392,(bigInt.bitLength() % 8) <mask> 0,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8)<mask>0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4245,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1049,40668,40670,BinaryOperatorMutator,%,/,2,0.013124464,bigInt.bitLength() <mask> 8,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength()<mask>8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4246,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1049,40668,40670,BinaryOperatorMutator,%,/,3,0.0021349713,bigInt.bitLength() <mask> 8,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength()<mask>8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4247,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1049,40668,40670,BinaryOperatorMutator,%,)/,4,0.0010469529,bigInt.bitLength() <mask> 8,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength()<mask>8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4248,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1049,40657,40665,MethodCallMutator,bitLength,length,0,0.9524557,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.<mask>() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4249,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1049,40657,40665,MethodCallMutator,bitLength,bits,1,0.027737807,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.<mask>() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4250,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1049,40657,40665,MethodCallMutator,bitLength,len,2,0.004314162,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.<mask>() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4251,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1049,40657,40665,MethodCallMutator,bitLength,Length,3,0.0022060445,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.<mask>() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4252,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1049,40657,40665,MethodCallMutator,bitLength,value,4,0.0018004113,bigInt.<mask>(),"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.<mask>() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4253,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1049,40650,40655,IdentifierMutator-Variable,bigInt,len,0,0.48073485,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((<mask>.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4254,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1049,40650,40655,IdentifierMutator-Variable,bigInt,int,1,0.09259159,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((<mask>.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4255,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1049,40650,40655,IdentifierMutator-Variable,bigInt,this,2,0.043618537,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((<mask>.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4256,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1049,40650,40655,IdentifierMutator-Variable,bigInt,src,3,0.025487807,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((<mask>.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4257,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1049,40650,40655,IdentifierMutator-Variable,bigInt,self,4,0.019777497,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((<mask>.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4258,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1049,40671,40671,IdentifierMutator-Literal,8,7,1,0.007750802,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() %<mask>) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4259,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1049,40671,40671,IdentifierMutator-Literal,8,2,2,0.007257772,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() %<mask>) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4260,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1049,40671,40671,IdentifierMutator-Literal,8,4,3,0.0055588605,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() %<mask>) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4261,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1049,40671,40671,IdentifierMutator-Literal,8,16,4,0.0032617177,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() %<mask>) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4262,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1049,40677,40677,IdentifierMutator-Literal,0,1,1,0.017934965,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) ==<mask>) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4263,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1049,40677,40677,IdentifierMutator-Literal,0,8,2,0.0029667788,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) ==<mask>) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4264,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1049,40677,40677,IdentifierMutator-Literal,0,2,3,7.5614953E-4,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) ==<mask>) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4265,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1049,40677,40677,IdentifierMutator-Literal,0,7,4,4.5119293E-4,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) ==<mask>) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4266,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1050,40702,40702,AssignmentMutator,startSrc=1,*,0,0.3484217,startSrc <mask>= 1,"
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc<mask>= 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4267,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1050,40702,40702,AssignmentMutator,startSrc=1,<<,1,0.3361942,startSrc <mask>= 1,"
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc<mask>= 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4268,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1050,40702,40702,AssignmentMutator,startSrc=1,|,2,0.19524975,startSrc <mask>= 1,"
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc<mask>= 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4269,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1050,40702,40702,AssignmentMutator,startSrc=1,>>,3,0.05596123,startSrc <mask>= 1,"
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc<mask>= 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4270,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1050,40702,40702,AssignmentMutator,startSrc=1,^,4,0.012988011,startSrc <mask>= 1,"
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc<mask>= 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4271,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1050,40694,40701,IdentifierMutator-Variable,startSrc,len,0,0.94888735,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {<mask> = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4272,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1050,40694,40701,IdentifierMutator-Variable,startSrc,len,1,0.017293142,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {<mask> = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4273,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1050,40694,40701,IdentifierMutator-Variable,startSrc,Len,2,0.0066153617,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {<mask> = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4274,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1050,40694,40701,IdentifierMutator-Variable,startSrc,src,3,0.0021479556,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {<mask> = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4275,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1050,40694,40701,IdentifierMutator-Variable,startSrc,pos,4,0.0011132794,<mask>,"byte[] toIntegerBytes(BigInteger bigInt) {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {<mask> = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4276,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1050,40705,40705,IdentifierMutator-Literal,1,0,0,0.81215477,<mask>,"        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc =<mask>;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4277,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1050,40705,40705,IdentifierMutator-Literal,1,len,1,0.06501877,<mask>,"        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc =<mask>;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4278,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1050,40705,40705,IdentifierMutator-Literal,1,i,3,0.014734172,<mask>,"        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc =<mask>;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4279,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1050,40705,40705,IdentifierMutator-Literal,1,pos,4,0.008305038,<mask>,"        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc =<mask>;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4280,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1051,40723,40725,UnaryOperatorMutator,--,++;,0,0.8438007,len<mask>,"Length();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len<mask>
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4281,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1051,40723,40725,UnaryOperatorMutator,--,=,1,0.081237845,len<mask>,"Length();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len<mask>
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4282,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1051,40723,40725,UnaryOperatorMutator,--,;,3,0.0130390255,len<mask>,"Length();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len<mask>
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4283,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1051,40723,40725,UnaryOperatorMutator,--,++,4,0.010570115,len<mask>,"Length();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len<mask>
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4284,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1051,40720,40722,IdentifierMutator-Variable,len,Len,2,0.0030426686,<mask>,"      int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;<mask>--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4285,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1051,40720,40722,IdentifierMutator-Variable,len,pos,3,6.6311454E-4,<mask>,"      int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;<mask>--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4286,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1051,40720,40722,IdentifierMutator-Variable,len,length,4,4.54495E-4,<mask>,"      int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;<mask>--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4287,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1053,40770,40772,BinaryOperatorMutator,-,*,0,0.47997975,(bitlen / 8) <mask> len," + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8<mask>len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4288,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1053,40770,40772,BinaryOperatorMutator,-,.,1,0.16752994,(bitlen / 8) <mask> len," + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8<mask>len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4289,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1053,40770,40772,BinaryOperatorMutator,-,+,2,0.12269536,(bitlen / 8) <mask> len," + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8<mask>len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4290,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1053,40770,40772,BinaryOperatorMutator,-,^,4,0.02007228,(bitlen / 8) <mask> len," + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8<mask>len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4291,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1053,40766,40768,BinaryOperatorMutator,/,)/,2,0.005524496,bitlen <mask> 8,"bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen<mask>8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4292,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1053,40766,40768,BinaryOperatorMutator,/,%,3,0.0047038374,bitlen <mask> 8,"bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen<mask>8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4293,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1053,40766,40768,BinaryOperatorMutator,/,*,4,0.004628589,bitlen <mask> 8,"bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen<mask>8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4294,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1053,40760,40765,IdentifierMutator-Variable,bitlen,len,0,0.24148533,<mask>," = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst =<mask> / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4295,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1053,40760,40765,IdentifierMutator-Variable,bitlen,src,1,0.12174079,<mask>," = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst =<mask> / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4296,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1053,40760,40765,IdentifierMutator-Variable,bitlen,64,2,0.052029595,<mask>," = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst =<mask> / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4297,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1053,40760,40765,IdentifierMutator-Variable,bitlen,8,3,0.03793712,<mask>," = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst =<mask> / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4298,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1053,40760,40765,IdentifierMutator-Variable,bitlen,size,4,0.033401415,<mask>," = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst =<mask> / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4299,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1053,40769,40769,IdentifierMutator-Literal,8,2,1,0.01293465,<mask>,"len + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen /<mask> - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4300,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1053,40769,40769,IdentifierMutator-Literal,8,4,2,0.005816742,<mask>,"len + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen /<mask> - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4301,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1053,40769,40769,IdentifierMutator-Literal,8,7,3,0.0017996825,<mask>,"len + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen /<mask> - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4302,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1053,40769,40769,IdentifierMutator-Literal,8,3,4,0.0014576969,<mask>,"len + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen /<mask> - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4303,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1053,40773,40775,IdentifierMutator-Variable,len,1,0,0.704221,<mask>," 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 -<mask>; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4304,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1053,40773,40775,IdentifierMutator-Variable,len,2,2,0.031460054,<mask>," 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 -<mask>; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4305,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1053,40773,40775,IdentifierMutator-Variable,len,4,3,0.0065544904,<mask>," 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 -<mask>; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4306,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1053,40773,40775,IdentifierMutator-Variable,len,0,4,0.0050731213,<mask>," 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 -<mask>; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4307,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1054,40854,40856,BinaryOperatorMutator,/,*,1,0.081972696,bitlen <mask> 8,"      if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen<mask>8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4308,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1054,40854,40856,BinaryOperatorMutator,/,)/,2,0.011129106,bitlen <mask> 8,"      if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen<mask>8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4309,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1054,40854,40856,BinaryOperatorMutator,/,+,3,0.009592882,bitlen <mask> 8,"      if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen<mask>8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4310,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1054,40848,40853,IdentifierMutator-Variable,bitlen,len,0,0.97348195,<mask>,"        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[<mask> / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4311,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1054,40848,40853,IdentifierMutator-Variable,bitlen,Len,1,0.004694517,<mask>,"        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[<mask> / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4312,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1054,40848,40853,IdentifierMutator-Variable,bitlen,8,2,0.003338404,<mask>,"        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[<mask> / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4313,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1054,40848,40853,IdentifierMutator-Variable,bitlen,len,3,0.002493743,<mask>,"        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[<mask> / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4314,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1054,40848,40853,IdentifierMutator-Variable,bitlen,64,4,0.0013884339,<mask>,"        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[<mask> / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4315,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1054,40857,40857,IdentifierMutator-Literal,8,2,1,0.012058348,<mask>,"     if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen /<mask>];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4316,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1054,40857,40857,IdentifierMutator-Literal,8,4,2,0.0110394545,<mask>,"     if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen /<mask>];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4317,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1054,40857,40857,IdentifierMutator-Literal,8,6,3,0.0028689392,<mask>,"     if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen /<mask>];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4318,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1054,40857,40857,IdentifierMutator-Literal,8,16,4,0.002247962,<mask>,"     if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen /<mask>];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4319,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1055,40876,40884,MethodCallMutator,arraycopy,copy,0,0.99759585,"System.<mask>(bigBytes, startSrc, resizedBytes, startDst, len)","() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.<mask>(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4320,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1055,40876,40884,MethodCallMutator,arraycopy,array,1,3.2043117E-4,"System.<mask>(bigBytes, startSrc, resizedBytes, startDst, len)","() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.<mask>(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4321,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1055,40876,40884,MethodCallMutator,arraycopy,fill,2,3.0976618E-4,"System.<mask>(bigBytes, startSrc, resizedBytes, startDst, len)","() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.<mask>(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4322,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1055,40876,40884,MethodCallMutator,arraycopy,abs,3,2.5887712E-4,"System.<mask>(bigBytes, startSrc, resizedBytes, startDst, len)","() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.<mask>(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4323,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1055,40876,40884,MethodCallMutator,arraycopy,printf,4,2.1275487E-4,"System.<mask>(bigBytes, startSrc, resizedBytes, startDst, len)","() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.<mask>(bigBytes, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4324,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1055,40886,40893,IdentifierMutator-Variable,bigBytes,bytes,0,0.6258725,<mask>,") != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(<mask>, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4325,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1055,40886,40893,IdentifierMutator-Variable,bigBytes,buf,1,0.07608221,<mask>,") != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(<mask>, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4326,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1055,40886,40893,IdentifierMutator-Variable,bigBytes,data,2,0.06558221,<mask>,") != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(<mask>, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4327,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1055,40886,40893,IdentifierMutator-Variable,bigBytes,buffer,3,0.037495412,<mask>,") != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(<mask>, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4328,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1055,40886,40893,IdentifierMutator-Variable,bigBytes,array,4,0.03456289,<mask>,") != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(<mask>, startSrc, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4329,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1055,40896,40903,IdentifierMutator-Variable,startSrc,0,0,0.9043985,<mask>,") && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes,<mask>, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4330,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1055,40896,40903,IdentifierMutator-Variable,startSrc,src,1,0.037909202,<mask>,") && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes,<mask>, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4331,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1055,40896,40903,IdentifierMutator-Variable,startSrc,start,2,0.01425248,<mask>,") && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes,<mask>, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4332,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1055,40896,40903,IdentifierMutator-Variable,startSrc,offset,3,0.008289592,<mask>,") && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes,<mask>, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4333,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1055,40896,40903,IdentifierMutator-Variable,startSrc,0,4,0.0057999636,<mask>,") && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes,<mask>, resizedBytes, startDst, len);
        return resizedBytes;
    }"
4334,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1055,40906,40917,IdentifierMutator-Variable,resizedBytes,bytes,0,0.7497938,<mask>,"bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc,<mask>, startDst, len);
        return resizedBytes;
    }"
4335,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1055,40906,40917,IdentifierMutator-Variable,resizedBytes,data,1,0.023462327,<mask>,"bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc,<mask>, startDst, len);
        return resizedBytes;
    }"
4336,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1055,40906,40917,IdentifierMutator-Variable,resizedBytes,arr,2,0.0233899,<mask>,"bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc,<mask>, startDst, len);
        return resizedBytes;
    }"
4337,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1055,40906,40917,IdentifierMutator-Variable,resizedBytes,buf,3,0.022987185,<mask>,"bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc,<mask>, startDst, len);
        return resizedBytes;
    }"
4338,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1055,40906,40917,IdentifierMutator-Variable,resizedBytes,array,4,0.018114606,<mask>,"bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc,<mask>, startDst, len);
        return resizedBytes;
    }"
4339,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1055,40920,40927,IdentifierMutator-Variable,startDst,0,0,0.9683424,<mask>,"Length() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes,<mask>, len);
        return resizedBytes;
    }"
4340,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1055,40920,40927,IdentifierMutator-Variable,startDst,off,1,0.0064939056,<mask>,"Length() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes,<mask>, len);
        return resizedBytes;
    }"
4341,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1055,40920,40927,IdentifierMutator-Variable,startDst,1,2,0.0051957383,<mask>,"Length() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes,<mask>, len);
        return resizedBytes;
    }"
4342,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1055,40920,40927,IdentifierMutator-Variable,startDst,offset,3,0.004979938,<mask>,"Length() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes,<mask>, len);
        return resizedBytes;
    }"
4343,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1055,40920,40927,IdentifierMutator-Variable,startDst,start,4,0.004014385,<mask>,"Length() / 8) + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes,<mask>, len);
        return resizedBytes;
    }"
4344,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1055,40930,40932,IdentifierMutator-Variable,len,Len,2,0.0011227366,<mask>,") + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst,<mask>);
        return resizedBytes;
    }"
4345,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1055,40930,40932,IdentifierMutator-Variable,len,length,3,4.8368544E-4,<mask>,") + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst,<mask>);
        return resizedBytes;
    }"
4346,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1055,40930,40932,IdentifierMutator-Variable,len,n,4,3.130909E-4,<mask>,") + 1) == (bitlen / 8))) {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst,<mask>);
        return resizedBytes;
    }"
4347,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1056,40951,40962,IdentifierMutator-Variable,resizedBytes,true,0,0.16599308,<mask>," {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return<mask>;
    }"
4348,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1056,40951,40962,IdentifierMutator-Variable,resizedBytes,ret,1,0.1373218,<mask>," {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return<mask>;
    }"
4349,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1056,40951,40962,IdentifierMutator-Variable,resizedBytes,0,2,0.11892544,<mask>," {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return<mask>;
    }"
4350,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1056,40951,40962,IdentifierMutator-Variable,resizedBytes,len,3,0.10996403,<mask>," {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return<mask>;
    }"
4351,Base64.java,toIntegerBytes,byte[] toIntegerBytes(BigInteger bigInt),1035,1056,40951,40962,IdentifierMutator-Variable,resizedBytes,res,4,0.077649586,<mask>," {
            return bigBytes;
        }
        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0) {
            startSrc = 1;
            len--;
        }
        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];
        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
        return<mask>;
    }"
4352,Base64.java,reset,void reset(),1062,1063,41102,41102,AssignmentMutator,buffer=null,Data,0,0.07159031,buffer <mask>= null,"void reset() {
        buffer<mask>= null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4353,Base64.java,reset,void reset(),1062,1063,41102,41102,AssignmentMutator,buffer=null,List,1,0.068108216,buffer <mask>= null,"void reset() {
        buffer<mask>= null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4354,Base64.java,reset,void reset(),1062,1063,41102,41102,AssignmentMutator,buffer=null,_,2,0.06616849,buffer <mask>= null,"void reset() {
        buffer<mask>= null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4355,Base64.java,reset,void reset(),1062,1063,41102,41102,AssignmentMutator,buffer=null,Pool,3,0.06374878,buffer <mask>= null,"void reset() {
        buffer<mask>= null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4356,Base64.java,reset,void reset(),1062,1063,41102,41102,AssignmentMutator,buffer=null,Info,4,0.031458925,buffer <mask>= null,"void reset() {
        buffer<mask>= null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4357,Base64.java,reset,void reset(),1062,1063,41096,41101,IdentifierMutator-Variable,buffer,reader,1,0.07818558,<mask>,"void reset() {<mask> = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4358,Base64.java,reset,void reset(),1062,1063,41096,41101,IdentifierMutator-Variable,buffer,line,2,0.049444243,<mask>,"void reset() {<mask> = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4359,Base64.java,reset,void reset(),1062,1063,41096,41101,IdentifierMutator-Variable,buffer,file,3,0.034612086,<mask>,"void reset() {<mask> = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4360,Base64.java,reset,void reset(),1062,1063,41096,41101,IdentifierMutator-Variable,buffer,stream,4,0.033980455,<mask>,"void reset() {<mask> = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4361,Base64.java,reset,void reset(),1062,1063,41096,41101,FieldReferenceMutator,buffer,reader,1,0.07818558,<mask>,"void reset() {<mask> = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4362,Base64.java,reset,void reset(),1062,1063,41096,41101,FieldReferenceMutator,buffer,line,2,0.049444243,<mask>,"void reset() {<mask> = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4363,Base64.java,reset,void reset(),1062,1063,41096,41101,FieldReferenceMutator,buffer,file,3,0.034612086,<mask>,"void reset() {<mask> = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4364,Base64.java,reset,void reset(),1062,1063,41096,41101,FieldReferenceMutator,buffer,stream,4,0.033980455,<mask>,"void reset() {<mask> = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4365,Base64.java,reset,void reset(),1062,1063,41105,41108,IdentifierMutator-Literal,null,"""""",1,0.07173865,<mask>,"void reset() {
        buffer =<mask>;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4366,Base64.java,reset,void reset(),1062,1063,41105,41108,IdentifierMutator-Literal,null,0,2,0.029990716,<mask>,"void reset() {
        buffer =<mask>;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4367,Base64.java,reset,void reset(),1062,1063,41105,41108,IdentifierMutator-Literal,null,"''",3,0.020619337,<mask>,"void reset() {
        buffer =<mask>;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4368,Base64.java,reset,void reset(),1062,1063,41105,41108,IdentifierMutator-Literal,null,false,4,0.004369159,<mask>,"void reset() {
        buffer =<mask>;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4369,Base64.java,reset,void reset(),1062,1064,41122,41122,AssignmentMutator,pos=0,|,0,0.4901789,pos <mask>= 0,"void reset() {
        buffer = null;
        pos<mask>= 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4370,Base64.java,reset,void reset(),1062,1064,41122,41122,AssignmentMutator,pos=0,*,1,0.14493254,pos <mask>= 0,"void reset() {
        buffer = null;
        pos<mask>= 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4371,Base64.java,reset,void reset(),1062,1064,41122,41122,AssignmentMutator,pos=0,>>,2,0.07640264,pos <mask>= 0,"void reset() {
        buffer = null;
        pos<mask>= 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4372,Base64.java,reset,void reset(),1062,1064,41122,41122,AssignmentMutator,pos=0,<<,3,0.05094505,pos <mask>= 0,"void reset() {
        buffer = null;
        pos<mask>= 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4373,Base64.java,reset,void reset(),1062,1064,41122,41122,AssignmentMutator,pos=0,&,4,0.042873614,pos <mask>= 0,"void reset() {
        buffer = null;
        pos<mask>= 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4374,Base64.java,reset,void reset(),1062,1064,41119,41121,IdentifierMutator-Variable,pos,offset,0,0.27125272,<mask>,"void reset() {
        buffer = null;<mask> = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4375,Base64.java,reset,void reset(),1062,1064,41119,41121,IdentifierMutator-Variable,pos,position,2,0.12208049,<mask>,"void reset() {
        buffer = null;<mask> = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4376,Base64.java,reset,void reset(),1062,1064,41119,41121,IdentifierMutator-Variable,pos,length,3,0.09401891,<mask>,"void reset() {
        buffer = null;<mask> = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4377,Base64.java,reset,void reset(),1062,1064,41119,41121,IdentifierMutator-Variable,pos,count,4,0.032574717,<mask>,"void reset() {
        buffer = null;<mask> = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4378,Base64.java,reset,void reset(),1062,1064,41119,41121,FieldReferenceMutator,pos,offset,0,0.27125272,<mask>,"void reset() {
        buffer = null;<mask> = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4379,Base64.java,reset,void reset(),1062,1064,41119,41121,FieldReferenceMutator,pos,position,2,0.12208049,<mask>,"void reset() {
        buffer = null;<mask> = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4380,Base64.java,reset,void reset(),1062,1064,41119,41121,FieldReferenceMutator,pos,length,3,0.09401891,<mask>,"void reset() {
        buffer = null;<mask> = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4381,Base64.java,reset,void reset(),1062,1064,41119,41121,FieldReferenceMutator,pos,count,4,0.032574717,<mask>,"void reset() {
        buffer = null;<mask> = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4382,Base64.java,reset,void reset(),1062,1064,41125,41125,IdentifierMutator-Literal,0,null,1,0.012261926,<mask>,"void reset() {
        buffer = null;
        pos =<mask>;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4383,Base64.java,reset,void reset(),1062,1064,41125,41125,IdentifierMutator-Literal,0,1,2,0.004182846,<mask>,"void reset() {
        buffer = null;
        pos =<mask>;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4384,Base64.java,reset,void reset(),1062,1064,41125,41125,IdentifierMutator-Literal,0,pos,3,0.002392879,<mask>,"void reset() {
        buffer = null;
        pos =<mask>;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4385,Base64.java,reset,void reset(),1062,1064,41125,41125,IdentifierMutator-Literal,0,false,4,0.0019585544,<mask>,"void reset() {
        buffer = null;
        pos =<mask>;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4386,Base64.java,reset,void reset(),1062,1065,41143,41143,AssignmentMutator,readPos=0,|,0,0.42254975,readPos <mask>= 0,"void reset() {
        buffer = null;
        pos = 0;
        readPos<mask>= 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4387,Base64.java,reset,void reset(),1062,1065,41143,41143,AssignmentMutator,readPos=0,*,1,0.1987296,readPos <mask>= 0,"void reset() {
        buffer = null;
        pos = 0;
        readPos<mask>= 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4388,Base64.java,reset,void reset(),1062,1065,41143,41143,AssignmentMutator,readPos=0,&,2,0.071804106,readPos <mask>= 0,"void reset() {
        buffer = null;
        pos = 0;
        readPos<mask>= 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4389,Base64.java,reset,void reset(),1062,1065,41143,41143,AssignmentMutator,readPos=0,<<,3,0.070528805,readPos <mask>= 0,"void reset() {
        buffer = null;
        pos = 0;
        readPos<mask>= 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4390,Base64.java,reset,void reset(),1062,1065,41143,41143,AssignmentMutator,readPos=0,/,4,0.039192457,readPos <mask>= 0,"void reset() {
        buffer = null;
        pos = 0;
        readPos<mask>= 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4391,Base64.java,reset,void reset(),1062,1065,41136,41142,IdentifierMutator-Variable,readPos,length,0,0.15366279,<mask>,"void reset() {
        buffer = null;
        pos = 0;<mask> = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4392,Base64.java,reset,void reset(),1062,1065,41136,41142,IdentifierMutator-Variable,readPos,line,1,0.10980444,<mask>,"void reset() {
        buffer = null;
        pos = 0;<mask> = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4393,Base64.java,reset,void reset(),1062,1065,41136,41142,IdentifierMutator-Variable,readPos,offset,2,0.08136528,<mask>,"void reset() {
        buffer = null;
        pos = 0;<mask> = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4394,Base64.java,reset,void reset(),1062,1065,41136,41142,IdentifierMutator-Variable,readPos,len,3,0.03876669,<mask>,"void reset() {
        buffer = null;
        pos = 0;<mask> = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4395,Base64.java,reset,void reset(),1062,1065,41136,41142,IdentifierMutator-Variable,readPos,index,4,0.028189087,<mask>,"void reset() {
        buffer = null;
        pos = 0;<mask> = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4396,Base64.java,reset,void reset(),1062,1065,41136,41142,FieldReferenceMutator,readPos,length,0,0.15366279,<mask>,"void reset() {
        buffer = null;
        pos = 0;<mask> = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4397,Base64.java,reset,void reset(),1062,1065,41136,41142,FieldReferenceMutator,readPos,line,1,0.10980444,<mask>,"void reset() {
        buffer = null;
        pos = 0;<mask> = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4398,Base64.java,reset,void reset(),1062,1065,41136,41142,FieldReferenceMutator,readPos,offset,2,0.08136528,<mask>,"void reset() {
        buffer = null;
        pos = 0;<mask> = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4399,Base64.java,reset,void reset(),1062,1065,41136,41142,FieldReferenceMutator,readPos,len,3,0.03876669,<mask>,"void reset() {
        buffer = null;
        pos = 0;<mask> = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4400,Base64.java,reset,void reset(),1062,1065,41136,41142,FieldReferenceMutator,readPos,index,4,0.028189087,<mask>,"void reset() {
        buffer = null;
        pos = 0;<mask> = 0;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4401,Base64.java,reset,void reset(),1062,1065,41146,41146,IdentifierMutator-Literal,0,null,1,0.0055957786,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos =<mask>;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4402,Base64.java,reset,void reset(),1062,1065,41146,41146,IdentifierMutator-Literal,0,1,2,0.0045285965,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos =<mask>;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4403,Base64.java,reset,void reset(),1062,1065,41146,41146,IdentifierMutator-Literal,0,false,3,0.0026240894,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos =<mask>;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4404,Base64.java,reset,void reset(),1062,1065,41146,41146,IdentifierMutator-Literal,0,zero,4,5.8432756E-4,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos =<mask>;
        currentLinePos = 0;
        modulus = 0;
        eof = false;
    }"
4405,Base64.java,reset,void reset(),1062,1066,41171,41171,AssignmentMutator,currentLinePos=0,|,0,0.3252196,currentLinePos <mask>= 0,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos<mask>= 0;
        modulus = 0;
        eof = false;
    }"
4406,Base64.java,reset,void reset(),1062,1066,41171,41171,AssignmentMutator,currentLinePos=0,*,1,0.21810818,currentLinePos <mask>= 0,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos<mask>= 0;
        modulus = 0;
        eof = false;
    }"
4407,Base64.java,reset,void reset(),1062,1066,41171,41171,AssignmentMutator,currentLinePos=0,<<,2,0.116552,currentLinePos <mask>= 0,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos<mask>= 0;
        modulus = 0;
        eof = false;
    }"
4408,Base64.java,reset,void reset(),1062,1066,41171,41171,AssignmentMutator,currentLinePos=0,||,3,0.07053653,currentLinePos <mask>= 0,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos<mask>= 0;
        modulus = 0;
        eof = false;
    }"
4409,Base64.java,reset,void reset(),1062,1066,41171,41171,AssignmentMutator,currentLinePos=0,&,4,0.049070105,currentLinePos <mask>= 0,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos<mask>= 0;
        modulus = 0;
        eof = false;
    }"
4410,Base64.java,reset,void reset(),1062,1066,41157,41170,IdentifierMutator-Variable,currentLinePos,length,0,0.12613648,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;<mask> = 0;
        modulus = 0;
        eof = false;
    }"
4411,Base64.java,reset,void reset(),1062,1066,41157,41170,IdentifierMutator-Variable,currentLinePos,offset,1,0.06150515,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;<mask> = 0;
        modulus = 0;
        eof = false;
    }"
4412,Base64.java,reset,void reset(),1062,1066,41157,41170,IdentifierMutator-Variable,currentLinePos,len,2,0.05087585,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;<mask> = 0;
        modulus = 0;
        eof = false;
    }"
4413,Base64.java,reset,void reset(),1062,1066,41157,41170,IdentifierMutator-Variable,currentLinePos,size,3,0.04989753,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;<mask> = 0;
        modulus = 0;
        eof = false;
    }"
4414,Base64.java,reset,void reset(),1062,1066,41157,41170,IdentifierMutator-Variable,currentLinePos,count,4,0.04040517,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;<mask> = 0;
        modulus = 0;
        eof = false;
    }"
4415,Base64.java,reset,void reset(),1062,1066,41157,41170,FieldReferenceMutator,currentLinePos,length,0,0.12613648,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;<mask> = 0;
        modulus = 0;
        eof = false;
    }"
4416,Base64.java,reset,void reset(),1062,1066,41157,41170,FieldReferenceMutator,currentLinePos,offset,1,0.06150515,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;<mask> = 0;
        modulus = 0;
        eof = false;
    }"
4417,Base64.java,reset,void reset(),1062,1066,41157,41170,FieldReferenceMutator,currentLinePos,len,2,0.05087585,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;<mask> = 0;
        modulus = 0;
        eof = false;
    }"
4418,Base64.java,reset,void reset(),1062,1066,41157,41170,FieldReferenceMutator,currentLinePos,size,3,0.04989753,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;<mask> = 0;
        modulus = 0;
        eof = false;
    }"
4419,Base64.java,reset,void reset(),1062,1066,41157,41170,FieldReferenceMutator,currentLinePos,count,4,0.04040517,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;<mask> = 0;
        modulus = 0;
        eof = false;
    }"
4420,Base64.java,reset,void reset(),1062,1066,41174,41174,IdentifierMutator-Literal,0,null,1,0.012948825,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos =<mask>;
        modulus = 0;
        eof = false;
    }"
4421,Base64.java,reset,void reset(),1062,1066,41174,41174,IdentifierMutator-Literal,0,1,2,0.00658629,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos =<mask>;
        modulus = 0;
        eof = false;
    }"
4422,Base64.java,reset,void reset(),1062,1066,41174,41174,IdentifierMutator-Literal,0,false,3,0.0038040658,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos =<mask>;
        modulus = 0;
        eof = false;
    }"
4423,Base64.java,reset,void reset(),1062,1066,41174,41174,IdentifierMutator-Literal,0,undefined,4,0.0011471427,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos =<mask>;
        modulus = 0;
        eof = false;
    }"
4424,Base64.java,reset,void reset(),1062,1067,41192,41192,AssignmentMutator,modulus=0,|,0,0.37451282,modulus <mask>= 0,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus<mask>= 0;
        eof = false;
    }"
4425,Base64.java,reset,void reset(),1062,1067,41192,41192,AssignmentMutator,modulus=0,*,1,0.3215155,modulus <mask>= 0,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus<mask>= 0;
        eof = false;
    }"
4426,Base64.java,reset,void reset(),1062,1067,41192,41192,AssignmentMutator,modulus=0,^,2,0.12662207,modulus <mask>= 0,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus<mask>= 0;
        eof = false;
    }"
4427,Base64.java,reset,void reset(),1062,1067,41192,41192,AssignmentMutator,modulus=0,&,3,0.059786137,modulus <mask>= 0,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus<mask>= 0;
        eof = false;
    }"
4428,Base64.java,reset,void reset(),1062,1067,41192,41192,AssignmentMutator,modulus=0,<<,4,0.023140948,modulus <mask>= 0,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus<mask>= 0;
        eof = false;
    }"
4429,Base64.java,reset,void reset(),1062,1067,41185,41191,IdentifierMutator-Variable,modulus,pos,0,0.21849275,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;<mask> = 0;
        eof = false;
    }"
4430,Base64.java,reset,void reset(),1062,1067,41185,41191,IdentifierMutator-Variable,modulus,line,1,0.14301813,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;<mask> = 0;
        eof = false;
    }"
4431,Base64.java,reset,void reset(),1062,1067,41185,41191,IdentifierMutator-Variable,modulus,offset,2,0.11567888,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;<mask> = 0;
        eof = false;
    }"
4432,Base64.java,reset,void reset(),1062,1067,41185,41191,IdentifierMutator-Variable,modulus,length,3,0.08439825,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;<mask> = 0;
        eof = false;
    }"
4433,Base64.java,reset,void reset(),1062,1067,41185,41191,IdentifierMutator-Variable,modulus,index,4,0.028484449,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;<mask> = 0;
        eof = false;
    }"
4434,Base64.java,reset,void reset(),1062,1067,41185,41191,FieldReferenceMutator,modulus,pos,0,0.21849275,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;<mask> = 0;
        eof = false;
    }"
4435,Base64.java,reset,void reset(),1062,1067,41185,41191,FieldReferenceMutator,modulus,line,1,0.14301813,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;<mask> = 0;
        eof = false;
    }"
4436,Base64.java,reset,void reset(),1062,1067,41185,41191,FieldReferenceMutator,modulus,offset,2,0.11567888,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;<mask> = 0;
        eof = false;
    }"
4437,Base64.java,reset,void reset(),1062,1067,41185,41191,FieldReferenceMutator,modulus,length,3,0.08439825,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;<mask> = 0;
        eof = false;
    }"
4438,Base64.java,reset,void reset(),1062,1067,41185,41191,FieldReferenceMutator,modulus,index,4,0.028484449,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;<mask> = 0;
        eof = false;
    }"
4439,Base64.java,reset,void reset(),1062,1067,41195,41195,IdentifierMutator-Literal,0,1,1,0.099731855,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus =<mask>;
        eof = false;
    }"
4440,Base64.java,reset,void reset(),1062,1067,41195,41195,IdentifierMutator-Literal,0,null,2,0.010692796,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus =<mask>;
        eof = false;
    }"
4441,Base64.java,reset,void reset(),1062,1067,41195,41195,IdentifierMutator-Literal,0,false,3,0.0062312614,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus =<mask>;
        eof = false;
    }"
4442,Base64.java,reset,void reset(),1062,1067,41195,41195,IdentifierMutator-Literal,0,2,4,0.005245677,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus =<mask>;
        eof = false;
    }"
4443,Base64.java,reset,void reset(),1062,1068,41209,41209,AssignmentMutator,eof=false,Flag,0,0.15248011,eof <mask>= false,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof<mask>= false;
    }"
4444,Base64.java,reset,void reset(),1062,1068,41209,41209,AssignmentMutator,eof=false,Found,1,0.08163081,eof <mask>= false,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof<mask>= false;
    }"
4445,Base64.java,reset,void reset(),1062,1068,41209,41209,AssignmentMutator,eof=false,flag,2,0.041007932,eof <mask>= false,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof<mask>= false;
    }"
4446,Base64.java,reset,void reset(),1062,1068,41209,41209,AssignmentMutator,eof=false,Ok,3,0.038225308,eof <mask>= false,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof<mask>= false;
    }"
4447,Base64.java,reset,void reset(),1062,1068,41209,41209,AssignmentMutator,eof=false,Match,4,0.03317603,eof <mask>= false,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof<mask>= false;
    }"
4448,Base64.java,reset,void reset(),1062,1068,41206,41208,IdentifierMutator-Variable,eof,valid,0,0.05957121,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;<mask> = false;
    }"
4449,Base64.java,reset,void reset(),1062,1068,41206,41208,IdentifierMutator-Variable,eof,modified,1,0.034466684,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;<mask> = false;
    }"
4450,Base64.java,reset,void reset(),1062,1068,41206,41208,IdentifierMutator-Variable,eof,done,2,0.031822406,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;<mask> = false;
    }"
4451,Base64.java,reset,void reset(),1062,1068,41206,41208,IdentifierMutator-Variable,eof,changed,3,0.024370342,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;<mask> = false;
    }"
4452,Base64.java,reset,void reset(),1062,1068,41206,41208,IdentifierMutator-Variable,eof,initialized,4,0.023468198,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;<mask> = false;
    }"
4453,Base64.java,reset,void reset(),1062,1068,41206,41208,FieldReferenceMutator,eof,valid,0,0.05957121,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;<mask> = false;
    }"
4454,Base64.java,reset,void reset(),1062,1068,41206,41208,FieldReferenceMutator,eof,modified,1,0.034466684,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;<mask> = false;
    }"
4455,Base64.java,reset,void reset(),1062,1068,41206,41208,FieldReferenceMutator,eof,done,2,0.031822406,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;<mask> = false;
    }"
4456,Base64.java,reset,void reset(),1062,1068,41206,41208,FieldReferenceMutator,eof,changed,3,0.024370342,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;<mask> = false;
    }"
4457,Base64.java,reset,void reset(),1062,1068,41206,41208,FieldReferenceMutator,eof,initialized,4,0.023468198,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;<mask> = false;
    }"
4458,Base64.java,reset,void reset(),1062,1068,41212,41216,IdentifierMutator-Literal,false,true,0,0.4440178,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof =<mask>;
    }"
4459,Base64.java,reset,void reset(),1062,1068,41212,41216,IdentifierMutator-Literal,false,0,2,0.18760204,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof =<mask>;
    }"
4460,Base64.java,reset,void reset(),1062,1068,41212,41216,IdentifierMutator-Literal,false,null,3,0.02340096,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof =<mask>;
    }"
4461,Base64.java,reset,void reset(),1062,1068,41212,41216,IdentifierMutator-Literal,false,1,4,0.0042812945,<mask>,"void reset() {
        buffer = null;
        pos = 0;
        readPos = 0;
        currentLinePos = 0;
        modulus = 0;
        eof =<mask>;
    }"
